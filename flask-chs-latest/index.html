<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Flask 0.10.1 文档</title>
    
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/badge_only.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.10.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="None" href="index.html#document-index" />

   
  
  <link rel="apple-touch-icon" href="_static/touch-icon.png" />
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />
  <script src="_static/functions.js" type="text/javascript"></script>

<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://flask-chs.readthedocs.org/zh_CN/latest/" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "flask-chs",
    version: "latest",
    language: "zh_CN",
    page: "index",
    theme: "flask",
    docroot: "/",
    api_host: "https://readthedocs.org"
  }
  // Old variables
  var doc_version = "latest";
  var doc_slug = "flask-chs";
  var page_name = "index";
  var html_theme = "flask";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->

  </head>
  <body>
  
  
  <div class=indexwrapper>
  

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li><a href="index.html#document-index">Flask 0.10.1 文档</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="flask">
<h1>欢迎使用 Flask<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h1>
<img alt="Flask: web development, one drop at a time" class="floatingflask" src="_images/logo-full.png" />
<p>欢迎阅读 Flask 文档。  本文档分为几个部分。我推荐您先从
<a class="reference internal" href="index.html#installation"><em>安装</em></a> 开始，之后再浏览 <a class="reference internal" href="index.html#quickstart"><em>快速入门</em></a> 章节。
<a class="reference internal" href="index.html#tutorial"><em>教程</em></a> 比快速入门更详细地介绍了如何用 Flask 创建一个完整的
应用（虽然很小）。
想要深入了解 Flask 内部细节，请查阅 <a class="reference internal" href="index.html#api"><em>API</em></a> 文档。
<a class="reference internal" href="index.html#patterns"><em>Flask 代码模式</em></a> 章节介绍了一些常见模式。</p>
<p>Flask 依赖两个外部库： <a class="reference external" href="http://jinja.pocoo.org/2/">Jinja2</a> 模板引擎和 <a class="reference external" href="http://werkzeug.pocoo.org/">Werkzeug</a> WSGI 工具
集。此文档不包含这两个库的文档。要细读它们的文档，请点击下面的链接：</p>
<ul class="simple">
<li><a class="reference external" href="http://jinja.pocoo.org/2/documentation/">Jinja2 文档</a></li>
<li><a class="reference external" href="http://werkzeug.pocoo.org/documentation/">Werkzeug 文档</a></li>
</ul>
<div class="section" id="id3">
<h2>用户指南<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>这部分文档很枯燥，以介绍 Flask 的背景开始，然后注重说明 Flask 的 Web 开发的各个步骤。</p>
<div class="toctree-wrapper compound">
<span id="document-foreword"></span><div class="section" id="id1">
<h3>前言<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>请在使用 Flask 前阅读。希望本文能回答你一些关于 Flask 的用途和目标以及
Flask 适用情境的问题。</p>
<div class="section" id="id2">
<h4>“微” 是什么意思？<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>“微”(micro) 并不表示你需要把整个 Web 应用塞进单个 Python 文件（虽然确实可以
），也不意味着 Flask 在功能上有所欠缺。微框架中的“微”意味着 Flask 旨在保持核心
简单且易扩展。Flask 不会替你作出过多选择，比如使用何种数据库。并且，Flask
已经选择好的，比如使用何种模板引擎，是易于修改的。除此之外的一切都取决于你，
因此 Flask 可以满足你的一切需求。</p>
<p>默认情况下，Flask 不包含数据库抽象层、表单验证或是任何其它现有库可以胜任的东
西。作为替代的是，Flask 支持扩展来给应用添加这些功能，如同是在 Flask 自身
中实现。众多的扩展提供了数据库集成、表单验证、上传处理、多种开放认证技术等功
能。Flask 可能是“微小”的，但它已经能在需求繁杂的生产环境中投入使用。</p>
</div>
<div class="section" id="id3">
<h4>配置与惯例<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Flask 数目众多的配置选项在初始状况下都有一个明智的默认值，并遵循一些惯例。
例如，按照惯例，模板和静态文件存储在应用的 Python 源代码树下的子目录中，名称
分别为 <cite>templates</cite> 和 <cite>static</cite> 。虽然可以更改这个配置，但你通常不必这么做，
尤其是在刚接触 Flask 的时候。</p>
</div>
<div class="section" id="flask">
<h4>与 Flask 共成长<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h4>
<p>当你配置好并运行 Flask，你会发现社区中有许多可以集成到生产环境项目的扩
展。Flask 核心团队会审阅这些扩展，确保经过检验的扩展在未来版本中仍能适用。</p>
<p>随着你的代码库逐渐庞大，你仍会在把握项目设计决策上拥有自由。Flask 会继续尽可
能提供 Python 应该提供的一个非常简单的胶水层。你可以在 SQLAlchemy 或其它数据
库工具中实现更高级的模式，酌情引入非关系型数据持久化，也可以从框架无关的 WSGI
（Python 的 Web 接口） 工具中获益。</p>
<p>Flask 里有许多可以定制其行为的钩子。如若你需要更深层次的定制，可以继承 Flask 类。
如果你对此有兴趣，请阅读 <a class="reference internal" href="index.html#becomingbig"><em>聚沙成塔</em></a> 章节。如果你好奇 Flask 的设计原
则，请查阅 <a class="reference internal" href="index.html#design"><em>Flask 中的设计决策</em></a> 章节。</p>
<p>继续阅读 <a class="reference internal" href="index.html#installation"><em>安装</em></a> 、 <a class="reference internal" href="index.html#quickstart"><em>快速入门</em></a> 、或
<a class="reference internal" href="index.html#advanced-foreword"><em>给有经验程序员的前言</em></a>.</p>
</div>
</div>
<span id="document-advanced_foreword"></span><div class="section" id="advanced-foreword">
<span id="id1"></span><h3>给有经验程序员的前言<a class="headerlink" href="#advanced-foreword" title="永久链接至标题">¶</a></h3>
<p>本章节是给有其它框架工作经验的程序员，以及有具体或深刻涉及那些的典型用户，</p>
<div class="section" id="flask">
<span id="thread-in-flask"></span><h4>Flask 中的线程局部变量<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h4>
<p>Flask 的设计抉择之一就是，简单的任务应该保持简单；它们的实现不应是大量代码的
堆叠，并不应该限制到你。为此，我们选择了一些可能让某些人觉得惊讶或异端的设
计。例如，Flask 内部使用线程局部的对象，这样你不必在请求内的函数间传递对象来
保证线程安全。这个方法很方便，但为依赖注入，或尝试重用使用了与请求挂钩的值的
代码，需要一个有效的请求上下文。</p>
</div>
<div class="section" id="web">
<span id="web-development-is-dangerous"></span><h4>Web 开发是危险的<a class="headerlink" href="#web" title="永久链接至标题">¶</a></h4>
<p>请在构建 Web 应用时牢记安全。</p>
<p>如果你编写了一个 Web 应用，你很可能允许用户在你的服务器上注册并留下数据。即
使你是这唯一的用户，也会在应用中留下数据。用户们把数据托付给你，你当然更希望
这些数据被妥善安全地保存。</p>
<p>不幸的是，有许多方式可以让 web 应用的安全措施形同虚设。 Flask 保护你免受现代
Web 应用最常见的一个安全问题的困扰：跨站脚本攻击（XSS）。除非你蓄意把不安全
的 HTML 标记为安全，Flask 和底层的 Jinja2 模板引擎已经为你严防死守。但许多安
全问题依然存在。</p>
<p>本文档会在 web 开发中那些需要注意安全的方面警示你。这些安全考虑中的某些远比
人们想象的复杂，我们有时候低估漏洞被利用的可能性——直到一个聪明的攻击者找出利
用我们程序的方法。并且，不要想着你的应用没有重要到可以吸引攻击者。取决于攻
击的类型，有时候是自动化的僵尸机器搜寻在你数据库中填充垃圾、恶意程序链接或
之类东西的方法。</p>
<p>开发者必须在为需求编写代码时留心安全隐患，在这点上，Flask 与其它框架没有区
别。</p>
</div>
<div class="section" id="python-3">
<span id="the-status-of-python-3"></span><h4>Python 3 的状态<a class="headerlink" href="#python-3" title="永久链接至标题">¶</a></h4>
<p>Python 社区目前处于改善库对 Python 编程语言中迭代支持的进程中。而当前大力改
进中的处境仍有一些问题，使得我们难以迁移到 Python 3 。导致这些问题的原因一部
分是语言中的变更长时间没有复查，一部分也是因为我们没有找出低层 API 应该如何
做出修改来适应 Python 3 中 Unicode 的差异。</p>
<p>一旦应对变更的解决方案出现，Werkzeug 和 Flask 就会立刻迁移到 Python 3 ，
并且我们会提供升级现有应用到 Python 3 的提示。在那之前，我们强烈建议
在开发时使用 Python 2.6 和 2.7 ，并激活 Python 3 警告。如果你计划在近期升级
到 Python 3 ，我们强烈推荐你阅读
<a class="reference external" href="http://lucumr.pocoo.org/2011/1/22/forwards-compatible-python/">如何编写向后兼容的 Python 代码</a> 。</p>
<p>继续阅读 <a class="reference internal" href="index.html#installation"><em>安装</em></a> 或 <a class="reference internal" href="index.html#quickstart"><em>快速入门</em></a> 。</p>
</div>
</div>
<span id="document-installation"></span><div class="section" id="installation">
<span id="id1"></span><h3>安装<a class="headerlink" href="#installation" title="永久链接至标题">¶</a></h3>
<p>Flask 依赖于两个外部库：<a class="reference external" href="http://werkzeug.pocoo.org/">Werkzeug</a> 和 <a class="reference external" href="http://jinja.pocoo.org/2/">Jinja2</a> 。
Werkzeug 是一个 WSGI （在 web 应用和多种服务器之间开发和部署的标
准 Python 接口) 的工具集Jinja2 负责渲染模板。</p>
<p>那么如何在你的电脑上安装这一切？虽说条条大道通罗马，但是最强大的方式是
virtualenv ，所以我们首先来看它。</p>
<p>你首先需要 Python 2.6 或更高的版本，所以请确认有一个最新的 Python 2.x 安装。
在 Python 3 中使用 Flask 请参考： <a class="reference internal" href="index.html#python3-support"><em>Python 3 支持</em></a> 。</p>
<div class="section" id="virtualenv">
<span id="id2"></span><h4>virtualenv<a class="headerlink" href="#virtualenv" title="永久链接至标题">¶</a></h4>
<p>你在开发中很可能想要使用 virtualenv，如果你拥有生产环境的 shell 权限，
同样会乐于在生产环境中使用它。</p>
<p>virtualenv 解决了什么问题？如果你像我一样喜欢 Python，你可能还要在基于 Flask
的 web 应用以外的项目中使用它。你拥有的项目越多，同时使用不同版本 Python 工作
的可能性越大，或者至少需要不同版本的 Python 库。我们需要面对的是：常常有库会破坏自身的向后兼容性，
然而正常应用零依赖的可能性也不大。当你的项目中的两个或更多出现依赖性冲突时，你会怎么做？</p>
<p>virtualenv 来拯救世界！virtualenv 允许多个版本的 Python 同时存在，对应不同的项目。
它实际上并没有安装独立的 Python 副本，但是它确实提供了一种巧妙的方式来让各项
目环境保持独立。让我们来看看 virtualenv 是怎么工作的。</p>
<p>如果你在 Mac OS X 或 Linux下，下面两条命令可能会适用:</p>
<div class="highlight-python"><pre>$ sudo easy_install virtualenv</pre>
</div>
<p>或更好的:</p>
<div class="highlight-python"><pre>$ sudo pip install virtualenv</pre>
</div>
<p>上述的命令会在你的系统中安装 virtualenv。它甚至可能会存在于包管理器中，如果
你使用 Ubuntu ，可以尝试:</p>
<div class="highlight-python"><pre>$ sudo apt-get install python-virtualenv</pre>
</div>
<p>如果你所使用的 Windows 上并没有 <cite>easy_install</cite> 命令，你必须先安装它。查阅
<a class="reference internal" href="index.html#windows-easy-install"><em>Windows 下的 pip 和 distribute</em></a> 章节来了解如何安装。之后，运行上述的命令，但是要
去掉 <cite>sudo</cite> 前缀。</p>
<p>virtualenv 安装完毕，你可以立即打开 shell 然后创建你自己的环境。我通常创建一个
项目文件夹，并在其下创建一个 <cite>venv</cite> 文件夹</p>
<div class="highlight-python"><pre>$ mkdir myproject
$ cd myproject
$ virtualenv venv
New python executable in venv/bin/python
Installing distribute............done.</pre>
</div>
<p>现在，无论何时你想在某个项目上工作，只需要激活相应的环境。在 OS X 和 Linux
上，执行如下操作:</p>
<div class="highlight-python"><pre>$ . venv/bin/activate</pre>
</div>
<p>下面的操作适用 Windows:</p>
<div class="highlight-python"><pre>$ venv\scripts\activate</pre>
</div>
<p>无论通过哪种方式，你现在应该已经激活了 virtualenv（注意你的 shell 提示符显示的是
活动的环境）。</p>
<p>现在你只需要键入以下的命令来激活 virtualenv 中的 Flask:</p>
<div class="highlight-python"><pre>$ pip install Flask</pre>
</div>
<p>几秒钟后，一切都搞定了。</p>
</div>
<div class="section" id="id3">
<h4>全局安装<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这样也是可以的，虽然我不推荐。只需要以 root 权限运行 <cite>pip</cite>:</p>
<div class="highlight-python"><pre>$ sudo pip install Flask</pre>
</div>
<p>（在 Windows 上，在管理员权限的命令提示符中去掉 <cite>sudo</cite> 运行这条命令 。）</p>
</div>
<div class="section" id="id4">
<h4>活在边缘<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>如果你需要最新版本的 Flask，有两种方法：你可以使用 <cite>pip</cite> 拉取开发版本，或让
它操作一个 git checkout 。无论哪种方式，依然推荐使用 virtualenv。</p>
<p>在一个全新的 virtualenv 中 git checkout 并运行在开发模式下:</p>
<div class="highlight-python"><pre>$ git clone http://github.com/mitsuhiko/flask.git
Initialized empty Git repository in ~/dev/flask/.git/
$ cd flask
$ virtualenv venv --distribute
New python executable in venv/bin/python
Installing distribute............done.
$ . venv/bin/activate
$ python setup.py develop
...
Finished processing dependencies for Flask</pre>
</div>
<p>这会拉取依赖关系并激活 git head 作为 virtualenv 中的当前版本。然后你只需要执
行 <tt class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span> <span class="pre">origin</span></tt> 来升级到最新版本。</p>
<p>没有 git 时，获取开发版本的替代操作:</p>
<div class="highlight-python"><pre>$ mkdir flask
$ cd flask
$ virtualenv venv --distribute
$ . venv/bin/activate
New python executable in venv/bin/python
Installing distribute............done.
$ pip install Flask==dev
...
Finished processing dependencies for Flask==dev</pre>
</div>
</div>
<div class="section" id="windows-pip-distribute">
<span id="windows-easy-install"></span><h4>Windows 下的 <cite>pip</cite> 和 <cite>distribute</cite><a class="headerlink" href="#windows-pip-distribute" title="永久链接至标题">¶</a></h4>
<p>在 Windows 下， <cite>easy_install</cite> 的安装稍微有点麻烦，但还是相当简单。最简单的
方法是下载 <cite>distribute_setup.py</cite> 文件并运行它。运行这个文件，最简单的方法就
是打开你的下载文件夹并且双击这个文件。</p>
<p>下一步，把你的 Python 安装中的 Scripts 文件夹添加到 <cite>PATH</cite> 环境变量来，这样
<cite>easy_install</cite> 命令和其它 Python 脚本就加入到了命令行自动搜索的路径。做法
是：右键单击桌面上或是“开始”菜单中的“我的电脑”图标，选择“属性”，然后单击“高
级系统设置”（在 Windows XP 中，单击“高级”选项卡），然后单击“环境变量”按钮，
最后双击“系统变量”栏中的“Path”变量，并加入你的 Python 解释器的 Scripts 文件
夹。确保你用分号把它和现有的值分隔开。假设你使用 Python 2.7 且为默认目录，添
加下面的值:</p>
<div class="highlight-python"><pre>;C:\Python27\Scripts</pre>
</div>
<p>于是，你就搞定了！检查它是否正常工作，打开命令提示符并执行
<tt class="docutils literal"><span class="pre">easy_install</span></tt> 。如果你开启了 Windows Vista 或 Windows 7 中的用户账户控
制，它应该会提示你使用管理员权限。</p>
<p>现在你有了 <tt class="docutils literal"><span class="pre">easy_install</span></tt> ，你可以用它来安装 <tt class="docutils literal"><span class="pre">pip</span></tt>:</p>
<div class="highlight-python"><pre>&gt; easy_install pip</pre>
</div>
</div>
</div>
<span id="document-quickstart"></span><div class="section" id="quickstart">
<span id="id1"></span><h3>快速入门<a class="headerlink" href="#quickstart" title="永久链接至标题">¶</a></h3>
<p>迫不及待要开始了吗？本页提供了一个很好的 Flask 介绍，并假定你已经安
装好了 Flask。如果没有，请跳转到 <a class="reference internal" href="index.html#installation"><em>安装</em></a> 章节。</p>
<div class="section" id="id2">
<h4>一个最小的应用<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>一个最小的 Flask 应用看起来是这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World!&#39;</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>把它保存为 <cite>hello.py</cite> （或是类似的），然后用 Python 解释器来运行。
但是确保你的应用没有命名为 <cite>flask.py</cite> ，因为这将与 Flask 本身冲突。</p>
<div class="highlight-python"><pre>$ python hello.py
 * Running on http://127.0.0.1:5000/</pre>
</div>
<p>现在访问 <a class="reference external" href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a> ，你会
看见 hello world 问候。</p>
<p>那么，这段代码做了什么？</p>
<ol class="arabic simple">
<li>首先，我们导入了 <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 类。这个类的实例将会是我
们的 WSGI 应用程序。</li>
<li>接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。
如果你使用单一的模块（如本例），你应该使用 <cite>__name__</cite> ，因为取决于
作为单独应用启动或者模块导入，它的名称将会不同（ <tt class="docutils literal"><span class="pre">'__main__'</span></tt>
相对实际的导入名称）。这是必须的，这样Flask 才会知道到哪里去寻找模板、
静态文件等等。详情参见 <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 的文档。</li>
<li>然后，我们使用 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器告诉 Flask 什么样的
URL 应该触发我们的函数。</li>
<li>这个函数的名字也用作给特定的函数生成 URL，并且返回我们想要显
示在用户浏览器中的信息。</li>
<li>最后我们用 <a class="reference internal" href="index.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 函数来让应用运行在本地服务器上。
其中 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></tt> 确保服务器只会在该脚本被
Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</li>
</ol>
<p>要停止服务器，按 Ctrl+C。</p>
<div class="admonition- admonition" id="public-server">
<p class="first admonition-title">可外部访问的服务器</p>
<p>如果你运行服务器，你会注意到它只能从你自己的计算机上访问，网络中其
它任何的地方都不能访问。这是在默认情况，因为在调试模式，用户可以在你的计算机上执行任意 Python 代码。</p>
<p>如果你禁用了 <cite>debug</cite> 或信任你所在网络的用户，你可以简单修改调用
<a class="reference internal" href="index.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 的方法使你的服务器公开可用，如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">这会让操作系统监听所有公开的IP。</p>
</div>
</div>
<div class="section" id="debug-mode">
<span id="id3"></span><h4>调试模式<a class="headerlink" href="#debug-mode" title="永久链接至标题">¶</a></h4>
<p>虽然 <a class="reference internal" href="index.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 方法适用于本地开发服务器的启动，但是
你每次修改代码后都要手动重启它。这样并不是很好，然而 Flask 可以做得更
好。如果你启用了调试 支持，服务器会在代码变更时自动重新载入，并且如果
发生错误，它会提供一个有用的调试器。</p>
<p>有两种途径来启用调试模式。一种是在应用对象上设置:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>另一种是作为 run 方法的一个参数传入:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>两种方法的效果完全相同。</p>
<div class="admonition- admonition">
<p class="first admonition-title">注意</p>
<p class="last">尽管交互式调试器不能在 forking 环境（即在生产服务器上使用几乎是不可
能的），它依然允许执行任意代码。这使它成为一个巨大的安全隐患，因此
它  <strong>绝对不能用于生产环境</strong> 。</p>
</div>
<p>运行中的调试器截图：</p>
<img alt="screenshot of debugger in action" class="screenshot align-center" src="_images/debugger.png" />
<p>想用另一个调试器？ 参见 <a class="reference internal" href="index.html#working-with-debuggers"><em>调试器操作</em></a> 。</p>
</div>
<div class="section" id="id4">
<h4>路由<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>现代 web 应用使用优雅的 URL，这易于人们记住 URL ，这点在面向使用慢网络连
接的移动设备的应用上特别有用。如果可以不访问索引页而直接访问想要的页面，他们多半会喜欢这个页面而再度光顾。</p>
<p>如上所见， <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器把一个函数绑定到对应的 URL 上。
这里是一些基本的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Index Page&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>但是，不仅如此！你可以构造特定部分动态的 URL，也可以在一个函数上附加多个规则。</p>
<div class="section" id="id5">
<h5>变量规则<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>要给 URL 添加变量部分，你可以把这些特殊的字段标记为 <tt class="docutils literal"><span class="pre">&lt;variable_name&gt;</span></tt> ，
这个部分将会作为命名参数传递到你的函数。规则可以用
<tt class="docutils literal"><span class="pre">&lt;converter:variable_name&gt;</span></tt> 指定一个可选的转换器。这里有一些不错的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user_profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="c"># show the user profile for that user</span>
    <span class="k">return</span> <span class="s">&#39;User </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">username</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="c"># show the post with the given id, the id is an integer</span>
    <span class="k">return</span> <span class="s">&#39;Post </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">post_id</span>
</pre></div>
</div>
<p>现有的转换器如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>int</cite></td>
<td>接受整数</td>
</tr>
<tr class="row-even"><td><cite>float</cite></td>
<td>同 <cite>int</cite> ，但是接受浮点数</td>
</tr>
<tr class="row-odd"><td><cite>path</cite></td>
<td>和默认的相似，但也接受斜线</td>
</tr>
</tbody>
</table>
<div class="admonition- admonition">
<p class="first admonition-title">唯一的网址 / 重定向行为</p>
<p>Flask 的 URL 规则基于 Werkzeug 的路由模块。这个模块背后的思想是基于 Apache
以及更早的 HTTP 服务器规定的先例，保证优雅且唯一的 URL。</p>
<p>以这两个规则为例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/projects/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">projects</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;The project page&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;The about page&#39;</span>
</pre></div>
</div>
<p>虽然它们看起来确实相似，但它们结尾斜线的使用在 URL <em>定义</em> 中不同。
第一种情况中，规范的 URL 指向 <cite>projects</cite> 尾端有一个斜线。这种感觉
很像在文件系统中的文件夹。访问一个结尾不带斜线的 URL 会被
Flask 重定向到带斜线的规范 URL 去。</p>
<p>然而，第二种情况的 URL 结尾不带斜线，类似 UNIX-like 系统下的文件的
路径名。访问结尾带斜线的 URL 会产生一个 404 &#8220;Not Found&#8221; 错误。</p>
<p class="last">当用户访问页面时忘记结尾斜线时，这个行为允许关联的 URL 继续工作，并
且与 Apache 和其它的服务器的行为一致。另外，URL 会保持唯一，有助于
避免搜索引擎索引同一个页面两次。</p>
</div>
</div>
<div class="section" id="url">
<span id="url-building"></span><h5>构建 URL<a class="headerlink" href="#url" title="永久链接至标题">¶</a></h5>
<p>如果它能匹配 URL ，那么 Flask 可以生成它们吗？当然可以。你可以使用
<a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> 来给一个特定函数构造 URL。它接受一个函数名作
为第一个参数和一些关键字参数，每个对应 URL 规则的变量部分。未知变量部
分会添加到 URL 末尾作为查询参数。这里是一些例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">url_for</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">index</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">login</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">():</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">)</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">&#39;login&#39;</span><span class="p">)</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">&#39;login&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">&#39;profile&#39;</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s">&#39;John Doe&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">/</span>
<span class="go">/login</span>
<span class="go">/login?next=/</span>
<span class="go">/user/John%20Doe</span>
</pre></div>
</div>
<p>（这里也用到了 <a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> 方法，下面会解
释。即使我们正在通过 Python 的 shell 进行交互，它依然会告诉 Flask 像对待请求一样处理。
请看下面的解释。 <a class="reference internal" href="index.html#context-locals"><em>局部上下文</em></a> ）</p>
<p>为什么你会想要构建 URL 而非在模板中硬编码？这里有三个好理由：</p>
<ol class="arabic simple">
<li>反向构建通常比硬编码更具备描述性。更重要的是，它允许你一次性修改 URL，
而不是到处找 URL 改。</li>
<li>URL 构建会显式地处理特殊字符和 Unicode 数据的转义，所以你不需要亲自处理。</li>
<li>如果你的应用不位于 URL 的根路径（比如，在 <tt class="docutils literal"><span class="pre">/myapplication</span></tt> 而不是 <tt class="docutils literal"><span class="pre">/</span></tt>
）， <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> 会为你妥善地处理这些。</li>
</ol>
</div>
<div class="section" id="http">
<h5>HTTP 方法<a class="headerlink" href="#http" title="永久链接至标题">¶</a></h5>
<p>HTTP （web 应用会话的协议）知道访问 URL 的不同方法。默认情况下，路由只回应
<cite>GET</cite> 请求，但是通过给 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器提供 <cite>methods</cite> 参数
可以更改这个行为。这里有一些例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">do_the_login</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">show_the_login_form</span><span class="p">()</span>
</pre></div>
</div>
<p>如果当前是 <cite>GET</cite> 请求， 它也会自动的为你添加`HEAD`，无需你操心。它会确保 <cite>HEAD</cite>
请求按照 <a class="reference external" href="http://www.ietf.org/rfc/rfc2068.txt">HTTP RFC</a> （描述 HTTP 协议的文档）来处理，所以你可以完全忽略这部
分的 HTTP 规范。同样，自从 Flask 0.6 起， <cite>OPTIONS</cite> 也实现了自动处理。</p>
<p>你不知道一个 HTTP 方法是什么？不必担心，这里快速介绍 HTTP 方法和它们为什么重要：</p>
<p>HTTP 方法（也经常被叫做“谓词”）告诉服务器客户端想对请求的页面 <em>做</em> 什么。
以下都是非常常见的方法：</p>
<dl class="docutils">
<dt><cite>GET</cite></dt>
<dd>浏览器告诉服务器，只 <em>获取</em> 页面上的信息并发给我。这是最常用的方法。</dd>
<dt><cite>HEAD</cite></dt>
<dd>浏览器告诉服务器获取信息，但是只对 <em>消息头</em> 感兴趣。应用期望像 <cite>GET</cite> 请求
一样处理它，但是不传递实际内容。在 Flask 中你完全不用处理它，底层的
Werkzeug 库已经替你处理好了。</dd>
<dt><cite>POST</cite></dt>
<dd>浏览器告诉服务器，它想在 URL 上 <em>发布</em> 新信息。并且，服务器必须确保数据已
存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。</dd>
<dt><cite>PUT</cite></dt>
<dd>类似 <cite>POST</cite> 但是服务器可能触发了存储过程多次，多次覆盖掉旧值。你可能会问这
有什么用，当然这是有原因的。考虑到传输中连接可能会丢失，在这种情况下浏览器
和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。使用 <cite>POST</cite>
不能实现，因为它只会被触发一次。</dd>
<dt><cite>DELETE</cite></dt>
<dd>删除给定位置的信息。</dd>
<dt><cite>OPTIONS</cite></dt>
<dd>给客户端提供一个快速的途径来弄清这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开
始，自动实现了它。</dd>
</dl>
<p>有趣的是，在 HTML4 和 XHTML1 中，表单只能以 <cite>GET</cite> 和 <cite>POST</cite> 方法提交到服务器。
但是用 JavaScript 和未来的 HTML 标准允许你使用其它所有的方法。此外，HTTP 最近变得
相当流行，浏览器不再是唯一的 HTTP 客户端。例如，许多版本控制系统也在用它。</p>
</div>
</div>
<div class="section" id="id6">
<h4>静态文件<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>动态 web 应用也会需要静态文件，通常是 CSS 和 JavaScript 文件的存放位置。理想情况下，
你已经配置 web 服务器来提供它们，但是在开发中， Flask 也可以做到。只要在你的包中
或模块旁边创建一个名为 <cite>static</cite> 的文件夹，在应用中使用 <cite>/static</cite> 即可访问。</p>
<p>给静态文件生成 URL ，使用特殊的 <tt class="docutils literal"><span class="pre">'static'</span></tt> 端点名:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;static&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;style.css&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这个文件应该存储在文件系统上的 <tt class="docutils literal"><span class="pre">static/style.css</span></tt> 。</p>
</div>
<div class="section" id="id7">
<h4>模板渲染<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>在 Python 里生成 HTML 十分无趣，而且相当繁琐，因为你需要自行对 HTML 做转
义来保证应用安全。由于这个原因， Flask 自动配置了
<a class="reference external" href="http://jinja.pocoo.org/2/">Jinja2</a> 模板引擎。</p>
<p>你可以使用 <a class="reference internal" href="index.html#flask.render_template" title="flask.render_template"><tt class="xref py py-func docutils literal"><span class="pre">render_template()</span></tt></a> 方法来渲染模板。你需要做的所有事就是将
模板名和你想作为关键字的参数传入模板的变量。这里有一个描述如何渲染模板的简例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">render_template</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/hello/&#39;</span><span class="p">)</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;hello.html&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Flask 会在 <cite>templates</cite> 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件
夹在模块的旁边；如果它是一个包，那么这个文件夹在你的包里面:</p>
<p><strong>情况 1</strong>: 模块:</p>
<div class="highlight-python"><pre>/application.py
/templates
    /hello.html</pre>
</div>
<p><strong>情况 2</strong>: 包:</p>
<div class="highlight-python"><pre>/application
    /__init__.py
    /templates
        /hello.html</pre>
</div>
<p>对于模板，你可以使用 Jinja2 模板的全部能力。更多信息请见官方的 <a class="reference external" href="http://jinja.pocoo.org/2/documentation/templates">Jinja2 模板文档</a> 。</p>
<p>这里是一个模板实例：</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;title&gt;</span>Hello from Flask<span class="nt">&lt;/title&gt;</span>
<span class="cp">{%</span> <span class="k">if</span> <span class="nv">name</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="nt">&lt;/h1&gt;</span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Hello World!<span class="nt">&lt;/h1&gt;</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>在模板里，你也可以访问 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 、 <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 和
<a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> <a class="footnote-reference" href="#id10" id="id9">[1]</a> 对象，以及 <a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a> 函数。</p>
<p>使用继承，模板会相当有用。如果你想知道继承如何工作，请跳转到
<a class="reference internal" href="index.html#template-inheritance"><em>模板继承</em></a> 模式文档。基本的模板继承使得特定元素（比如页眉、导航
栏和页脚）可以出现在所有的页面。</p>
<p>自动转义默认是开启的，所以如果 <cite>name</cite> 包含 HTML ，它将会被自动转义。如果你能信任一个
变量，并且你知道它是安全的（例如一个模块把 wiki 标记转换到 HTML ），你可以用
<tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt> 类或 <tt class="docutils literal"><span class="pre">|safe</span></tt> 过滤器在模板中标记它是安全的。在 Jinja 2
文档中，你会见到更多例子。</p>
<p>这里是一个 <tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt> 类如何工作的基本介绍:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Markup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&#39;&lt;strong&gt;Hello </span><span class="si">%s</span><span class="s">!&lt;/strong&gt;&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="s">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span>
<span class="go">Markup(u&#39;&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span><span class="p">)</span>
<span class="go">Markup(u&#39;&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&#39;&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Marked up \xbb HTML&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.5 版更改: </span>自动转义不再在所有模板中启用。下列扩展名的模板会触发自动转义： <tt class="docutils literal"><span class="pre">.html</span></tt> 、
<tt class="docutils literal"><span class="pre">.htm</span></tt> 、<tt class="docutils literal"><span class="pre">.xml</span></tt> 、 <tt class="docutils literal"><span class="pre">.xhtml</span></tt> 。从字符串加载的模板会禁用自动转义。</p>
</div>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[1]</a></td><td>不确定 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> 对象是什么？它是你可以按需存储信息的东西，
查看（ <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> ）对象的文档和 <a class="reference internal" href="index.html#sqlite3"><em>在 Flask 中使用 SQLite 3</em></a> 的文档以获取更多信息。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id11">
<h4>访问请求数据<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>对于 web 应用，对客户端发送给服务器的数据做出反应至关重要。在 Flask 中由全局
的 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 对象来提供这些信息。如果你有一定的 Python 经验，你
会好奇这个对象怎么可能是全局的，并且 Flask 是怎么还能保证线程安全。答案是上下
文作用域:</p>
<div class="section" id="context-locals">
<span id="id12"></span><h5>局部上下文<a class="headerlink" href="#context-locals" title="永久链接至标题">¶</a></h5>
<div class="admonition- admonition">
<p class="first admonition-title">内幕</p>
<p class="last">如果你想理解它是如何工作以及如何实现测试，请阅读此节，否则可跳过。</p>
</div>
<p>Flask 中的某些对象是全局对象，但不是通常的类型。这些对象实际上是给定上下文
的局部对象的代理。虽然很拗口，但实际上很容易理解。</p>
<p>想象一下处理线程的上下文。一个请求传入，web 服务器决定生成一个新线程（或者别
的什么东西，只要这个基础对象可以胜任并发系统，而不仅仅是线程）。当 Flask 开始它
内部请求处理时，它认定当前线程是活动的上下文并绑定当前的应用和 WSGI 环境到那
个上下文（线程）。它以一种智能的方法来实现，以保证一个应用调用另一个应用时
不会中断。</p>
<p>所以这对你来说意味着什么？除非你要做类似单元测试的东西，基本上可以完全忽略
这种情况。你会发现依赖于一个请求对象的代码会突然中断，因为不会有请求对象。解
决方案是自己创建一个请求对象并且把它绑定到上下文。单元测试的最早的解决方案是
使用 <a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> 上下文管理器。结合 <cite>with</cite> 声
明，它将绑定一个测试请求来进行交互。这里是一个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s">&#39;/hello&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;POST&#39;</span><span class="p">):</span>
    <span class="c"># now you can do something with the request until the</span>
    <span class="c"># end of the with block, such as basic assertions:</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="s">&#39;/hello&#39;</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span>
</pre></div>
</div>
<p>另一种可能是传递整个 WSGI 环境给 <a class="reference internal" href="index.html#flask.Flask.request_context" title="flask.Flask.request_context"><tt class="xref py py-meth docutils literal"><span class="pre">request_context()</span></tt></a> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h5>请求对象<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h5>
<p>请求对象在 API 章节有详细的描述（参见 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> ），这里不会赘
述。这里宽泛介绍一些最常用的操作。首先你需要从 <cite>flask</cite> 模块里导入它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>
</pre></div>
</div>
<p>当前的请求方式通过 <tt class="xref py py-attr docutils literal"><span class="pre">method</span></tt> 属性来访问。通过
<tt class="xref py py-attr docutils literal"><span class="pre">form</span></tt> 属性来访问表单数据（ <cite>POST</cite> 或 <cite>PUT</cite> 请求提交的数
据）。这里有一个上面提到的两个属性的完整实例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">,</span> <span class="s">&#39;GET&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s">&#39;Invalid username/password&#39;</span>
    <span class="c"># the code below is executed if the request method</span>
    <span class="c"># was GET or the credentials were invalid</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;login.html&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>当 <cite>form</cite> 属性中的键值不存在会发生什么？在这种情况，一个特殊的
<a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#KeyError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> 异常会抛出。你可以像捕获标准的 <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#KeyError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> 来捕获它。
如果你不这么做，它会显示一个 HTTP 400 Bad Request 错误页面。所以，很多情况下你并不需
要处理这个问题。</p>
<p>你可以通过 <tt class="xref py py-attr docutils literal"><span class="pre">args</span></tt> 属性来访问 URL 中提交的参数
（ <tt class="docutils literal"><span class="pre">?key=value</span></tt> ）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">searchword</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们推荐使用 <cite>get</cite> 来访问 URL 参数或捕获 <cite>KeyError</cite> ，因为用户可能会修改 URL ，
向他们展现一个 400 bad request 页面会影响用户体验。</p>
<p>想获取请求对象的完整方法和属性清单，请参阅 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 的文档。</p>
</div>
<div class="section" id="id14">
<h5>文件上传<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h5>
<p>你可以很容易的用 Flask 处理文件上传。只需要确保没忘记在你的 HTML 表单中设置
<tt class="docutils literal"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></tt> 属性，否则你的浏览器将根本不提交文件。</p>
<p>已上传的文件存储在内存或是文件系统上的临时位置。你可以通过请求对象的
<tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt> 属性访问那些文件。每个上传的文件都会存储在那个
字典里。它表现得如同一个标准的 Python <tt class="xref py py-class docutils literal"><span class="pre">file</span></tt> 对象，但它还有一个
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.save" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法来允许你在服务器的文件
系统上保存它。这里是一个它如何工作的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;/var/www/uploads/uploaded_file.txt&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你想知道上传前文件在客户端的文件名，你可以访问
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.filename" title="(在 Werkzeug v0.10)"><tt class="xref py py-attr docutils literal"><span class="pre">filename</span></tt></a> 属性。但请记住永远不
要信任这个值，因为这个值可以伪造。如果你想要使用客户端的文件名来在服务器上
存储文件，把它传递给 Werkzeug 提供的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">secure_filename()</span></tt></a> 函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">secure_filename</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;/var/www/uploads/&#39;</span> <span class="o">+</span> <span class="n">secure_filename</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>一些更好的例子，查看 <a class="reference internal" href="index.html#uploading-files"><em>上传文件</em></a> 模式。</p>
</div>
<div class="section" id="cookies">
<h5>Cookies<a class="headerlink" href="#cookies" title="永久链接至标题">¶</a></h5>
<p>你可以通过 <a class="reference internal" href="index.html#flask.Request.cookies" title="flask.Request.cookies"><tt class="xref py py-attr docutils literal"><span class="pre">cookies</span></tt></a> 属性来访问 cookies 。设置
cookies 通过响应对象的 <a class="reference internal" href="index.html#flask.Response.set_cookie" title="flask.Response.set_cookie"><tt class="xref py py-attr docutils literal"><span class="pre">set_cookie</span></tt></a> 方法。请求对象
的 <a class="reference internal" href="index.html#flask.Request.cookies" title="flask.Request.cookies"><tt class="xref py py-attr docutils literal"><span class="pre">cookies</span></tt></a> 属性是一个客户端提交的所有 cookies 的
字典。如果你想使用会话，请不要直接使用 cookies，请参考 <a class="reference internal" href="index.html#sessions"><em>会话</em></a>
一节。在 Flask 中，已经在 cookies 上增加了一些安全细节。</p>
<p>读取 cookies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;username&#39;</span><span class="p">)</span>
    <span class="c"># use cookies.get(key) instead of cookies[key] to not get a</span>
    <span class="c"># KeyError if the cookie is missing.</span>
</pre></div>
</div>
<p>存储 cookies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">make_response</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="s">&#39;the username&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
<p>注意 cookies 是设置在响应对象上。由于通常只是从视图函数返回字符串，
Flask 会将其转换为响应对象。如果你显式地想要这么做，你可以使用
<a class="reference internal" href="index.html#flask.make_response" title="flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">make_response()</span></tt></a> 函数然后修改它。</p>
<p>有时候你会想要在响应对象不存在的时候设置 cookie ，这在利用
<a class="reference internal" href="index.html#deferred-callbacks"><em>延迟请求回调</em></a> 模式时是可行的。</p>
<p>为此也可以参阅 <a class="reference internal" href="index.html#about-responses"><em>关于响应</em></a> 。</p>
</div>
</div>
<div class="section" id="id15">
<h4>重定向和错误<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<p>重定向用户到其它地方你可以使用 <a class="reference internal" href="index.html#flask.redirect" title="flask.redirect"><tt class="xref py py-func docutils literal"><span class="pre">redirect()</span></tt></a> 函数。放弃请求并
返回错误代码可以使用 <a class="reference internal" href="index.html#flask.abort" title="flask.abort"><tt class="xref py py-func docutils literal"><span class="pre">abort()</span></tt></a> 函数。这里是一个它们如何工作的
例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">abort</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;login&#39;</span><span class="p">))</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
    <span class="n">this_is_never_executed</span><span class="p">()</span>
</pre></div>
</div>
<p>这是一个相当无意义的例子因为用户会从主页重定向到一个不能访问的页面（401意
味着禁止访问），但是它说明了重定向如何工作。</p>
<p>默认情况下，每个错误代码会显示一个黑白错误页面。如果你想定制错误页面，可
以使用 <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> 装饰器:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">render_template</span>

<span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;page_not_found.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>注意 <a class="reference internal" href="index.html#flask.render_template" title="flask.render_template"><tt class="xref py py-func docutils literal"><span class="pre">render_template()</span></tt></a> 调用之后的 <tt class="docutils literal"><span class="pre">404</span></tt> 。这告诉 Flask 该
页的错误代码应是 404 ，即没有找到。默认的 200 被假定为：一切正常。</p>
</div>
<div class="section" id="about-responses">
<span id="id16"></span><h4>关于响应<a class="headerlink" href="#about-responses" title="永久链接至标题">¶</a></h4>
<p>视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串，
它被转换为响应主体为该字符串、状态码为 <tt class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></tt> 、 MIME 类型为
<tt class="docutils literal"><span class="pre">text/html</span></tt> 的响应对象。Flask 把返回值转换为响应对象的逻辑如下：</p>
<ol class="arabic simple">
<li>如果返回的是一个合法的响应对象，它会被从视图直接返回。</li>
<li>如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。</li>
<li>如果返回的是一个元组，且元组中的元素可以提供额外的信息。这样的元组
必须是 <tt class="docutils literal"><span class="pre">(response,</span> <span class="pre">status,</span> <span class="pre">headers)</span></tt> 这样的形式，且至少包含一个元素。
<cite>status</cite> 值会覆盖状态代码， <cite>headers</cite> 可以是一个列表或字典，作为额外的
消息头值。</li>
<li>如果上述条件均不满足， Flask 会假设返回值是一个合法的 WSGI 应用程序，
并转换为一个请求对象。</li>
</ol>
<p>如果你想在视图里掌控上述步骤结果的响应对象，你可以使用
<a class="reference internal" href="index.html#flask.make_response" title="flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a> 函数。</p>
<p>想象你有这样一个视图:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>你只需要用 <a class="reference internal" href="index.html#flask.make_response" title="flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a> 封装返回表达式，获取结果对象并修
改，然后返回它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span><span class="p">)</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;X-Something&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;A value&#39;</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
</div>
<div class="section" id="sessions">
<span id="id17"></span><h4>会话<a class="headerlink" href="#sessions" title="永久链接至标题">¶</a></h4>
<p>除请求对象之外，还有 <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 对象允许你在不同请求间存储特
定用户的信息。这是在 cookies 的基础上实现的，并且在 cookies 中使用加密的
签名。这意味着用户可以查看你 cookie 的内容，但是不能修改它，除非它知道签
名的密钥。</p>
<p>要使用会话，你需要设置一个密钥。这里介绍会话如何工作:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">request</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="s">&#39;username&#39;</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;Logged in as </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">escape</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="s">&#39;You are not logged in&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">session</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span>
<span class="s">            &lt;p&gt;&lt;input type=text name=username&gt;</span>
<span class="s">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span>
<span class="s">        &lt;/form&gt;</span>
<span class="s">    &#39;&#39;&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/logout&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="c"># remove the username from the session if it&#39;s there</span>
    <span class="n">session</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">))</span>

<span class="c"># set the secret key.  keep this really secret:</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="s">&#39;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&#39;</span>
</pre></div>
</div>
<p>这里提到的 <a class="reference internal" href="index.html#flask.escape" title="flask.escape"><tt class="xref py py-func docutils literal"><span class="pre">escape()</span></tt></a> 可以在你不使用模板引擎的时候做转义（如同
本例）。</p>
<div class="admonition- admonition">
<p class="first admonition-title">如何生成一个强壮的密钥</p>
<p>随机的问题在于很难判断什么是真随机。一个密钥应该足够随机。你的操作系统
可以基于一个密码随机生成器来生成漂亮的随机值，这个值可以用来做密钥:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="go">&#39;\xfd{H\xe5&lt;\x95\xf9\xe3\x96.5\xd1\x01O&lt;!\xd5\xa2\xa0\x9fR&quot;\xa1\xa8&#39;</span>
</pre></div>
</div>
<p class="last">把这个值复制粘贴到你的代码，你就搞定了密钥。</p>
</div>
<p>使用基于 cookie 的会话需注意: Flask 会将你放进会话对象的值序列化到 cookie。
如果你发现某些值在请求之间并没有持久化保存，而 cookies 确实已经启用了，你也没
有得到明确的错误信息，请检查你的页面响应中的 cookie 的大小，并与 web 浏览器所
支持的大小对比。</p>
</div>
<div class="section" id="id18">
<h4>消息闪现<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p>良好的应用和用户界面全部涉及反馈。如果用户得不到足够的反馈，他们很可能开始
厌恶这个应用。 Flask 提供一种消息闪现系统给用户反馈的简单方法。
消息闪现系统通常会在请求结束时记录信息，并在下一个（且仅在下一个）请求中
访问。通常结合模板布局来展现消息。</p>
<p>使用 <a class="reference internal" href="index.html#flask.flash" title="flask.flash"><tt class="xref py py-func docutils literal"><span class="pre">flash()</span></tt></a> 方法可以闪现一条消息。要掌控消息本身，使用
<a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a> 函数，并且在模板中也可以使用。完整的例
子请查阅 <a class="reference internal" href="index.html#message-flashing-pattern"><em>消息闪现</em></a> 部分。</p>
</div>
<div class="section" id="id19">
<h4>日志记录<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
<p>有时候你处于一种境地，你处理的数据本应该是正确的，但实际上不是。比如你有一些
客户端代码向服务器发送请求，但请求显然是畸形的。这可能是用户篡改了数据，或
是客户端代码的失败。大多数情况下，正常地返回 <tt class="docutils literal"><span class="pre">400</span> <span class="pre">Bad</span> <span class="pre">Request</span></tt> 就可以了，
但是有时不这么做，并且代码要继续运行。</p>
<p>你可能依然想要记录发生了什么不对劲。这时日志记录就派上了用场。Flask 0.3
开始已经预置了日志系统。</p>
<p>这里有一些日志调用的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;A warning occurred (</span><span class="si">%d</span><span class="s"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;An error occurred&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>附带的 <a class="reference internal" href="index.html#flask.Flask.logger" title="flask.Flask.logger"><tt class="xref py py-attr docutils literal"><span class="pre">logger</span></tt></a> 是一个标准日志类
<a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Logger" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">Logger</span></tt></a> ，所以更多信息请见 <a class="reference external" href="http://docs.python.org/library/logging.html">logging
文档</a> 。</p>
</div>
<div class="section" id="wsgi">
<h4>整合 WSGI 中间件<a class="headerlink" href="#wsgi" title="永久链接至标题">¶</a></h4>
<p>如果你想给你的应用添加 WSGI 中间件，你可以封装内部 WSGI 应用。例如如果你想
使用 Werkzeug 包中的某个中间件来应付 lighttpd 中的 bugs ，可以这样做:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.contrib.fixers</span> <span class="kn">import</span> <span class="n">LighttpdCGIRootFix</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">LighttpdCGIRootFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="web">
<span id="quickstart-deployment"></span><h4>部署到 Web 服务器<a class="headerlink" href="#web" title="永久链接至标题">¶</a></h4>
<p>准备好部署你的 Flask 应用了？你可以立即部署到托管平台来圆满完成快速入门，
以下均向小项目提供免费的方案:</p>
<ul class="simple">
<li><a class="reference external" href="http://devcenter.heroku.com/articles/python">在 Heroku 上部署 Flask</a></li>
<li><a class="reference external" href="http://docs.dotcloud.com/services/python/">在 dotCloud 上部署 Flask</a>
附 <a class="reference external" href="http://flask.pocoo.org/snippets/48/">Flask 的具体说明</a></li>
</ul>
<p>托管 Flask 应用的其它选择:</p>
<ul class="simple">
<li><a class="reference external" href="http://flask.pocoo.org/snippets/65/">在 Webfaction 上部署 Flask</a></li>
<li><a class="reference external" href="https://github.com/kamalgill/flask-appengine-template">在 Google App Engine 上部署 Flask</a></li>
<li><a class="reference external" href="http://flask.pocoo.org/snippets/89/">用 Localtunnel 共享你的本地服务器</a></li>
</ul>
<p>如果你管理自己的主机并且想要亲自运行，参见 <a class="reference internal" href="index.html#deployment"><em>部署选择</em></a> 章节。</p>
</div>
</div>
<span id="document-tutorial/index"></span><div class="section" id="tutorial">
<span id="id1"></span><h3>教程<a class="headerlink" href="#tutorial" title="永久链接至标题">¶</a></h3>
<p>你想要用 Python 和 Flask 开发一个应用？这里你将有机会通过实例来学习。
在本教程中，我们会创建一个简单的微博客应用。它只支持单用户和纯文本的
条目，并且没有推送或是评论，但是它仍然有你开始时需要的一切。我们使
用 Flask ，采用在 Python 方框中产生的 SQLite 数据库 ，所以你不会需
要其它的东西。</p>
<p>如果你想提前获得完整源码或是用于对照，请检查 <a class="reference external" href="http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/">示例源码</a></p>
<div class="toctree-wrapper compound">
<span id="document-tutorial/introduction"></span><div class="section" id="flaskr">
<span id="tutorial-introduction"></span><h4>介绍 Flaskr<a class="headerlink" href="#flaskr" title="永久链接至标题">¶</a></h4>
<p>这里，我们把我们的博客应用称为 flaskr ，也可以选一个不那么 web 2.0 的名字 ;) 。基本上，我们希望它能做如下的事情：</p>
<ol class="arabic simple">
<li>根据配置文件里的凭证允许用户登入登出。只支持一个用户。</li>
<li>当用户登入后，可以向页面添加条目。条目标题是纯文本，正文可以是一些 HTML 。因假定信任这里的用户，这部分 HTML 不做审查。</li>
<li>页面倒序显示所有条目（后来居上），并且用户登入后可以在此添加新条目。</li>
</ol>
<p>我们将会在应用中直接使用 SQLite3 ，因为它对这种规模的应用足够适用。对于更大型的应用，就有必要使用 <a class="reference external" href="http://www.sqlalchemy.org/">SQLAlchemy</a> 更加智能地处理数据库连接、允许你一次连接不同的关系数据库等等。你也可以考虑流行的 NoSQL 数据库，如果你的数据更适合它们。</p>
<p>这里是一个应用最终效果的截图:</p>
<img alt="screenshot of the final application" class="screenshot align-center" src="_images/flaskr.png" />
<p>继续 <a class="reference internal" href="index.html#tutorial-folders"><em>步骤 0: 创建文件夹</em></a> 。</p>
</div>
<span id="document-tutorial/folders"></span><div class="section" id="tutorial-folders">
<span id="id1"></span><h4>步骤 0: 创建文件夹<a class="headerlink" href="#tutorial-folders" title="永久链接至标题">¶</a></h4>
<p>在我们开始之前，让我们创建这个应用需要的文件夹:</p>
<div class="highlight-python"><pre>/flaskr
    /static
    /templates</pre>
</div>
<p><cite>flaskr</cite> 文件夹不是一个 python 包，只是我们放置文件的地方。在接下来的步骤中，我们会直接把数据库模式和主模块放在这个目录中。 可以应用用户通过 <cite>HTTP</cite> 访问`static` 文件夹中的文件，这也是 css 和 javascript 文件存放的地方。在 <cite>templates</cite> 文件夹里， Flask 会寻找 <a class="reference external" href="http://jinja.pocoo.org/2/">Jinja2</a> 模板，你之后教程中创建的模板会放在这一文件夹里。</p>
<p>继续 <a class="reference internal" href="index.html#tutorial-schema"><em>步骤 1: 数据库模式</em></a>.</p>
</div>
<span id="document-tutorial/schema"></span><div class="section" id="tutorial-schema">
<span id="id1"></span><h4>步骤 1: 数据库模式<a class="headerlink" href="#tutorial-schema" title="永久链接至标题">¶</a></h4>
<p>首先我们要创建数据库模式。对于这个应用只有一张表就足够了，并且我们只需要支持 SQLite ，所以很简单。只需要把下面的内容放进一个名为 <cite>schema.sql</cite> 的文件，放在刚才创建的 <cite>flaskr</cite> 文件夹中:</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">drop</span> <span class="k">table</span> <span class="n">if</span> <span class="k">exists</span> <span class="n">entries</span><span class="p">;</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">entries</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">integer</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">autoincrement</span><span class="p">,</span>
  <span class="n">title</span> <span class="n">string</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="nb">text</span> <span class="n">string</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>
</pre></div>
</div>
<p>这个模式由一个名为 <cite>entries</cite> 的表组成，表中每列包含一个 <cite>id</cite> 、 一个 <cite>title</cite> 和 一个 <cite>text</cite> 。 <cite>id</cite> 是一个自增的整数，也是主键；其余的两个是字符串，且为非空。</p>
<p>继续 <a class="reference internal" href="index.html#tutorial-setup"><em>步骤 2: 应用设置代码</em></a>.</p>
</div>
<span id="document-tutorial/setup"></span><div class="section" id="tutorial-setup">
<span id="id1"></span><h4>步骤 2: 应用设置代码<a class="headerlink" href="#tutorial-setup" title="永久链接至标题">¶</a></h4>
<p>现在我们已经有了数据库模式，我们可以创建应用的模块了。让我们叫它 <cite>flaskr.py</cite> ，
并放置在 <cite>flaskr</cite> 目录下。为面向初学者，我们会添加所有需要的导入像配置的章节中
一样。对于小应用，直接把配置放在主模块里，正如我们现在要做的一样，是可行的。但
是，一个更简洁的方案是创建独立的 <cite>.ini</cite> 或 <cite>.py</cite> 文件，并载入或导入里面的值。</p>
<p><cite>flaskr.py</cite> 中</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># all the imports</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> \
     <span class="n">abort</span><span class="p">,</span> <span class="n">render_template</span><span class="p">,</span> <span class="n">flash</span>

<span class="c"># configuration</span>
<span class="n">DATABASE</span> <span class="o">=</span> <span class="s">&#39;/tmp/flaskr.db&#39;</span>
<span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="s">&#39;development key&#39;</span>
<span class="n">USERNAME</span> <span class="o">=</span> <span class="s">&#39;admin&#39;</span>
<span class="n">PASSWORD</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
</pre></div>
</div>
<p>接下来我们要创建真正的应用，并且在同一个文件 <cite>flaskr.py</cite> 中配置并初始化:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># create our little application :)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="index.html#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a> 会遍历给定的对象（如果它是一个字符串，则
会导入它），搜寻里面定义的全部大写的变量。这种情况，配置文件就是我们上面写
的几行代码。你也可以将他们分开存储到多个文件。</p>
<p>从一个配置文件导入配置通常是个好主意。 <a class="reference internal" href="index.html#flask.Config.from_envvar" title="flask.Config.from_envvar"><tt class="xref py py-meth docutils literal"><span class="pre">from_envvar()</span></tt></a>
也能做到，用它替换上面的 <a class="reference internal" href="index.html#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a> 一行:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_envvar</span><span class="p">(</span><span class="s">&#39;FLASKR_SETTINGS&#39;</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方法我们可以设置一个名为 <span class="target" id="index-0"></span><tt class="xref std std-envvar docutils literal"><span class="pre">FLASKR_SETTINGS</span></tt> 环境变量来设定一个配置
文件载入后是否覆盖默认值。静默开关告诉 Flask 不去关心这个环境变量键值是否存在。</p>
<p>我们需要 <cite>secret_key</cite> 来保证客户端会话的安全。一个尽可能难猜测，尽可能复杂的密
钥是正确的选择。调试标志关系交互式调试器的开启。 <em>永远不要在生产系统中激活调试
模式</em> ，因为它将允许用户在服务器上执行代码。</p>
<p>我们还添加了一个快速连接到指定数据库的方法，这个方法用于在请求时打开一个连接，
并且在交互式 Python shell 和脚本中也能使用。这对以后很方便。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">connect_db</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;DATABASE&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>最后，如果我们想要把那个文件当做独立应用来运行，我们只需在服务器启动文件的末
尾添加这一行:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>如此我们便可以顺利开始运行这个应用，使用如下命令:</p>
<div class="highlight-python"><pre>python flaskr.py</pre>
</div>
<p>你将会看见有消息提示你可以访问服务器的地址。
You will see a message telling you that server has started along with
the address at which you can access it.</p>
<p>当你在浏览器中访问服务器获得一个 404 page not found 错误时，是因为我们还没有
任何视图。我们之后再来关注这些。首先我们应该让数据库工作起来。</p>
<div class="admonition- admonition">
<p class="first admonition-title">外部可见的服务器</p>
<p class="last">想要你的服务器公开可见？ <a class="reference internal" href="index.html#public-server"><em>外部可见的服务器</em></a>
一节有更多信息。</p>
</div>
<p>继续 <a class="reference internal" href="index.html#tutorial-dbinit"><em>步骤 3: 创建数据库</em></a> 。</p>
</div>
<span id="document-tutorial/dbinit"></span><div class="section" id="tutorial-dbinit">
<span id="id1"></span><h4>步骤 3: 创建数据库<a class="headerlink" href="#tutorial-dbinit" title="永久链接至标题">¶</a></h4>
<p>Flaskr 是一个数据库驱动的应用，如同之前所概括的，更准确的说法是，一个由
关系数据库系统驱动的应用。关系数据库系统需要一个模式来决定存储信息的方式。
所以在第一次开启服务器之前，要点是创建模式。</p>
<p>可以通过管道把 <cite>schema.sql</cite> 作为 <cite>sqlite3</cite> 命令的输入来创建这个模式，命
令如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sqlite3</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">flaskr</span><span class="o">.</span><span class="n">db</span> <span class="o">&lt;</span> <span class="n">schema</span><span class="o">.</span><span class="n">sql</span>
</pre></div>
</div>
<p>这种方法的缺点是需要安装 sqlite3 命令，而并不是每个系统都有安装。而且你必
须提供数据库的路径，否则将报错。添加一个函数来对初始化数据库是个不错的想法。</p>
<p>如果你想这么做，你首先要从 contextlib 包中导入 <a class="reference external" href="http://docs.python.org/dev/library/contextlib.html#contextlib.closing" title="(在 Python v3.5)"><tt class="xref py py-func docutils literal"><span class="pre">contextlib.closing()</span></tt></a>
函数。如果你想使用 Python 2.5 ，那么必须先启用 <cite>with</cite> 声明（ <cite>__future__</cite>
导入必须先于其它的导入）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>
</pre></div>
</div>
<p>接下来，我们可以创建一个名为 <cite>init_db</cite> 的函数来初始化数据库。为此，我们可以
使用之前定义的 <cite>connect_db</cite> 函数。只需要在 <cite>connect_db</cite> 函数后面添加这个函
数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">init_db</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">connect_db</span><span class="p">())</span> <span class="k">as</span> <span class="n">db</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;schema.sql&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference external" href="http://docs.python.org/dev/library/contextlib.html#contextlib.closing" title="(在 Python v3.5)"><tt class="xref py py-func docutils literal"><span class="pre">closing()</span></tt></a> 助手函数允许我们在 <cite>with</cite> 块中保持数据库连接可
用。应用对象的 <a class="reference internal" href="index.html#flask.Flask.open_resource" title="flask.Flask.open_resource"><tt class="xref py py-func docutils literal"><span class="pre">open_resource()</span></tt></a> 方法在其方框外也支持这个
功能，因此可以在 <cite>with</cite> 块中直接使用。这个函数从资源位置（你的 <cite>flaskr</cite> 文
件夹）中打开一个文件，并且允许你读取它。我们在这里用它在数据库连接上执行一
个脚本。</p>
<p>当我们连接到数据库时会得到一个数据库连接对象（这里命名它为 <cite>db</cite> ），这个对
象提供给我们一个数据库指针。指针上有一个可以执行完整脚本的方法。最后我们不
显式地提交更改， SQLite 3 或者其它事务数据库不会这么做。</p>
<p>现在可以在 Python shell 里创建数据库，导入并调用刚才的函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flaskr</span> <span class="kn">import</span> <span class="n">init_db</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">init_db</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">故障排除</p>
<p class="last">如果你获得了一个表无法找到的异常，请检查你确实调用了 <cite>init_db</cite> 函数并且
表的名称是正确的（如单数复数混淆）。</p>
</div>
<p>继续 <a class="reference internal" href="index.html#tutorial-dbcon"><em>步骤 4: 请求数据库连接</em></a></p>
</div>
<span id="document-tutorial/dbcon"></span><div class="section" id="tutorial-dbcon">
<span id="id1"></span><h4>步骤 4: 请求数据库连接<a class="headerlink" href="#tutorial-dbcon" title="永久链接至标题">¶</a></h4>
<p>现在我们知道如何在建立数据库连接并且如何执行脚本，但是我们如何能优雅的在请求
中这么做？所有的函数都需要数据库连接，所以在请求之前初始化，在请求结束后自动
关闭就很有意义。</p>
<p>Flask 允许我们用 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 、
<a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> 和 <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a>
装饰器来实现这个功能:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.before_request</span>
<span class="k">def</span> <span class="nf">before_request</span><span class="p">():</span>
    <span class="n">g</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">connect_db</span><span class="p">()</span>

<span class="nd">@app.teardown_request</span>
<span class="k">def</span> <span class="nf">teardown_request</span><span class="p">(</span><span class="n">exception</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>用 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 装饰的函数会在请求前调用，它没有参
数。用 <a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> 装饰的函数在请求结束后调用，需要
传入响应。它们必须返回那个响应对象或是不同的响应对象。但当异常抛出时，它们
不一定会被执行，这时可以使用 <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> 装饰器，
它装饰的函数将在响应构造后执行，并不允许修改请求，返回的值会被忽略。如果在
请求已经被处理的时候抛出异常，它会被传递到每个函数，否则会传入一个 <cite>None</cite> 。</p>
<p>我们把当前的数据库连接保存在 Flask 提供的 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 特殊对象中。这个
对象只能保存一次请求的信息，并且在每个函数里都可用。不要用其它对象来保存信
息，因为在多线程环境下将不可行。特殊的对象 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 在后台有一些神
奇的机制来保证它在做正确的事情。</p>
<p>继续 <a class="reference internal" href="index.html#tutorial-views"><em>步骤 5: 视图函数</em></a> 。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>我该把代码放在哪？</p>
<p>如果你一直遵循教程，你应该会问从这步到以后的步骤，代码放在什么地方。逻辑上
应该按照模块来组织函数，即把你新的 <tt class="docutils literal"><span class="pre">before_request</span></tt> 和 <tt class="docutils literal"><span class="pre">teardown_request</span></tt>
装饰的函数放在之前的 <tt class="docutils literal"><span class="pre">init_db</span></tt> 函数下面（逐行遵照教程）。</p>
<p class="last">如果你需要一个时刻来找到你的方位，看一下 <a class="reference external" href="http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/">示例源码</a> 是怎么组织的。在
Flask 中，你可以把你应用所有的代码放在一个 Python 模块里。但你无需这么做，
并且在你的应用 <a class="reference internal" href="index.html#larger-applications"><em>规模扩大</em></a> 的时候，这显然不妥。</p>
</div>
</div>
<span id="document-tutorial/views"></span><div class="section" id="tutorial-views">
<span id="id1"></span><h4>步骤 5: 视图函数<a class="headerlink" href="#tutorial-views" title="永久链接至标题">¶</a></h4>
<p>现在数据库连接已经正常工作，我们终于可以开始写视图函数了。我们一共需要写
四个:</p>
<div class="section" id="id2">
<h5>显示条目<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>这个视图显示数据库中存储的所有条目。它绑定在应用的根地址，并从数据库查询出
文章的标题和正文。id 值最大的条目（最新的条目）会显示在最上方。从指针返回的
行是按 select 语句中声明的列组织的元组。这对像我们这样的小应用已经足够了，
但是你可能会想把它转换成字典。如果你对这方面有兴趣，请参考 <a class="reference internal" href="index.html#easy-querying"><em>简化查询</em></a>
的例子。</p>
<p>视图函数会将条目作为字典传递给 <cite>show_entries.html</cite> 模板，并返回渲染结果:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_entries</span><span class="p">():</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&#39;select title, text from entries order by id desc&#39;</span><span class="p">)</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">text</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;show_entries.html&#39;</span><span class="p">,</span> <span class="n">entries</span><span class="o">=</span><span class="n">entries</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>添加条目<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>这个视图允许已登入的用户添加新条目，并只响应 <cite>POST</cite> 请求，实际的表单显示在
<cite>show_entries</cite> 页。如果一切工作正常，我们会用 <a class="reference internal" href="index.html#flask.flash" title="flask.flash"><tt class="xref py py-func docutils literal"><span class="pre">flash()</span></tt></a>  向下
一次请求发送提示消息，并重定向回 <cite>show_entries</cite> 页:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/add&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">add_entry</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;logged_in&#39;</span><span class="p">):</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&#39;insert into entries (title, text) values (?, ?)&#39;</span><span class="p">,</span>
                 <span class="p">[</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;title&#39;</span><span class="p">],</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;text&#39;</span><span class="p">]])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="n">flash</span><span class="p">(</span><span class="s">&#39;New entry was successfully posted&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;show_entries&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>注意这里的用户登入检查（ <cite>logged_in</cite> 键在会话中存在，并且为 <cite>True</cite> ）</p>
<div class="admonition- admonition">
<p class="first admonition-title">安全提示</p>
<p class="last">确保像上面例子中一样，使用问号标记来构建 SQL 语句。否则，当你使用格式化
字符串构建 SQL 语句时，你的应用容易遭受 SQL 注入。
更多请见 <a class="reference internal" href="index.html#sqlite3"><em>在 Flask 中使用 SQLite 3</em></a> 。</p>
</div>
</div>
<div class="section" id="id4">
<h5>登入和登出<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>这些函数用来让用户登入登出。登入通过与配置文件中的数据比较检查用户名和密码，
并设定会话中的 <cite>logged_in</cite> 键值。如果用户成功登入，那么这个键值会被设为
<cite>True</cite> ，并跳转回 <cite>show_entries</cite> 页。此外，会有消息闪现来提示用户登入成功。
如果发生一个错误，模板会通知，并提示重新登录。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;USERNAME&#39;</span><span class="p">]:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s">&#39;Invalid username&#39;</span>
        <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;PASSWORD&#39;</span><span class="p">]:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s">&#39;Invalid password&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">session</span><span class="p">[</span><span class="s">&#39;logged_in&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">flash</span><span class="p">(</span><span class="s">&#39;You were logged in&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;show_entries&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;login.html&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>登出函数，做相反的事情，从会话中删除 <cite>logged_in</cite> 键。我们这里使用了一个
简洁的方法：如果你使用字典的 <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict.pop" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt></a> 方法并传入第二个参数（默认），
这个方法会从字典中删除这个键，如果这个键不存在则什么都不做。这很有用，因为
我们不需要检查用户是否已经登入。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/logout&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="n">session</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;logged_in&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">flash</span><span class="p">(</span><span class="s">&#39;You were logged out&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;show_entries&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>继续 <a class="reference internal" href="index.html#tutorial-templates"><em>步骤 6: 模板</em></a> 。</p>
</div>
</div>
<span id="document-tutorial/templates"></span><div class="section" id="tutorial-templates">
<span id="id1"></span><h4>步骤 6: 模板<a class="headerlink" href="#tutorial-templates" title="永久链接至标题">¶</a></h4>
<p>接下来我们应该创建模板了。如果我们现在请求 URL，只会得到 Flask 无法找到模板的异常。
模板使用 <a class="reference external" href="http://jinja.pocoo.org/2/documentation/templates">Jinja2</a> 语法并默认开启自动转义。这意味着除非你使用
<a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> 标记或在模板中使用 <tt class="docutils literal"><span class="pre">|safe</span></tt> 过滤器，否则 Jinja 2 会
确保特殊字符，比如 <tt class="docutils literal"><span class="pre">&lt;</span></tt> 或 <tt class="docutils literal"><span class="pre">&gt;</span></tt> 被转义为等价的 XML 实体。</p>
<p>我们也会使用模板继承在网站的所有页面中重用布局。</p>
<p>将下面的模板放在 <cite>templates</cite> 文件夹里:</p>
<div class="section" id="layout-html">
<h5>layout.html<a class="headerlink" href="#layout-html" title="永久链接至标题">¶</a></h5>
<p>这个模板包含 HTML 主体结构、标题和一个登入链接（用户已登入则提供登出）。
如果有，它也会显示闪现消息。 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">body</span> <span class="pre">%}</span></tt> 块可以被子模板中相同名
字的块（ <tt class="docutils literal"><span class="pre">body</span></tt> ）替换。</p>
<p><a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 字典在模板中也是可用的。你可以用它来检查用户是否已登入。
注意，在 Jinja 中你可以访问不存在的对象/字典属性或成员。比如下面的代码，
即便 <tt class="docutils literal"><span class="pre">'logged_in'</span></tt> 键不存在，仍然可以正常工作:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;title&gt;</span>Flaskr<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">stylesheet</span> <span class="na">type=</span><span class="s">text/css</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;static&#39;</span><span class="o">,</span> <span class="nv">filename</span><span class="o">=</span><span class="s1">&#39;style.css&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">page</span><span class="nt">&gt;</span>
  <span class="nt">&lt;h1&gt;</span>Flaskr<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">metanav</span><span class="nt">&gt;</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="k">not</span> <span class="nv">session.logged_in</span> <span class="cp">%}</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;login&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>log in<span class="nt">&lt;/a&gt;</span>
  <span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;logout&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>log out<span class="nt">&lt;/a&gt;</span>
  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
  <span class="nt">&lt;/div&gt;</span>
  <span class="cp">{%</span> <span class="k">for</span> <span class="nv">message</span> <span class="k">in</span> <span class="nv">get_flashed_messages</span><span class="o">()</span> <span class="cp">%}</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">flash</span><span class="nt">&gt;</span><span class="cp">{{</span> <span class="nv">message</span> <span class="cp">}}</span><span class="nt">&lt;/div&gt;</span>
  <span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
  <span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="show-entries-html">
<h5>show_entries.html<a class="headerlink" href="#show-entries-html" title="永久链接至标题">¶</a></h5>
<p>这个模板继承了上面的 <cite>layout.html</cite> 模板来显示消息。注意 <cite>for</cite> 循环会遍历并输出
所有 <a class="reference internal" href="index.html#flask.render_template" title="flask.render_template"><tt class="xref py py-func docutils literal"><span class="pre">render_template()</span></tt></a> 函数传入的消息。我们还告诉表单使用 <cite>HTTP</cite>
的 <cite>POST</cite> 方法提交信息到 <cite>add_entry</cite> 函数:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;layout.html&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">session.logged_in</span> <span class="cp">%}</span>
    <span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;add_entry&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span> <span class="na">method=</span><span class="s">post</span> <span class="na">class=</span><span class="s">add-entry</span><span class="nt">&gt;</span>
      <span class="nt">&lt;dl&gt;</span>
        <span class="nt">&lt;dt&gt;</span>Title:
        <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">text</span> <span class="na">size=</span><span class="s">30</span> <span class="na">name=</span><span class="s">title</span><span class="nt">&gt;</span>
        <span class="nt">&lt;dt&gt;</span>Text:
        <span class="nt">&lt;dd&gt;&lt;textarea</span> <span class="na">name=</span><span class="s">text</span> <span class="na">rows=</span><span class="s">5</span> <span class="na">cols=</span><span class="s">40</span><span class="nt">&gt;&lt;/textarea&gt;</span>
        <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">submit</span> <span class="na">value=</span><span class="s">Share</span><span class="nt">&gt;</span>
      <span class="nt">&lt;/dl&gt;</span>
    <span class="nt">&lt;/form&gt;</span>
  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
  <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">entries</span><span class="nt">&gt;</span>
  <span class="cp">{%</span> <span class="k">for</span> <span class="nv">entry</span> <span class="k">in</span> <span class="nv">entries</span> <span class="cp">%}</span>
    <span class="nt">&lt;li&gt;&lt;h2&gt;</span><span class="cp">{{</span> <span class="nv">entry.title</span> <span class="cp">}}</span><span class="nt">&lt;/h2&gt;</span><span class="cp">{{</span> <span class="nv">entry.text</span><span class="o">|</span><span class="nf">safe</span> <span class="cp">}}</span>
  <span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
    <span class="nt">&lt;li&gt;&lt;em&gt;</span>Unbelievable.  No entries here so far<span class="nt">&lt;/em&gt;</span>
  <span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
  <span class="nt">&lt;/ul&gt;</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
</div>
<div class="section" id="login-html">
<h5>login.html<a class="headerlink" href="#login-html" title="永久链接至标题">¶</a></h5>
<p>最后是登入模板，只是简单地显示一个允许用户登入的表单:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;layout.html&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}</span>
  <span class="nt">&lt;h2&gt;</span>Login<span class="nt">&lt;/h2&gt;</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">error</span> <span class="cp">%}</span><span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">error</span><span class="nt">&gt;&lt;strong&gt;</span>Error:<span class="nt">&lt;/strong&gt;</span> <span class="cp">{{</span> <span class="nv">error</span> <span class="cp">}}{%</span> <span class="k">endif</span> <span class="cp">%}</span>
  <span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;login&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span> <span class="na">method=</span><span class="s">post</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dl&gt;</span>
      <span class="nt">&lt;dt&gt;</span>Username:
      <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">text</span> <span class="na">name=</span><span class="s">username</span><span class="nt">&gt;</span>
      <span class="nt">&lt;dt&gt;</span>Password:
      <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">password</span> <span class="na">name=</span><span class="s">password</span><span class="nt">&gt;</span>
      <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">submit</span> <span class="na">value=</span><span class="s">Login</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/dl&gt;</span>
  <span class="nt">&lt;/form&gt;</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>继续 <a class="reference internal" href="index.html#tutorial-css"><em>步骤 7: 添加样式</em></a> 。</p>
</div>
</div>
<span id="document-tutorial/css"></span><div class="section" id="tutorial-css">
<span id="id1"></span><h4>步骤 7: 添加样式<a class="headerlink" href="#tutorial-css" title="永久链接至标题">¶</a></h4>
<p>现在其它的一切都可以正常工作，是时候给应用添加样式了。只需在之前创建的
<cite>static</cite> 文件夹中创建一个名为 <cite>style.css</cite> 的样式表:</p>
<div class="highlight-css"><div class="highlight"><pre><span class="nt">body</span>            <span class="p">{</span> <span class="k">font-family</span><span class="o">:</span> <span class="k">sans-serif</span><span class="p">;</span> <span class="k">background</span><span class="o">:</span> <span class="m">#eee</span><span class="p">;</span> <span class="p">}</span>
<span class="nt">a</span><span class="o">,</span> <span class="nt">h1</span><span class="o">,</span> <span class="nt">h2</span>       <span class="p">{</span> <span class="k">color</span><span class="o">:</span> <span class="m">#377BA8</span><span class="p">;</span> <span class="p">}</span>
<span class="nt">h1</span><span class="o">,</span> <span class="nt">h2</span>          <span class="p">{</span> <span class="k">font-family</span><span class="o">:</span> <span class="s1">&#39;Georgia&#39;</span><span class="o">,</span> <span class="k">serif</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
<span class="nt">h1</span>              <span class="p">{</span> <span class="k">border-bottom</span><span class="o">:</span> <span class="m">2px</span> <span class="k">solid</span> <span class="m">#eee</span><span class="p">;</span> <span class="p">}</span>
<span class="nt">h2</span>              <span class="p">{</span> <span class="k">font-size</span><span class="o">:</span> <span class="m">1.2em</span><span class="p">;</span> <span class="p">}</span>

<span class="nc">.page</span>           <span class="p">{</span> <span class="k">margin</span><span class="o">:</span> <span class="m">2em</span> <span class="k">auto</span><span class="p">;</span> <span class="k">width</span><span class="o">:</span> <span class="m">35em</span><span class="p">;</span> <span class="k">border</span><span class="o">:</span> <span class="m">5px</span> <span class="k">solid</span> <span class="m">#ccc</span><span class="p">;</span>
                  <span class="k">padding</span><span class="o">:</span> <span class="m">0.8em</span><span class="p">;</span> <span class="k">background</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.entries</span>        <span class="p">{</span> <span class="k">list-style</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.entries</span> <span class="nt">li</span>     <span class="p">{</span> <span class="k">margin</span><span class="o">:</span> <span class="m">0.8em</span> <span class="m">1.2em</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.entries</span> <span class="nt">li</span> <span class="nt">h2</span>  <span class="p">{</span> <span class="k">margin-left</span><span class="o">:</span> <span class="m">-1em</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.add-entry</span>      <span class="p">{</span> <span class="k">font-size</span><span class="o">:</span> <span class="m">0.9em</span><span class="p">;</span> <span class="k">border-bottom</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#ccc</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.add-entry</span> <span class="nt">dl</span>   <span class="p">{</span> <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.metanav</span>        <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span> <span class="m">0.8em</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span> <span class="m">0.3em</span><span class="p">;</span>
                  <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">1em</span><span class="p">;</span> <span class="k">background</span><span class="o">:</span> <span class="m">#fafafa</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.flash</span>          <span class="p">{</span> <span class="k">background</span><span class="o">:</span> <span class="m">#CEE5F5</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span> <span class="m">0.5em</span><span class="p">;</span>
                  <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#AACBE2</span><span class="p">;</span> <span class="p">}</span>
<span class="nc">.error</span>          <span class="p">{</span> <span class="k">background</span><span class="o">:</span> <span class="m">#F0D6D6</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span> <span class="m">0.5em</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>继续 <a class="reference internal" href="index.html#tutorial-testing"><em>福利: 应用测试</em></a> 。</p>
</div>
<span id="document-tutorial/testing"></span><div class="section" id="tutorial-testing">
<span id="id1"></span><h4>福利: 应用测试<a class="headerlink" href="#tutorial-testing" title="永久链接至标题">¶</a></h4>
<p>现在你应该完成你的应用，并且一切都按预期运转正常，对于简化未来的修改，添加
自动测试不是一个坏主意。上面的应用将作为文档中 <a class="reference internal" href="index.html#testing"><em>测试 Flask 应用</em></a> 节的例子来演示
如何进行单元测试。去看看测试 Flask 应用是多么简单的一件事。</p>
</div>
</div>
</div>
<span id="document-templating"></span><div class="section" id="id1">
<h3>模板<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>Flask 使用 Jinja 2 作为模板引擎。当然，你也可以自由使用其它的模板引擎，但运行
Flask 本身仍然需要 Jinja2 依赖 ，这对启用富扩展是必要的，扩展可
以依赖 Jinja2 存在。</p>
<p>本节只是快速地介绍 Jinja2 是如何集成到 Flask 中的。更多关于 Jinja2 语法本身的信息，
请参考官方文档
<a class="reference external" href="http://jinja.pocoo.org/2/documentation/templates">Jinja2 模板引擎</a> 。</p>
<div class="section" id="jinja">
<h4>Jinja 配置<a class="headerlink" href="#jinja" title="永久链接至标题">¶</a></h4>
<p>Jinja 2 默认配置如下:</p>
<ul class="simple">
<li>所有扩展名为 <tt class="docutils literal"><span class="pre">.html</span></tt> 、 <tt class="docutils literal"><span class="pre">.htm</span></tt> 、 <tt class="docutils literal"><span class="pre">.xml</span></tt> 以及 <tt class="docutils literal"><span class="pre">.xhtml</span></tt>
的模板会开启自动转义</li>
<li>模板可以利用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">autoescape</span> <span class="pre">%}</span></tt> 标签选择自动转义的开关。</li>
<li>Flask 在 Jinja2 上下文中插入了几个全局函数和助手，另外还有一些
目前默认的值</li>
</ul>
</div>
<div class="section" id="id2">
<h4>标准上下文<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>下面的全局变量默认在 Jinja2 模板中可用:</p>
<dl class="data">
<dt>
<tt class="descname">config</tt></dt>
<dd><p>当前的配置对象 (<tt class="xref py py-data docutils literal"><span class="pre">flask.config</span></tt>)</p>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.10 版更改: </span>现在这总是可用的，甚至在导入的模版里。</p>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descname">request</tt></dt>
<dd><p>当前的请求对象 (<a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">flask.request</span></tt></a>)。当模版不是在活动的请求上下
文中渲染时这个变量不可用。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descname">session</tt></dt>
<dd><p>当前的会话对象 (<a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">flask.session</span></tt></a>)。当模版不是在活动的请求上下
文中渲染时这个变量不可用。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descname">g</tt></dt>
<dd><p>请求相关的全局变量 (<a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">flask.g</span></tt></a>)。当模版不是在活动的请求上下
文中渲染时这个变量不可用。</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">url_for</tt><big>(</big><big>)</big></dt>
<dd><p><a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">flask.url_for()</span></tt></a> 函数</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_flashed_messages</tt><big>(</big><big>)</big></dt>
<dd><p><a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">flask.get_flashed_messages()</span></tt></a> 函数</p>
</dd></dl>

<div class="admonition-jinja admonition">
<p class="first admonition-title">Jinja 上下文行为</p>
<p>这些变量被添加到了请求的上下文中，而非全局变量。区别在于，他们默认不会
在导入模板的上下文中出现。这样做，一方面是考虑到性能，另一方面是为了
让事情显式透明。</p>
<p>这对你来说意味着什么？如果你想要导入一个需要访问请求对象的宏，有两种可能的方法:</p>
<ol class="arabic simple">
<li>显式地传入请求或请求对象的属性作为宏的参数。</li>
<li>与上下文一起（with context）导入宏。</li>
</ol>
<p>与上下文中一起（with context）导入的方式如下:</p>
<div class="last highlight-jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">from</span> <span class="s1">&#39;_helpers.html&#39;</span> <span class="k">import</span> <span class="nv">my_macro</span> <span class="k">with context</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id3">
<h4>标准过滤器<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这些过滤器在 Jinja2 中可用，也是 Jinja2 自带的过滤器:</p>
<dl class="function">
<dt>
<tt class="descname">tojson</tt><big>(</big><big>)</big></dt>
<dd><p>这个函数把给定的对象转换为 JSON 表示，如果你要动态生成 JavaScript 这里有
一个非常有用的例子。</p>
<p>注意 <cite>script</cite> 标签里的东西不应该被转义，因此如果你想在 <cite>script</cite> 标签里使用它，
请使用 <tt class="docutils literal"><span class="pre">|safe</span></tt> 来禁用转义，:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
    <span class="nx">doSomethingWith</span><span class="p">(</span><span class="cp">{{</span> <span class="nv">user.username</span><span class="o">|</span><span class="nf">tojson</span><span class="o">|</span><span class="nf">safe</span> <span class="cp">}}</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id4">
<h4>控制自动转义<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>自动转义的概念是自动转义特殊字符。 HTML （或 XML ，因此也有 XHTML ）意义下
的特殊字符是 <tt class="docutils literal"><span class="pre">&amp;</span></tt> ， <tt class="docutils literal"><span class="pre">&gt;</span></tt> ， <tt class="docutils literal"><span class="pre">&lt;</span></tt> ， <tt class="docutils literal"><span class="pre">&quot;</span></tt> 以及 <tt class="docutils literal"><span class="pre">'</span></tt> 。因为这些字符在
文档中表示它们特定的含义，如果你想在文本中使用它们，应该把它们替换成相应
的“实体”。不这么做不仅会导致用户疲于在文本中使用这些字符，也会导致安全问题。
（见 <a class="reference internal" href="index.html#xss"><em>跨站脚本攻击（XSS）</em></a> ）</p>
<p>虽然你有时会需要在模板中禁用自动转义，比如在页面中显式地插入 HTML ，
可以是一个来自于 markdown 到 HTML 转换器的安全输出。</p>
<p>我们有三种可行的解决方案:</p>
<ul class="simple">
<li>在传递到模板之前，用 <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> 对象封装 HTML字符串。一般推荐这个方法。</li>
<li>在模板中，使用 <tt class="docutils literal"><span class="pre">|safe</span></tt> 过滤器显式地标记一个字符串为安全的 HTML
（ <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">myvariable|safe</span> <span class="pre">}}</span></tt> ）。</li>
<li>临时地完全禁用自动转义系统。</li>
</ul>
<p>在模板中禁用自动转义系统，可以使用 <tt class="docutils literal"><span class="pre">{%autoescape</span> <span class="pre">%}</span></tt> 块:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">autoescape</span> <span class="kp">false</span> <span class="cp">%}</span>
    <span class="nt">&lt;p&gt;</span>autoescaping is disabled here
    <span class="nt">&lt;p&gt;</span><span class="cp">{{</span> <span class="nv">will_not_be_escaped</span> <span class="cp">}}</span>
<span class="cp">{%</span> <span class="k">endautoescape</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>无论何时，都请务必格外小心这里的变量。</p>
</div>
<div class="section" id="registering-filters">
<span id="id5"></span><h4>注册过滤器<a class="headerlink" href="#registering-filters" title="永久链接至标题">¶</a></h4>
<p>如果你要在 Jinja2 中注册你自己的过滤器，你有两种方法。你可以把它们手动添加到
应用的 <a class="reference internal" href="index.html#flask.Flask.jinja_env" title="flask.Flask.jinja_env"><tt class="xref py py-attr docutils literal"><span class="pre">jinja_env</span></tt></a> 或者使用
<a class="reference internal" href="index.html#flask.Flask.template_filter" title="flask.Flask.template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">template_filter()</span></tt></a> 装饰器。</p>
<p>下面两个例子作用相同，都是反转一个对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.template_filter</span><span class="p">(</span><span class="s">&#39;reverse&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reverse_filter</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">reverse_filter</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">app</span><span class="o">.</span><span class="n">jinja_env</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s">&#39;reverse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reverse_filter</span>
</pre></div>
</div>
<p>在使用装饰器的情况下，如果你想以函数名作为过滤器名，参数是可选的。注册之后，
你可以在模板中像使用 Jinja2 内置过滤器一样使用你的过滤器，例如你在上下文中有
一个名为 <cite>mylist</cite> 的 Python 列表:</p>
<div class="highlight-python"><pre>{% for x in mylist | reverse %}
{% endfor %}</pre>
</div>
</div>
<div class="section" id="id6">
<h4>上下文处理器<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>Flask 上下文处理器自动向模板的上下文中插入新变量。上下文处理器在模板
渲染之前运行，并且可以在模板上下文中插入新值。上下文处理器是一个返回字典
的函数，这个字典的键值最终将传入应用中所有模板的上下文:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.context_processor</span>
<span class="k">def</span> <span class="nf">inject_user</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的上下文处理器使得模板可以使用一个名为 <cite>user</cite> ，值为 <cite>g.user</cite> 的变量。
不过这个例子不是很有意思，因为 <cite>g</cite> 在模板中本来就是可用的，但它解释
了上下文处理器是如何工作的。</p>
<p>变量不仅限于值，上下文处理器也可以使某个函数在模板中可用（由于 Python 允
许传递函数）:</p>
<div class="highlight-python"><pre>@app.context_processor
def utility_processor():
    def format_price(amount, currency=u'€'):
        return u'{0:.2f}{1}.format(amount, currency)
    return dict(format_price=format_price)</pre>
</div>
<p>上面的上下文处理器使得 <cite>format_price</cite> 函数在所有模板中可用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{{</span> <span class="n">format_price</span><span class="p">(</span><span class="mf">0.33</span><span class="p">)</span> <span class="p">}}</span>
</pre></div>
</div>
<p>你也可以构建 <cite>format_price</cite> 为一个模板过滤器（见 <a class="reference internal" href="index.html#registering-filters"><em>注册过滤器</em></a> ），
但这展示了上下文处理器传递函数的工作过程。</p>
</div>
</div>
<span id="document-testing"></span><div class="section" id="flask">
<span id="testing"></span><h3>测试 Flask 应用<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><strong>没有经过测试的东西都是不完整的</strong></div></blockquote>
<p>这一箴言的起源已经不可考了，尽管他不是完全正确的，但是仍然离真理
不远。没有测试过的应用将会使得提高现有代码质量很困难，二不测试应用
程序的开发者，会显得特别多疑。如果一个应用拥有自动化测试，那么您就
可以安全的修改然后立刻知道是否有错误。</p>
<p>Flask 提供了一种方法用于测试您的应用，那就是将 Werkzeug 测试
<a class="reference external" href="http://werkzeug.pocoo.org/docs/test/#werkzeug.test.Client" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> 暴露出来，并且为您操作这些内容
的本地上下文变量。然后您就可以将自己最喜欢的测试解决方案应用于其上了。
在这片文档中，我们将会使用Python自带的 <a class="reference external" href="http://docs.python.org/dev/library/unittest.html#module-unittest" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> 包。</p>
<div class="section" id="id1">
<h4>应用程序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>首先，我们需要一个应用来测试，我们将会使用 <a class="reference internal" href="index.html#tutorial"><em>教程</em></a> 这里的应用
来演示。如果您还没有获取它，请从 <cite>the examples</cite> 这里查找源码。</p>
</div>
<div class="section" id="id3">
<h4>测试的大框架<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了测试这个引用，我们添加了第二个模块(<cite>flaskr_tests.py</cite>)，
并且创建了一个框架如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">flaskr</span>
<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="k">class</span> <span class="nc">FlaskrTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_fd</span><span class="p">,</span> <span class="n">flaskr</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;DATABASE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()</span>
        <span class="n">flaskr</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;TESTING&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">flaskr</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
        <span class="n">flaskr</span><span class="o">.</span><span class="n">init_db</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_fd</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">flaskr</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;DATABASE&#39;</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>在 <a class="reference external" href="http://docs.python.org/dev/library/unittest.html#unittest.TestCase.setUp" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> 方法的代码创建了一个新的测试
客户端并且初始化了一个新的数据库。这个函数将会在每次独立的测试函数
运行之前运行。要在测试之后删除这个数据库，我们在 <a class="reference external" href="http://docs.python.org/dev/library/unittest.html#unittest.TestCase.tearDown" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a>
函数当中关闭这个文件，并将它从文件系统中删除。同时，在初始化的时候
<tt class="docutils literal"><span class="pre">TESTING</span></tt> 配置标志被激活，这将会使得处理请求时的错误捕捉失效，以便于
您在进行对应用发出请求的测试时获得更好的错误反馈。</p>
<p>这个测试客户端将会给我们一个通向应用的简单接口，我们可以激发
对向应用发送请求的测试，并且此客户端也会帮我们记录 Cookie 的
动态。</p>
<p>因为 SQLite3 是基于文件系统的，我们可以很容易的使用临时文件模块来
创建一个临时的数据库并初始化它，函数 <a class="reference external" href="http://docs.python.org/dev/library/tempfile.html#tempfile.mkstemp" title="(在 Python v3.5)"><tt class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></tt></a>
实际上完成了两件事情：它返回了一个底层的文件指针以及一个随机
的文件名，后者我们用作数据库的名字。我们只需要将 <cite>db_fd</cite> 变量
保存起来，就可以使用 <cite>os.close</cite> 方法来关闭这个文件。</p>
<p>如果我们运行这套测试，我们应该会得到如下的输出:</p>
<div class="highlight-python"><pre>$ python flaskr_tests.py

----------------------------------------------------------------------
Ran 0 tests in 0.000s

OK</pre>
</div>
<p>虽然现在还未进行任何实际的测试，我们已经可以知道我们的 flaskr
程序没有语法错误了。否则，在 import 的时候就会抛出一个致死的
错误了。</p>
</div>
<div class="section" id="id4">
<h4>第一个测试<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>是进行第一个应用功能的测试的时候了。让我们检查当我们访问
根路径(<tt class="docutils literal"><span class="pre">/</span></tt>)时应用程序是否正确地返回了了“No entries here so far”
字样。为此，我们添加了一个新的测试函数到我们的类当中，
如下面的代码所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FlaskrTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_fd</span><span class="p">,</span> <span class="n">flaskr</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;DATABASE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">flaskr</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
        <span class="n">flaskr</span><span class="o">.</span><span class="n">init_db</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_fd</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">flaskr</span><span class="o">.</span><span class="n">DATABASE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_empty_db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s">&#39;No entries here so far&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>注意到我们的测试函数以 <cite>test</cite> 开头，这允许 <a class="reference external" href="http://docs.python.org/dev/library/unittest.html#module-unittest" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> 模块自动
识别出哪些方法是一个测试方法，并且运行它。</p>
<p>通过使用 <cite>self.app.get</cite> 我们可以发送一个 HTTP <cite>GET</cite> 请求给应用的
某个给定路径。返回值将会是一个 <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-class docutils literal"><span class="pre">response_class</span></tt></a>
对象。我们可以使用 <a class="reference external" href="http://werkzeug.pocoo.org/docs/wrappers/#werkzeug.wrappers.BaseResponse.data" title="(在 Werkzeug v0.10)"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a> 属性
来检查程序的返回值(以字符串类型)。在这里，我们检查 <tt class="docutils literal"><span class="pre">'No</span> <span class="pre">entries</span> <span class="pre">here</span> <span class="pre">so</span> <span class="pre">far'</span></tt>
是不是输出内容的一部分。</p>
<p>再次运行，您应该看到一个测试成功通过了:</p>
<div class="highlight-python"><pre>$ python flaskr_tests.py
.
----------------------------------------------------------------------
Ran 1 test in 0.034s

OK</pre>
</div>
</div>
<div class="section" id="id5">
<h4>登陆和登出<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>我们应用的大部分功能只允许具有管理员资格的用户访问。所以我们需要
一种方法来帮助我们的测试客户端登陆和登出。为此，我们向登陆和登出
页面发送一些请求，这些请求都携带了表单数据（用户名和密码），因为
登陆和登出页面都会重定向，我们将客户端设置为 <cite>follow_redirects</cite> 。</p>
<p>将如下两个方法加入到您的 <cite>FlaskrTestCase</cite> 类:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">,</span>
        <span class="n">password</span><span class="o">=</span><span class="n">password</span>
    <span class="p">),</span> <span class="n">follow_redirects</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/logout&#39;</span><span class="p">,</span> <span class="n">follow_redirects</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们可以轻松的测试登陆和登出是正常工作还是因认证失败而出错，
添加新的测试函数到类中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_login_logout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s">&#39;You were logged in&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logout</span><span class="p">()</span>
    <span class="k">assert</span> <span class="s">&#39;You were logged out&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">&#39;adminx&#39;</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s">&#39;Invalid username&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;defaultx&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s">&#39;Invalid password&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>测试消息的添加<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>我们同时应该测试消息的添加功能是否正常，添加一个新的
测试方法如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">)</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;/add&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;&lt;Hello&gt;&#39;</span><span class="p">,</span>
        <span class="n">text</span><span class="o">=</span><span class="s">&#39;&lt;strong&gt;HTML&lt;/strong&gt; allowed here&#39;</span>
    <span class="p">),</span> <span class="n">follow_redirects</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s">&#39;No entries here so far&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
    <span class="k">assert</span> <span class="s">&#39;&amp;lt;Hello&amp;gt;&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
    <span class="k">assert</span> <span class="s">&#39;&lt;strong&gt;HTML&lt;/strong&gt; allowed here&#39;</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>这里我们测试计划的行为是否能够正常工作，即在正文中可以出现 HTML
标签，而在标题中不允许。</p>
<p>运行这个测试，我们应该得到三个通过的测试:</p>
<div class="highlight-python"><pre>$ python flaskr_tests.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.332s

OK</pre>
</div>
<p>关于请求的头信息和状态值等更复杂的测试，请参考
<a class="reference external" href="http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/">MiniTwit Example</a> ，在这个例子的源代码里包含
一套更长的测试。</p>
</div>
<div class="section" id="id7">
<h4>其他测试技巧<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>除了如上文演示的使用测试客户端完成测试的方法，也有一个
<a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> 方法可以
配合 <cite>with</cite> 语句用于激活一个临时的请求上下文。通过
它，您可以访问 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 、<a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a>
和 <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 类的对象，就像在视图中一样。
这里有一个完整的例子示范了这种用法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s">&#39;/?name=Peter&#39;</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">flask</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="s">&#39;/&#39;</span>
    <span class="k">assert</span> <span class="n">flask</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Peter&#39;</span>
</pre></div>
</div>
<p>所有其他的和上下文绑定的对象都可以使用同样的方法访问。</p>
<p>如果您希望测试应用在不同配置的情况下的表现，这里似乎没有一个
很好的方法，考虑使用应用的工厂函数(参考 <a class="reference internal" href="index.html#app-factories"><em>应用程序的工厂函数</em></a>)</p>
<p>注意，尽管你在使用一个测试用的请求环境，函数
<a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 以及
<a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> 都不会自动运行。
然而，<a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> 函数在
测试请求的上下文离开 <cite>with</cite> 块的时候会执行。如果您
希望 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 函数仍然执行。
您需要手动调用 <a class="reference internal" href="index.html#flask.Flask.preprocess_request" title="flask.Flask.preprocess_request"><tt class="xref py py-meth docutils literal"><span class="pre">preprocess_request()</span></tt></a> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s">&#39;/?name=Peter&#39;</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">preprocess_request</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这对于打开数据库连接或者其他类似的操作来说，很可能
是必须的，这视您应用的设计方式而定。</p>
<p>如果您希望调用 <a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> 函数，
您需要使用 <a class="reference internal" href="index.html#flask.Flask.process_response" title="flask.Flask.process_response"><tt class="xref py py-meth docutils literal"><span class="pre">process_response()</span></tt></a> 方法。
这个方法需要您传入一个 response 对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s">&#39;/?name=Peter&#39;</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;...&#39;</span><span class="p">)</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">process_response</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这通常不是很有效，因为这时您可以直接转向使用
测试客户端。</p>
</div>
<div class="section" id="faking-resources">
<span id="id8"></span><h4>伪造资源和上下文<a class="headerlink" href="#faking-resources" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<p>在应用上下文或 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-attr docutils literal"><span class="pre">flask.g</span></tt></a> 对象上存储用户认证信息和数据库连接
非常常见。一般的模式是在第一次使用对象时，把对象放在应用上下文或
<a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-attr docutils literal"><span class="pre">flask.g</span></tt></a> 上面，而在请求销毁时移除对象。试想一下例如下面的获
取当前用户的代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_user</span><span class="p">():</span>
    <span class="n">user</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">fetch_current_user_from_database</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="k">return</span> <span class="n">user</span>
</pre></div>
</div>
<p>对于测试，这样易于从外部覆盖这个用户，而不用修改代码。连接
<a class="reference internal" href="index.html#flask.appcontext_pushed" title="flask.appcontext_pushed"><tt class="xref py py-data docutils literal"><span class="pre">flask.appcontext_pushed</span></tt></a> 信号可以很容易地完成这个任务:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">appcontext_pushed</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">user_set</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="k">with</span> <span class="n">appcontext_pushed</span><span class="o">.</span><span class="n">connected_to</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">app</span><span class="p">):</span>
        <span class="k">yield</span>
</pre></div>
</div>
<p>并且之后使用它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">json</span><span class="p">,</span> <span class="n">jsonify</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/users/me&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">users_me</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>

<span class="k">with</span> <span class="n">user_set</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">my_user</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/users/me&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">],</span> <span class="n">my_user</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>保存上下文<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.4 新版功能.</span></p>
</div>
<p>有时，激发一个通常的请求，但是将当前的上下文
保存更长的时间，以便于附加的内省发生是很有用的。
在 Flask 0.4 中，通过 <a class="reference internal" href="index.html#flask.Flask.test_client" title="flask.Flask.test_client"><tt class="xref py py-meth docutils literal"><span class="pre">test_client()</span></tt></a>
函数和 <cite>with</cite> 块的使用可以实现:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/?tequila=42&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;tequila&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;42&#39;</span>
</pre></div>
</div>
<p>如果您仅仅使用 <a class="reference internal" href="index.html#flask.Flask.test_client" title="flask.Flask.test_client"><tt class="xref py py-meth docutils literal"><span class="pre">test_client()</span></tt></a> 方法，而
不使用 <cite>with</cite> 代码块， <cite>assert</cite> 断言会失败，因为 <cite>request</cite>
不再可访问(因为您试图在非真正请求中时候访问它)。</p>
</div>
<div class="section" id="sessions">
<h4>访问和修改 Sessions<a class="headerlink" href="#sessions" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
<p>有时，在测试客户端里访问和修改 Sesstions 可能会非常有用。
通常有两种方法实现这种需求。如果您仅仅希望确保一个 Session
拥有某个特定的键，且此键的值是某个特定的值，那么您可以只
保存起上下文，并且访问 <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-data docutils literal"><span class="pre">flask.session</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">flask</span><span class="o">.</span><span class="n">session</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>但是这样做并不能使您修改 Session 或在请求发出之前访问 Session。
从 Flask 0.8 开始，我们提供一个叫做 “Session 事务” 的东西用于
模拟适当的调用，从而在测试客户端的上下文中打开一个 Session，并
用于修改。在事务的结尾，Session 将被恢复为原来的样子。这些都
独立于 Session 的后端使用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">c</span><span class="o">.</span><span class="n">session_transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">sess</span><span class="p">:</span>
        <span class="n">sess</span><span class="p">[</span><span class="s">&#39;a_key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;a value&#39;</span>

    <span class="c"># once this is reached the session was stored</span>
</pre></div>
</div>
<p>注意到，在此时，您必须使用这个 <tt class="docutils literal"><span class="pre">sess</span></tt> 对象而不是调用
<a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-data docutils literal"><span class="pre">flask.session</span></tt></a> 代理，而这个对象本身提供了同样的接口。</p>
</div>
</div>
<span id="document-errorhandling"></span><div class="section" id="application-errors">
<span id="id1"></span><h3>记录应用错误<a class="headerlink" href="#application-errors" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
<p>应用故障，服务器故障。早晚你会在产品中看见异常。即使你的代码是 100% 正确的，
你仍然会不时看见异常。为什么？因为涉及的所有一切都会出现故障。这里给出一些
完美正确的代码导致服务器错误的情况:</p>
<ul class="simple">
<li>客户端在应用读取到达数据时，提前终止请求</li>
<li>数据库服务器超载，并无法处理查询</li>
<li>文件系统满了</li>
<li>硬盘损坏</li>
<li>后端服务器超载</li>
<li>你所用的库出现程序错误</li>
<li>服务器的网络连接或其它系统故障</li>
</ul>
<p>而且这只是你可能面对的问题的简单情形。那么，我们应该怎么处理这一系列问题？
默认情况下，如果你的应用在以生产模式运行， Flask 会显示一个非常简单的页面并
记录异常到 <a class="reference internal" href="index.html#flask.Flask.logger" title="flask.Flask.logger"><tt class="xref py py-attr docutils literal"><span class="pre">logger</span></tt></a> 。</p>
<p>但是你还可以做些别的，我们会介绍一些更好的设置来应对错误。</p>
<div class="section" id="id2">
<h4>错误邮件<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>如果你的应用在生产模式下运行（会在你的服务器上做），默认情况下，你不会看见
任何日志消息。为什么会这样？Flask 试图实现一个零配置框架。如果没有配置，日
志会存放在哪？猜测不是个好主意，因为它猜测的位置可能不是一个用户有权创建日
志文件的地方。而且，对于大多数小型应用，不会有人关注日志。</p>
<p>事实上，我现在向你保证，如果你给应用错误配置一个日志文件，你将永远不会去看
它，除非在调试问题时用户向你报告。你需要的应是异常发生时的邮件，然后你会得
到一个警报，并做些什么。</p>
<p>Flask 使用 Python 内置的日志系统，而且它确实向你发送你可能需要的错误邮件。
这里给出你如何配置 Flask 日志记录器向你发送报告异常的邮件:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ADMINS</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;yourname@example.com&#39;</span><span class="p">]</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">app</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">logging</span>
    <span class="kn">from</span> <span class="nn">logging.handlers</span> <span class="kn">import</span> <span class="n">SMTPHandler</span>
    <span class="n">mail_handler</span> <span class="o">=</span> <span class="n">SMTPHandler</span><span class="p">(</span><span class="s">&#39;127.0.0.1&#39;</span><span class="p">,</span>
                               <span class="s">&#39;server-error@example.com&#39;</span><span class="p">,</span>
                               <span class="n">ADMINS</span><span class="p">,</span> <span class="s">&#39;YourApplication Failed&#39;</span><span class="p">)</span>
    <span class="n">mail_handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">mail_handler</span><span class="p">)</span>
</pre></div>
</div>
<p>那么刚刚发生了什么？我们创建了一个新的
<a class="reference external" href="http://docs.python.org/dev/library/logging.handlers.html#logging.handlers.SMTPHandler" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></tt></a> 来用监听 <tt class="docutils literal"><span class="pre">127.0.0.1</span></tt> 的邮件服务器
向所有的 <cite>ADMINS</cite> 发送发件人为 <em>server-error&#64;example.com</em> ，主题
为 &#8220;YourApplication Failed&#8221; 的邮件。如果你的邮件服务器需要凭证，这些功能也
被提供了。详情请见 <a class="reference external" href="http://docs.python.org/dev/library/logging.handlers.html#logging.handlers.SMTPHandler" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></tt></a> 的文档。</p>
<p>我们同样告诉处理程序只发送错误和更重要的消息。因为我们的确不想收到警告或是
其它没用的，每次请求处理都会发生的日志邮件。</p>
<p>你在生产环境中运行它之前，请参阅 <a class="reference internal" href="index.html#logformat"><em>控制日志格式</em></a> 来向错误邮件中置放更多的
信息。这会让你少走弯路。</p>
</div>
<div class="section" id="id3">
<h4>记录到文件<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>即便你收到了邮件，你可能还是想记录警告。当调试问题的时候，收集更多的信息是个
好主意。请注意 Flask 核心系统本身不会发出任何警告，所以在古怪的事情发生时发
出警告是你的责任。</p>
<p>在日志系统的方框外提供了一些处理程序，但它们对记录基本错误并不是都有用。最让人
感兴趣的可能是下面的几个:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/dev/library/logging.handlers.html#logging.FileHandler" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">FileHandler</span></tt></a> - 在文件系统上记录日志</li>
<li><a class="reference external" href="http://docs.python.org/dev/library/logging.handlers.html#logging.handlers.RotatingFileHandler" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></tt></a> - 在文件系统上记录日志，
并且当消息达到一定数目时，会滚动记录</li>
<li><a class="reference external" href="http://docs.python.org/dev/library/logging.handlers.html#logging.handlers.NTEventLogHandler" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">NTEventLogHandler</span></tt></a> - 记录到 Windows 系统中的系
统事件日志。如果你在 Windows 上做开发，这就是你想要用的。</li>
<li><a class="reference external" href="http://docs.python.org/dev/library/logging.handlers.html#logging.handlers.SysLogHandler" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></tt></a> - 发送日志到 Unix 的系统日志</li>
</ul>
<p>当你选择了日志处理程序，像前面对 SMTP 处理程序做的那样，只要确保使用一个低级
的设置（我推荐 <cite>WARNING</cite> ）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="ow">not</span> <span class="n">app</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">logging</span>
    <span class="kn">from</span> <span class="nn">themodule</span> <span class="kn">import</span> <span class="n">TheHandlerYouWant</span>
    <span class="n">file_handler</span> <span class="o">=</span> <span class="n">TheHandlerYouWant</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">file_handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">file_handler</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="logformat">
<span id="id4"></span><h4>控制日志格式<a class="headerlink" href="#logformat" title="永久链接至标题">¶</a></h4>
<p>默认情况下，错误处理只会把消息字符串记录到文件或邮件发送给你。一个日志记
录应存储更多的信息，这使得配置你的日志记录器包含那些信息很重要，如此你会
对错误发生的原因，还有更重要的——错误在哪发生，有更好的了解。</p>
<p>格式可以从一个格式化字符串实例化。注意回溯（tracebacks）会被自动加入到日
志条目后，你不需要在日志格式的格式化字符串中这么做。</p>
<p>这里有一些配置实例:</p>
<div class="section" id="id5">
<h5>邮件<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Formatter</span>
<span class="n">mail_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">Formatter</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">Message type:       </span><span class="si">%(levelname)s</span><span class="s"></span>
<span class="s">Location:           </span><span class="si">%(pathname)s</span><span class="s">:</span><span class="si">%(lineno)d</span><span class="s"></span>
<span class="s">Module:             </span><span class="si">%(module)s</span><span class="s"></span>
<span class="s">Function:           </span><span class="si">%(funcName)s</span><span class="s"></span>
<span class="s">Time:               </span><span class="si">%(asctime)s</span><span class="s"></span>

<span class="s">Message:</span>

<span class="si">%(message)s</span><span class="s"></span>
<span class="s">&#39;&#39;&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>日志文件<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h5>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Formatter</span>
<span class="n">file_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">Formatter</span><span class="p">(</span>
    <span class="s">&#39;</span><span class="si">%(asctime)s</span><span class="s"> </span><span class="si">%(levelname)s</span><span class="s">: </span><span class="si">%(message)s</span><span class="s"> &#39;</span>
    <span class="s">&#39;[in </span><span class="si">%(pathname)s</span><span class="s">:</span><span class="si">%(lineno)d</span><span class="s">]&#39;</span>
<span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>复杂日志格式<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h5>
<p>这里给出一个用于格式化字符串的格式变量列表。注意这个列表并不完整，完整的列
表请翻阅 <a class="reference external" href="http://docs.python.org/dev/library/logging.html#module-logging" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">logging</span></tt></a> 包的官方文档。</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">格式</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">%(levelname)s</span></tt></td>
<td>消息文本的记录等级
(<tt class="docutils literal"><span class="pre">'DEBUG'</span></tt>, <tt class="docutils literal"><span class="pre">'INFO'</span></tt>, <tt class="docutils literal"><span class="pre">'WARNING'</span></tt>,
<tt class="docutils literal"><span class="pre">'ERROR'</span></tt>, <tt class="docutils literal"><span class="pre">'CRITICAL'</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">%(pathname)s</span></tt></td>
<td>发起日志记录调用的源文件的完整路径（如果可用）</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">%(filename)s</span></tt></td>
<td>路径中的文件名部分</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">%(module)s</span></tt></td>
<td>模块（文件名的名称部分）</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">%(funcName)s</span></tt></td>
<td>包含日志调用的函数名</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">%(lineno)d</span></tt></td>
<td>日志记录调用所在的源文件行的行号（如果可用）</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">%(asctime)s</span></tt></td>
<td><cite>LogRecord</cite> 创建时的人类可读的时间。默认情况下，格
式为 <tt class="docutils literal"><span class="pre">&quot;2003-07-08</span> <span class="pre">16:49:45,896&quot;</span></tt> （逗号后的数字
时间的毫秒部分）。这可以通过继承
:class:~logging.Formatter，并
重载 <a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Formatter.formatTime" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">formatTime()</span></tt></a> 改变。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">%(message)s</span></tt></td>
<td>记录的消息，视为 <tt class="docutils literal"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></tt></td>
</tr>
</tbody>
</table>
<p>如果你想深度定制日志格式，你可以继承 <a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Formatter" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">Formatter</span></tt></a> 。
<a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Formatter" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">Formatter</span></tt></a> 有三个需要关注的方法:</p>
<dl class="docutils">
<dt><a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Formatter.format" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">format()</span></tt></a>:</dt>
<dd><dl class="first last docutils">
<dt>处理实际上的格式。需要一个 <a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.LogRecord" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">LogRecord</span></tt></a> 对象作为参数，并</dt>
<dd>必须返回一个格式化字符串。</dd>
</dl>
</dd>
<dt><a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Formatter.formatTime" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">formatTime()</span></tt></a>:</dt>
<dd>控制 <cite>asctime</cite> 格式。如果你需要不同的时间格式，可以重载这个函数。</dd>
<dt><a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Formatter.formatException" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">formatException()</span></tt></a></dt>
<dd>控制异常的格式。需要一个 <tt class="xref py py-attr docutils literal"><span class="pre">exc_info</span></tt> 元组作为参数，并必须返
回一个字符串。默认的通常足够好，你不需要重载它。</dd>
</dl>
<p>更多信息请见其官方文档。</p>
</div>
</div>
<div class="section" id="id8">
<h4>其它的库<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>至此，我们只配置了应用自己建立的日志记录器。其它的库也可以记录它们。例如，
SQLAlchemy 在它的核心中大量地使用日志。而在 <a class="reference external" href="http://docs.python.org/dev/library/logging.html#module-logging" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">logging</span></tt></a> 包中有一个方法
可以一次性配置所有的日志记录器，我不推荐使用它。可能存在一种情况，当你想
要在同一个 Python 解释器中并排运行多个独立的应用时，则不可能对它们的日志
记录器做不同的设置。</p>
<p>作为替代，我推荐你找出你有兴趣的日志记录器，用 <a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.getLogger" title="(在 Python v3.5)"><tt class="xref py py-func docutils literal"><span class="pre">getLogger()</span></tt></a>
函数来获取日志记录器，并且遍历它们来附加处理程序:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="n">loggers</span> <span class="o">=</span> <span class="p">[</span><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span> <span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;sqlalchemy&#39;</span><span class="p">),</span>
           <span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;otherlibrary&#39;</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">logger</span> <span class="ow">in</span> <span class="n">loggers</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">mail_handler</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">file_handler</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h3>调试应用错误<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>对于生产应用，按照 <a class="reference internal" href="index.html#application-errors"><em>记录应用错误</em></a> 中的描述来配置你应用的日志记录和
通知。这个章节讲述了调试部署配置和深入一个功能强大的 Python 调试器的要点。</p>
<div class="section" id="id10">
<h4>有疑问时，手动运行<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>在配置你的应用到生产环境时时遇到了问题？如果你拥有主机的 shell 权限，验证你
是否可以在部署环境中手动用 shell 运行你的应用。确保在同一用户账户下运行配置
好的部署来解决权限问题。你可以使用 Flask 内置的开发服务器并设置 <cite>debug=True</cite> ，
这在捕获配置问题的时候非常有效，但是 <strong>请确保在可控环境下临时地这么做。</strong> 不要
在生产环境中使用 <cite>debug=True</cite> 运行。</p>
</div>
<div class="section" id="working-with-debuggers">
<span id="id11"></span><h4>调试器操作<a class="headerlink" href="#working-with-debuggers" title="永久链接至标题">¶</a></h4>
<p>为了深入跟踪代码的执行，Flask 提供了一个方框外的调试器（见 <a class="reference internal" href="index.html#debug-mode"><em>调试模式</em></a> ）。
如果你想用其它的 Python 调试器，请注意相互的调试器接口。你需要设置下面的参数来
使用你中意的调试器:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">debug</span></tt>        - 是否开启调试模式并捕获异常</li>
<li><tt class="docutils literal"><span class="pre">use_debugger</span></tt> - 是否使用内部的 Flask 调试器</li>
<li><tt class="docutils literal"><span class="pre">use_reloader</span></tt> - 是否在异常时重新载入并创建子进程</li>
</ul>
<p><cite>debug</cite> 必须为 True （即异常必须被捕获）来允许其它的两个选项设置为任何值。</p>
<p>如果你使用 Aptana/Eclipse 来调试，你会需要把 <tt class="docutils literal"><span class="pre">use_debugger</span></tt> 和 <tt class="docutils literal"><span class="pre">user_reloader</span></tt>
都设置为 False 。</p>
<p>一个可能有用的配置模式就是在你的 config.yaml 中设置为如下（当然，自行更改为适用
你应用的）:</p>
<div class="highlight-python"><pre>FLASK:
    DEBUG: True
    DEBUG_WITH_APTANA: True</pre>
</div>
<p>然后在你应用的入口（ main.py ），你可以写入下面的内容:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c"># To allow aptana to receive errors, set use_debugger=False</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="s">&quot;config.yaml&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span> <span class="n">use_debugger</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># Disable Flask&#39;s debugger if external debugger is requested</span>
        <span class="n">use_debugger</span> <span class="o">=</span> <span class="ow">not</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;DEBUG_WITH_APTANA&#39;</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">use_debugger</span><span class="o">=</span><span class="n">use_debugger</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
            <span class="n">use_reloader</span><span class="o">=</span><span class="n">use_debugger</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-config"></span><div class="section" id="config">
<span id="id1"></span><h3>配置处理<a class="headerlink" href="#config" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
<p>应用会需要某种配置。你可能会需要根据应用环境更改不同的设置，比如切换调试模
式、设置密钥、或是别的设定环境的东西。</p>
<p>Flask 被设计为需要配置来启动应用。你可以在代码中硬编码配置，这对于小的应用
并不坏，但是有更好的方法。</p>
<p>跟你如何载入配置无关，会有一个可用的配置对象保存着载入的配置值:
<a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 对象的 <a class="reference internal" href="index.html#flask.Flask.config" title="flask.Flask.config"><tt class="xref py py-attr docutils literal"><span class="pre">config</span></tt></a> 属性。这是 Flask
自己放置特定配置值的地方，也是扩展可以存储配置值的地方。但是，你也可以把
自己的配置保存到这个对象里。</p>
<div class="section" id="id2">
<h4>配置基础<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="index.html#flask.Flask.config" title="flask.Flask.config"><tt class="xref py py-attr docutils literal"><span class="pre">config</span></tt></a> 实际上继承于字典，并且可以像修改字典一样修
改它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;DEBUG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>给定的配置值会被推送到 <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-attr docutils literal"><span class="pre">Flask</span></tt></a> 对象中，所以你可以在那里读写它
们:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>你可以使用 <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict.update" title="(在 Python v3.5)"><tt class="xref py py-meth docutils literal"><span class="pre">dict.update()</span></tt></a> 方法来一次性更新多个键:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">DEBUG</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">SECRET_KEY</span><span class="o">=</span><span class="s">&#39;...&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>内置的配置值<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>下列配置值是 Flask 内部使用的:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">DEBUG</span></tt></td>
<td>启用/禁用 调试模式</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">TESTING</span></tt></td>
<td>启用/禁用 测试模式</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">PROPAGATE_EXCEPTIONS</span></tt></td>
<td>显式地允许或禁用异常的传播。如果没有设置
或显式地设置为 <cite>None</cite> ，当 <tt class="docutils literal"><span class="pre">TESTING</span></tt> 或
<tt class="docutils literal"><span class="pre">DEBUG</span></tt> 为真时，这个值隐式地为 true.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">PRESERVE_CONTEXT_ON_EXCEPTION</span></tt></td>
<td>默认情况下，如果应用工作在调试模式，请求
上下文不会在异常时出栈来允许调试器内省。
这可以通过这个键来禁用。你同样可以用这个
设定来强制启用它，即使没有调试执行，这对
调试生产应用很有用（但风险也很大）</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">SECRET_KEY</span></tt></td>
<td>密钥</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_NAME</span></tt></td>
<td>会话 cookie 的名称。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_DOMAIN</span></tt></td>
<td>会话 cookie 的域。如果不设置这个值，则
cookie 对 <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> 的全部子域名有效</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_PATH</span></tt></td>
<td>会话 cookie 的路径。如果不设置这个值，且
没有给 <tt class="docutils literal"><span class="pre">'/'</span></tt> 设置过，则 cookie 对
<tt class="docutils literal"><span class="pre">APPLICATION_ROOT</span></tt> 下的所有路径有效。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_HTTPONLY</span></tt></td>
<td>控制 cookie 是否应被设置 httponly 的标志，
默认为 <cite>True</cite></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_SECURE</span></tt></td>
<td>控制 cookie 是否应被设置安全标志，默认
为 <cite>False</cite></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">PERMANENT_SESSION_LIFETIME</span></tt></td>
<td>以 <a class="reference external" href="http://docs.python.org/dev/library/datetime.html#datetime.timedelta" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">datetime.timedelta</span></tt></a> 对象控制
长期会话的生存时间。从 Flask 0.8 开始，也
可以用整数来表示秒。</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">SESSION_REFRESH_EACH_REQUEST</span></tt></td>
<td>这个标志控制永久会话如何刷新。如果被设置为
<cite>True</cite> （这是默认值），每一个请求 cookie
都会被刷新。如果设置为 <cite>False</cite> ，只有当
cookie 被修改后才会发送一个 <cite>set-cookie</cite>
的标头。非永久会话不会受到这个配置项的影响
。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">USE_X_SENDFILE</span></tt></td>
<td>启用/禁用 x-sendfile</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">LOGGER_NAME</span></tt></td>
<td>日志记录器的名称</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt></td>
<td>服务器名和端口。需要这个选项来支持子域名
（例如： <tt class="docutils literal"><span class="pre">'myapp.dev:5000'</span></tt> ）。注意
localhost 不支持子域名，所以把这个选项设
置为 “localhost” 没有意义。设置
<tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> 默认会允许在没有请求上下文
而仅有应用上下文时生成 URL</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">APPLICATION_ROOT</span></tt></td>
<td>如果应用不占用完整的域名或子域名，这个选项可
以被设置为应用所在的路径。这个路径也会用于会
话 cookie 的路径值。如果直接使用域名，则留作
<tt class="docutils literal"><span class="pre">None</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">MAX_CONTENT_LENGTH</span></tt></td>
<td>如果设置为字节数， Flask 会拒绝内容长度大于
此值的请求进入，并返回一个 413 状态码</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">SEND_FILE_MAX_AGE_DEFAULT</span></tt>:</td>
<td>默认缓存控制的最大期限，以秒计，在
<a class="reference internal" href="index.html#flask.Flask.send_static_file" title="flask.Flask.send_static_file"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.send_static_file()</span></tt></a> (默认的
静态文件处理器)中使用。对于单个文件分别在
<a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 或
<a class="reference internal" href="index.html#flask.Blueprint" title="flask.Blueprint"><tt class="xref py py-class docutils literal"><span class="pre">Blueprint</span></tt></a> 上使用
<a class="reference internal" href="index.html#flask.Flask.get_send_file_max_age" title="flask.Flask.get_send_file_max_age"><tt class="xref py py-meth docutils literal"><span class="pre">get_send_file_max_age()</span></tt></a>
来覆盖这个值。默认为 43200（12小时）。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">TRAP_HTTP_EXCEPTIONS</span></tt></td>
<td>如果这个值被设置为 <tt class="docutils literal"><span class="pre">True</span></tt> ，Flask不会执行
HTTP 异常的错误处理，而是像对待其它异常一样，
通过异常栈让它冒泡地抛出。这对于需要找出
HTTP 异常源头的可怕调试情形是有用的。</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">TRAP_BAD_REQUEST_ERRORS</span></tt></td>
<td>Werkzeug 处理请求中的特定数据的内部数据结构会
抛出同样也是“错误的请求”异常的特殊的 key
errors 。同样地，为了保持一致，许多操作可以
显式地抛出 BadRequest 异常。因为在调试中，你
希望准确地找出异常的原因，这个设置用于在这些
情形下调试。如果这个值被设置为 <tt class="docutils literal"><span class="pre">True</span></tt> ，你
只会得到常规的回溯。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">PREFERRED_URL_SCHEME</span></tt></td>
<td>生成URL的时候如果没有可用的 URL 模式话将使
用这个值。默认为 <tt class="docutils literal"><span class="pre">http</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">JSON_AS_ASCII</span></tt></td>
<td>默认情况下 Flask 使用 ascii 编码来序列化对
象。如果这个值被设置为 False ， Flask不会
将其编码为 ASCII，并且按原样输出，返回它的
unicode 字符串。比如 <tt class="docutils literal"><span class="pre">jsonfiy</span></tt> 会自动地采用
<tt class="docutils literal"><span class="pre">utf-8</span></tt> 来编码它然后才进行传输。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">JSON_SORT_KEYS</span></tt></td>
<td>默认情况下 Flask 按照 JSON 对象的键的顺序来序
来序列化它。这样做是为了确保键的顺序不会受到
字典的哈希种子的影响，从而返回的值每次都是
一致的，不会造成无用的额外 HTTP 缓存。你可
以通过修改这个配置的值来覆盖默认的操作。但
这是不被推荐的做法因为这个默认的行为可能会给
你在性能的代价上带来改善。</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">JSONIFY_PRETTYPRINT_REGULAR</span></tt></td>
<td>如果这个配置项被  <tt class="docutils literal"><span class="pre">True</span></tt> （默认值），
如果不是 XMLHttpRequest 请求的话（由
<tt class="docutils literal"><span class="pre">X-Requested-With</span></tt>  标头控制）
json 字符串的返回值会被漂亮地打印出来。</td>
</tr>
</tbody>
</table>
<div class="admonition-server-name admonition">
<p class="first admonition-title">关于 <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> 的更多</p>
<p><tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> 用于子域名支持。因为 Flask 在得知现有服务器名之前不能
猜测出子域名部分，所以如果你想使用子域名，这个选项是必要的，并且也用于会
话 cookie 。</p>
<p class="last">请注意，不只是 Flask 有不知道子域名是什么的问题，你的 web 浏览器也会这
样。现代 web 浏览器不允许服务器名不含有点的跨子域名 cookie 。所以如果你
的服务器名是 <tt class="docutils literal"><span class="pre">'localhost'</span></tt> ，你不能在 <tt class="docutils literal"><span class="pre">'localhost'</span></tt> 和它的每个子域名
下设置 cookie 。请选择一个合适的服务器名，像 <tt class="docutils literal"><span class="pre">'myapplication.local'</span></tt> ，
并添加你想要的 服务器名 + 子域名 到你的 host 配置或设置一个本地 <a class="reference external" href="https://www.isc.org/software/bind">绑定</a> 。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.4 新版功能: </span><tt class="docutils literal"><span class="pre">LOGGER_NAME</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能: </span><tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能: </span><tt class="docutils literal"><span class="pre">MAX_CONTENT_LENGTH</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能: </span><tt class="docutils literal"><span class="pre">PROPAGATE_EXCEPTIONS</span></tt>, <tt class="docutils literal"><span class="pre">PRESERVE_CONTEXT_ON_EXCEPTION</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能: </span><tt class="docutils literal"><span class="pre">TRAP_BAD_REQUEST_ERRORS</span></tt>, <tt class="docutils literal"><span class="pre">TRAP_HTTP_EXCEPTIONS</span></tt>,
<tt class="docutils literal"><span class="pre">APPLICATION_ROOT</span></tt>, <tt class="docutils literal"><span class="pre">SESSION_COOKIE_DOMAIN</span></tt>,
<tt class="docutils literal"><span class="pre">SESSION_COOKIE_PATH</span></tt>, <tt class="docutils literal"><span class="pre">SESSION_COOKIE_HTTPONLY</span></tt>,
<tt class="docutils literal"><span class="pre">SESSION_COOKIE_SECURE</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能: </span><tt class="docutils literal"><span class="pre">PREFERRED_URL_SCHEME</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能: </span><tt class="docutils literal"><span class="pre">JSON_AS_ASCII</span></tt>, <tt class="docutils literal"><span class="pre">JSON_SORT_KEYS</span></tt>, <tt class="docutils literal"><span class="pre">JSONIFY_PRETTYPRINT_REGULAR</span></tt></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">1.0 新版功能: </span><tt class="docutils literal"><span class="pre">SESSION_REFRESH_EACH_REQUEST</span></tt></p>
</div>
</div>
<div class="section" id="id5">
<h4>从文件配置<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>如果你能在独立的文件里存储配置，理想情况是存储在当前应用包之外，它将变得更
有用。这使得通过各式包处理工具（ <a class="reference internal" href="index.html#distribute-deployment"><em>部署和分发</em></a> ）打包和分发
你的应用成为可能，并在之后才修改配置文件。</p>
<p>则一个常见模式为如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;yourapplication.default_settings&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_envvar</span><span class="p">(</span><span class="s">&#39;YOURAPPLICATION_SETTINGS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>首先从 <cite>yourapplication.default_settings</cite> 模块加载配置，然后用
<span class="target" id="index-0"></span><tt class="xref std std-envvar docutils literal"><span class="pre">YOURAPPLICATION_SETTINGS</span></tt> 环境变量指向的文件的内容覆
盖其值。 在 Linux 或 OS X 上，这个环境变量可以在服务器启动之前
，在 shell 中用 export 命令设置:</p>
<div class="highlight-python"><pre>$ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg
$ python run-app.py
 * Running on http://127.0.0.1:5000/
 * Restarting with reloader...</pre>
</div>
<p>在 Windows 下则使用其内置的 <cite>set</cite> 命令:</p>
<div class="highlight-python"><pre>&gt;set YOURAPPLICATION_SETTINGS=\path\to\settings.cfg</pre>
</div>
<p>配置文件其实是 Python 文件。只有大写名称的值才会被存储到配置对象中。所以
请确保你在配置键中使用了大写字母。</p>
<p>这里是一个配置文件的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Example configuration</span>
<span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="s">&#39;?</span><span class="se">\xbf</span><span class="s">,</span><span class="se">\xb4\x8d\xa3</span><span class="s">&quot;&lt;</span><span class="se">\x9c\xb0</span><span class="s">@</span><span class="se">\x0f</span><span class="s">5</span><span class="se">\xab</span><span class="s">,w</span><span class="se">\xee\x8d</span><span class="s">$0</span><span class="se">\x13\x8b</span><span class="s">83&#39;</span>
</pre></div>
</div>
<p>确保足够早载入配置，这样扩展才能在启动时访问配置。配置对象上也有其它方法来
从多个文件中载入配置。完整的参考请阅读 <a class="reference internal" href="index.html#flask.Config" title="flask.Config"><tt class="xref py py-class docutils literal"><span class="pre">Config</span></tt></a> 对象的文档。</p>
</div>
<div class="section" id="id6">
<h4>配置的最佳实践<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>之前提到的建议的缺陷是它会使得测试变得有点困难。基本上，这个问题没有单一的
100% 解决方案，但是你可以注意下面的事项来改善体验:</p>
<ol class="arabic simple">
<li>在函数中创建你的应用，并在上面注册蓝图。这样你可以用不同的配置来创建
多个应用实例，以此使得单元测试变得很简单。你可以用这样的方法来按需传
入配置。</li>
<li>不要写出在导入时需要配置的代码。如果你限制只在请求中访问配置，你可以在
之后按需重新配置对象。</li>
</ol>
</div>
<div class="section" id="id7">
<h4>开发 / 生产<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>大多数应用不止需要一份配置。生产服务器和开发期间使用的服务器应该各有一份单独
的配置。处理这个的最简单方法是，使用一份默认的总会被载入的配置，和一部分版本
控制，以及独立的配置来像上面提到的例子中必要的那样覆盖值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;yourapplication.default_settings&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_envvar</span><span class="p">(</span><span class="s">&#39;YOURAPPLICATION_SETTINGS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>然后你只需要添加一个独立的 <cite>config.py</cite> 文件然后 export
<tt class="docutils literal"><span class="pre">YOURAPPLICATION_SETTINGS=/path/to/config.py</span></tt> 。不过，也有其它可选的方式。
例如你可以使用导入或继承。</p>
<p>在 Django 世界中流行的是在文件顶部，显式地使用
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">yourapplication.default_settings</span> <span class="pre">import</span> <span class="pre">*</span></tt> 导入配置文件，并手动覆
盖更改。你也可以检查一个类似 <tt class="docutils literal"><span class="pre">YOURAPPLICATION_MODE</span></tt> 的环境变量来设置
<cite>production</cite> ， <cite>development</cite> 等等，并导入基于此的不同的硬编码文件。</p>
<p>一个有意思的模式是在配置中使用类和继承:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">TESTING</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">DATABASE_URI</span> <span class="o">=</span> <span class="s">&#39;sqlite://:memory:&#39;</span>

<span class="k">class</span> <span class="nc">ProductionConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
    <span class="n">DATABASE_URI</span> <span class="o">=</span> <span class="s">&#39;mysql://user@localhost/foo&#39;</span>

<span class="k">class</span> <span class="nc">DevelopmentConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">TestingConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
    <span class="n">TESTING</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>启用这样的配置你需要调用 <a class="reference internal" href="index.html#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;configmodule.ProductionConfig&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>管理配置文件有许多方式，这取决于你。这里仍然给出一个好建议的列表:</p>
<ul class="simple">
<li>在版本控制中保留一个默认的配置。向配置中迁移这份默认配置，或者在覆盖
配置值前，在你自己的配置文件中导入它。</li>
<li>使用环境变量来在配置间切换。这样可以在 Python 解释器之外完成，使开发
和部署更容易，因为你可以在不触及代码的情况下快速简便地切换配置。如果你
经常在不同的项目中作业，你甚至可以创建激活一个 virtualenv 并导出开发
配置的脚本。</li>
<li>使用 <a class="reference external" href="http://fabfile.org/">fabric</a> 之类的工具在生产环境中独立地向生产服务器推送代码和配置。
参阅 <a class="reference internal" href="index.html#fabric-deployment"><em>使用 Fabric 部署</em></a> 模式来获得更详细的信息。</li>
</ul>
</div>
<div class="section" id="instance-folders">
<span id="id8"></span><h4>实例文件夹<a class="headerlink" href="#instance-folders" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
<p>Flask 0.8 引入了示例文件夹。 Flask 在很长时间使得直接引用相对应用文件夹
的路径成为可能(通过 <tt class="xref py py-attr docutils literal"><span class="pre">Flask.root_path</span></tt> )。这也是许多开发者加载存储
在载入应用旁边的配置的方法。不幸的是，这只会在应用不是包，即根路径指向包
内容的情况下才能工作。</p>
<p>在 Flask 0.8 中，引入了 <tt class="xref py py-attr docutils literal"><span class="pre">Flask.instance_path</span></tt> 并提出了“实例文件夹”
的新概念。实例文件夹被为不使用版本控制和特定的部署而设计。这是放置运行时
更改的文件和配置文件的最佳位置。</p>
<p>你可以在创建 Flask 应用时显式地提供实例文件夹的路径，也可以让 Flask 自
动找到它。对于显式的配置，使用 <cite>instance_path</cite> 参数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="n">instance_path</span><span class="o">=</span><span class="s">&#39;/path/to/instance/folder&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意给出的 <em>一定</em> 是绝对路径。</p>
<p>如果 <cite>instance_path</cite> 参数没有赋值，会使用下面默认的位置:</p>
<ul>
<li><p class="first">未安装的模块:</p>
<div class="highlight-python"><pre>/myapp.py
/instance</pre>
</div>
</li>
<li><p class="first">未安装的包:</p>
<div class="highlight-python"><pre>/myapp
    /__init__.py
/instance</pre>
</div>
</li>
<li><p class="first">已安装的包或模块:</p>
<div class="highlight-python"><pre>$PREFIX/lib/python2.X/site-packages/myapp
$PREFIX/var/myapp-instance</pre>
</div>
<p><tt class="docutils literal"><span class="pre">$PREFIX</span></tt> 是你 Python 安装的前缀。这个前缀可以是 <tt class="docutils literal"><span class="pre">/usr</span></tt> 或者你的
virtualenv 的路径。你可以打印 <tt class="docutils literal"><span class="pre">sys.prefix</span></tt> 的值来查看前缀被设置成
了什么。</p>
</li>
</ul>
<p>既然配置对象提供从相对文件名来载入配置的方式，那么我们也使得它从相对实例
路径的文件名加载成为可能，如果你想这样做。配置文件中的相对路径的行为可以
在“相对应用的根目录”（默认）和 “相对实例文件夹”中切换，后者通过应用构造函
数的 <cite>instance_relative_config</cite> 开关实现:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="n">instance_relative_config</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>这里有一个配置 Flask 来从模块预载入配置并覆盖配置文件夹中配置文件（如果
存在）的完整例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="n">instance_relative_config</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;yourapplication.default_settings&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="s">&#39;application.cfg&#39;</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>实例文件夹的路径可以在 <tt class="xref py py-attr docutils literal"><span class="pre">Flask.instance_path</span></tt> 找到。 Flask 也提供了
一个打开实例文件夹中文件的捷径，就是 <tt class="xref py py-meth docutils literal"><span class="pre">Flask.open_instance_resource()</span></tt> 。</p>
<p>两者的使用示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">instance_path</span><span class="p">,</span> <span class="s">&#39;application.cfg&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c"># or via open_instance_resource:</span>
<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_instance_resource</span><span class="p">(</span><span class="s">&#39;application.cfg&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<span id="document-signals"></span><div class="section" id="signals">
<span id="id1"></span><h3>信号<a class="headerlink" href="#signals" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
<p>从 Flask 0.6 开始， Flask 集成了信号支持。这个支持由 <a class="reference external" href="http://pypi.python.org/pypi/blinker">blinker</a> 库提供，
并且当它不可用时会优雅地退回。</p>
<p>什么是信号？信号通过发送发生在核心框架的其它地方或 Flask 扩展的动作
时的通知来帮助你解耦应用。简而言之，信号允许特定的发送端通知订阅者发
生了什么。</p>
<p>Flask 提供了几个信号，其它的扩展可能会提供更多。另外，请注意信号倾向于
通知订阅者，而不应该鼓励订阅者修改数据。你会注意到，信号似乎和一些内置的
装饰器做同样的事情（例如： <a class="reference internal" href="index.html#flask.request_started" title="flask.request_started"><tt class="xref py py-data docutils literal"><span class="pre">request_started</span></tt></a> 与
<a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 十分相似）。然而它们工作的方式是有
差异的。譬如核心的 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 处理程序以特定的顺
序执行，并且可以在返回响应之前放弃请求。相比之下，所有的信号处理器执行的
顺序没有定义，并且不修改任何数据。</p>
<p>信号之于其它处理器最大的优势是你可以在一秒钟的不同的时段上安全地订阅。譬
如这些临时的订阅对单元测试很有用。比如说你想要知道哪个模板被作为请求的一
部分渲染：信号允许你完全地了解这些。</p>
<div class="section" id="id2">
<h4>订阅信号<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你可以使用信号的 <a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Signal.connect" title="(在 Blinker v1.1)"><tt class="xref py py-meth docutils literal"><span class="pre">connect()</span></tt></a> 方法来订阅信号。该
函数的第一个参数是信号发出时要调用的函数，第二个参数是可选的，用于确定信号
的发送端。退订一个信号，可以使用 <a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Signal.disconnect" title="(在 Blinker v1.1)"><tt class="xref py py-meth docutils literal"><span class="pre">disconnect()</span></tt></a>
方法。</p>
<p>对于所有的核心 Flask 信号，发送端都是发出信号的应用。当你订阅一个信号，请
确保也提供一个发送端，除非你确实想监听全部应用的信号。这在你开发一个扩展
的时候尤其正确。</p>
<p>比如这里有一个用于在单元测试中找出哪个模板被渲染和传入模板的变量的助手上
下文管理器:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">template_rendered</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">captured_templates</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">recorded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
        <span class="n">recorded</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>
    <span class="n">template_rendered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">recorded</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">template_rendered</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>这可以很容易地与一个测试客户端配对:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">captured_templates</span><span class="p">(</span><span class="n">app</span><span class="p">)</span> <span class="k">as</span> <span class="n">templates</span><span class="p">:</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">rv</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">templates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">template</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">template</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;index.html&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="s">&#39;items&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>
</div>
<p>确保订阅使用了一个额外的 <tt class="docutils literal"><span class="pre">**extra</span></tt> 参数，这样当 Flask 对信号引入新参数
时你的调用不会失败。</p>
<p>代码中，从 <cite>with</cite> 块的应用 <cite>app</cite> 中流出的渲染的所有模板现在会被记录到
<cite>templates</cite> 变量。无论何时模板被渲染，模板对象和上下文中都会被添加到它
里面。</p>
<p>此外，也有一个方便的助手方法（ <a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Signal.connected_to" title="(在 Blinker v1.1)"><tt class="xref py py-meth docutils literal"><span class="pre">connected_to()</span></tt></a> ）
，它允许你临时地把函数订阅到信号并使用信号自己的上下文管理器。因为这个上下文
管理器的返回值不能由我们决定，所以必须把列表作为参数传入:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">template_rendered</span>

<span class="k">def</span> <span class="nf">captured_templates</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">recorded</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">recorded</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">template_rendered</span><span class="o">.</span><span class="n">connected_to</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的例子会看起来是这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">templates</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">with</span> <span class="n">captured_templates</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">template</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition-blinker-api admonition">
<p class="first admonition-title">Blinker API 变更</p>
<p class="last"><a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Signal.connected_to" title="(在 Blinker v1.1)"><tt class="xref py py-meth docutils literal"><span class="pre">connected_to()</span></tt></a> 方法出现于 Blinker 1.1 。</p>
</div>
</div>
<div class="section" id="id3">
<h4>创建信号<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想要在自己的应用中使用信号，你可以直接使用 blinker 库。最常见的用法
是在自定义的 <a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Namespace" title="(在 Blinker v1.1)"><tt class="xref py py-class docutils literal"><span class="pre">Namespace</span></tt></a> 中命名信号。这也是大多数时候
推荐的做法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">blinker</span> <span class="kn">import</span> <span class="n">Namespace</span>
<span class="n">my_signals</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">()</span>
</pre></div>
</div>
<p>现在你可以这样创建新的信号:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model_saved</span> <span class="o">=</span> <span class="n">my_signals</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="s">&#39;model-saved&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这里使用唯一的信号名，简化调试。可以用 <a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.NamedSignal.name" title="(在 Blinker v1.1)"><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt></a>
属性来访问信号名。</p>
<div class="admonition- admonition">
<p class="first admonition-title">给扩展开发者</p>
<p class="last">如果你在编写一个 Flask 扩展并且你想优雅地在没有 blinker 安装时退化，你可以用
<a class="reference internal" href="index.html#flask.signals.Namespace" title="flask.signals.Namespace"><tt class="xref py py-class docutils literal"><span class="pre">flask.signals.Namespace</span></tt></a> 这么做。</p>
</div>
</div>
<div class="section" id="signals-sending">
<span id="id4"></span><h4>发送信号<a class="headerlink" href="#signals-sending" title="永久链接至标题">¶</a></h4>
<p>如果你想要发出信号，调用 <a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Signal.send" title="(在 Blinker v1.1)"><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt></a> 方法可以做到。
它接受发送端作为第一个参数，和一些推送到信号订阅者的可选关键字参数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">model_saved</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>永远尝试选择一个合适的发送端。如果你有一个发出信号的类，把 <cite>self</cite> 作为发送
端。如果你从一个随机的函数发出信号，把 <tt class="docutils literal"><span class="pre">current_app._get_current_object()</span></tt>
作为发送端。</p>
<div class="admonition- admonition">
<p class="first admonition-title">传递代理作为发送端</p>
<p class="last">永远不要向信号传递 <a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> 作为发送端，使用
<tt class="docutils literal"><span class="pre">current_app._get_current_object()</span></tt> 作为替代。这样的原因是，
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> 是一个代理，而不是真正的应用对象。</p>
</div>
</div>
<div class="section" id="flask">
<h4>信号与 Flask 的请求上下文<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h4>
<p>信号在接收时，完全支持 <a class="reference internal" href="index.html#request-context"><em>请求上下文</em></a> 。上下文本地的变量在
<a class="reference internal" href="index.html#flask.request_started" title="flask.request_started"><tt class="xref py py-data docutils literal"><span class="pre">request_started</span></tt></a> 和 <a class="reference internal" href="index.html#flask.request_finished" title="flask.request_finished"><tt class="xref py py-data docutils literal"><span class="pre">request_finished</span></tt></a> 一贯可用，
所以你可以信任 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">flask.g</span></tt></a> 和其它需要的东西。注意 <a class="reference internal" href="index.html#signals-sending"><em>发送信号</em></a>
和 <a class="reference internal" href="index.html#flask.request_tearing_down" title="flask.request_tearing_down"><tt class="xref py py-data docutils literal"><span class="pre">request_tearing_down</span></tt></a> 信号中描述的限制。</p>
</div>
<div class="section" id="id5">
<h4>基于装饰器的信号订阅<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>你可以在 Blinker 1.1 中容易地用新的
<tt class="xref py py-meth docutils literal"><span class="pre">connect_via()</span></tt> 装饰器订阅信号:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">template_rendered</span>

<span class="nd">@template_rendered.connect_via</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">when_template_rendered</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;Template </span><span class="si">%s</span><span class="s"> is rendered with </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>核心信号<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>下列是 Flask 中存在的信号:</p>
<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">template_rendered</tt></dt>
<dd><p>当模板成功渲染的时候，这个信号会发出。这个信号与模板实例
<cite>template</cite> 和上下文的字典（名为 <cite>context</cite> ）一起调用。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">log_template_renders</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">sender</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Rendering template &quot;</span><span class="si">%s</span><span class="s">&quot; with context </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span>
                        <span class="n">template</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s">&#39;string template&#39;</span><span class="p">,</span>
                        <span class="n">context</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">template_rendered</span>
<span class="n">template_rendered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">log_template_renders</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">request_started</tt></dt>
<dd><p>这个信号在处建立请求上下文之外的任何请求处理开始前发送。因为请求上下文
已经被约束，订阅者可以用 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 之类的标准全局代理访问
请求。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">log_request</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">sender</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Request context is set up&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request_started</span>
<span class="n">request_started</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">log_request</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">request_finished</tt></dt>
<dd><p>这个信号恰好在请求发送给客户端之前发送。它传递名为 <cite>response</cite> 的响应。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">log_response</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">sender</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Request context is about to close down.  &#39;</span>
                        <span class="s">&#39;Response: </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request_finished</span>
<span class="n">request_finished</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">log_response</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">got_request_exception</tt></dt>
<dd><p>这个信号在请求处理中抛出异常时发送。它在标准异常处理生效 <em>之前</em> ，甚至是
在没有异常处理的情况下发送。异常本身会通过 <cite>exception</cite> 传递到订阅函数。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">log_exception</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">sender</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Got exception during processing: </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">got_request_exception</span>
<span class="n">got_request_exception</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">log_exception</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">request_tearing_down</tt></dt>
<dd><p>这个信号在请求销毁时发送。它总是被调用，即使发生异常。当前监听这个信号
的函数会在常规销毁处理后被调用，但这不是你可以信赖的。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">close_db_connection</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request_tearing_down</span>
<span class="n">request_tearing_down</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">close_db_connection</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>从 Flask 0.9 ，如果有异常的话它会被传递一个 <cite>exc</cite> 关键字参数引用导致销
毁的异常。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">appcontext_tearing_down</tt></dt>
<dd><p>这个信号在应用上下文销毁时发送。它总是被调用，即使发生异常。当前监听这个信号
的函数会在常规销毁处理后被调用，但这不是你可以信赖的。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">close_db_connection</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request_tearing_down</span>
<span class="n">appcontext_tearing_down</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">close_db_connection</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>如果有异常它会被传递一个 <cite>exc</cite> 关键字参数引用导致销毁的异常。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">appcontext_pushed</tt></dt>
<dd><p>这个信号在应用上下文压入栈时发送。发送者是应用对象。这通常在单元测试中
为了暂时地钩住信息比较有用。例如这可以用来提前在 <cite>g</cite> 对象上设置一些资源。</p>
<p>用法示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">appcontext_pushed</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">user_set</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="k">with</span> <span class="n">appcontext_pushed</span><span class="o">.</span><span class="n">connected_to</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">app</span><span class="p">):</span>
        <span class="k">yield</span>
</pre></div>
</div>
<p>测试代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_user_me</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">user_set</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="s">&#39;john&#39;</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/users/me&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">resp</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s">&#39;username=john&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">appcontext_popped</tt></dt>
<dd><p>这个信号在应用上下文弹出栈时发送。发送者是应用对象。这通常在
<tt class="xref py py-data docutils literal"><span class="pre">appcontext_tearing_down</span></tt> 信号发送后发送。</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">flask.</tt><tt class="descname">message_flashed</tt></dt>
<dd><p>这个信号在应用对象闪现一个消息时发送。消息作为 <cite>message</cite> 命名参数发送，
分类则是 <cite>category</cite> 参数。</p>
<p>订阅示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">recorded</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">):</span>
    <span class="n">recorded</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">message_flashed</span>
<span class="n">message_flashed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

</div>
</div>
<span id="document-views"></span><div class="section" id="views">
<span id="id1"></span><h3>即插视图<a class="headerlink" href="#views" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
<p>Flask 0.7 引入了即插视图，灵感来自 Django 的基于类而不是函数的通用视图。
其主要目的是让你可以对已实现的部分进行替换，并且这个方式可以定制即插视
图。</p>
<div class="section" id="id2">
<h4>基本原则<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>想象你有一个从数据库载入一个对象列表并渲染到视图的函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_users</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">users</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;users.html&#39;</span><span class="p">,</span> <span class="n">users</span><span class="o">=</span><span class="n">users</span><span class="p">)</span>
</pre></div>
</div>
<p>这是简单而灵活的，但如果你想要用一种通用的，同样可以适应其它模型和模板的
方式来提供这个视图，你会需要更大的灵活性。这就是基于类的即插视图所做的。
第一步，把它转换为基于类的视图，你要这样做:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask.views</span> <span class="kn">import</span> <span class="n">View</span>

<span class="k">class</span> <span class="nc">ShowUsers</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">dispatch_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">users</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;users.html&#39;</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="n">users</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">ShowUsers</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;show_users&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>如你所见，你需要做的是创建一个 <a class="reference internal" href="index.html#flask.views.View" title="flask.views.View"><tt class="xref py py-class docutils literal"><span class="pre">flask.views.View</span></tt></a> 的子类，
并且实现 <a class="reference internal" href="index.html#flask.views.View.dispatch_request" title="flask.views.View.dispatch_request"><tt class="xref py py-meth docutils literal"><span class="pre">dispatch_request()</span></tt></a> 。然后我们需要用类方法
<a class="reference internal" href="index.html#flask.views.View.as_view" title="flask.views.View.as_view"><tt class="xref py py-meth docutils literal"><span class="pre">as_view()</span></tt></a> 把这个类转换到一个实际的视图函数。你传给
这个函数的字符串是视图之后的最终名称。但是用它自己实现的方法不够有效，所以
我们稍微重构一下代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask.views</span> <span class="kn">import</span> <span class="n">View</span>

<span class="k">class</span> <span class="nc">ListView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get_template_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">render_template</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_template_name</span><span class="p">(),</span> <span class="o">**</span><span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dispatch_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;objects&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_objects</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">render_template</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">UserView</span><span class="p">(</span><span class="n">ListView</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get_template_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;users.html&#39;</span>

    <span class="k">def</span> <span class="nf">get_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>这当然不是那么有助于一个小例子，但是对于解释基本原则已经很有用了。当你有一
个基于类的视图，那么问题来了， <cite>self</cite> 指向什么。它工作的方式是，无论何时请
求被调度，会创建这个类的一个新实例，并且
<a class="reference internal" href="index.html#flask.views.View.dispatch_request" title="flask.views.View.dispatch_request"><tt class="xref py py-meth docutils literal"><span class="pre">dispatch_request()</span></tt></a> 方法会以 URL 规则为参数调用。
这个类本身会用传递到 <a class="reference internal" href="index.html#flask.views.View.as_view" title="flask.views.View.as_view"><tt class="xref py py-meth docutils literal"><span class="pre">as_view()</span></tt></a> 函数的参数来实例化。
比如，你可以像这样写一个类:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">RenderTemplateView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template_name</span> <span class="o">=</span> <span class="n">template_name</span>
    <span class="k">def</span> <span class="nf">dispatch_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_name</span><span class="p">)</span>
</pre></div>
</div>
<p>然后你可以这样注册它::
And then you can register it like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/about&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">RenderTemplateView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span>
    <span class="s">&#39;about_page&#39;</span><span class="p">,</span> <span class="n">template_name</span><span class="o">=</span><span class="s">&#39;about.html&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>方法提示<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>即插视图可以像常规函数一样用 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-func docutils literal"><span class="pre">route()</span></tt></a> 或更好的
<a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a> 附加到应用中。然而当你附加它时，你必须
提供 HTTP 方法的名称。为了将这个信息加入到类中，你可以提供
<a class="reference internal" href="index.html#flask.views.View.methods" title="flask.views.View.methods"><tt class="xref py py-attr docutils literal"><span class="pre">methods</span></tt></a> 属性来承载它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">dispatch_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
            <span class="o">...</span>
        <span class="o">...</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/myview&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">MyView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;myview&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>基于调度的方法<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对每个 HTTP 方法执行不同的函数，对 RESTful API 非常有用。你可以通过
<a class="reference internal" href="index.html#flask.views.MethodView" title="flask.views.MethodView"><tt class="xref py py-class docutils literal"><span class="pre">flask.views.MethodView</span></tt></a> 容易地实现。每个 HTTP 方法映射到同名函数
（只有名称为小写的）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask.views</span> <span class="kn">import</span> <span class="n">MethodView</span>

<span class="k">class</span> <span class="nc">UserAPI</span><span class="p">(</span><span class="n">MethodView</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">users</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">from_form_data</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">)</span>
        <span class="o">...</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">UserAPI</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;users&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>如此，你可以不提供 <a class="reference internal" href="index.html#flask.views.View.methods" title="flask.views.View.methods"><tt class="xref py py-attr docutils literal"><span class="pre">methods</span></tt></a> 属性。它会自动的按照
类中定义的方法来设置。</p>
</div>
<div class="section" id="id5">
<h4>装饰视图<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>既然视图类自己不是加入到路由系统的视图函数，那么装饰视图类并没有多大意义。
相反的，你可以手动装饰 <a class="reference internal" href="index.html#flask.views.View.as_view" title="flask.views.View.as_view"><tt class="xref py py-meth docutils literal"><span class="pre">as_view()</span></tt></a> 的返回值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">user_required</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks whether user is logged in or raises error 401.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="p">:</span>
            <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="n">view</span> <span class="o">=</span> <span class="n">user_required</span><span class="p">(</span><span class="n">UserAPI</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;users&#39;</span><span class="p">))</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">view</span><span class="p">)</span>
</pre></div>
</div>
<p>从 Flask 0.8 开始，你也有一种在类声明中设定一个装饰器列表的方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UserAPI</span><span class="p">(</span><span class="n">MethodView</span><span class="p">):</span>
    <span class="n">decorators</span> <span class="o">=</span> <span class="p">[</span><span class="n">user_required</span><span class="p">]</span>
</pre></div>
</div>
<p>因为从调用者的视角来看 self 是不明确的，所以你不能在单独的视图方法上使用
常规的视图装饰器，请记住这些。</p>
</div>
<div class="section" id="api">
<h4>用于 API 的方法视图<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h4>
<p>Web API 的工作通常与 HTTP 动词紧密相关，所以这使得实现这样一个基于
<a class="reference internal" href="index.html#flask.views.MethodView" title="flask.views.MethodView"><tt class="xref py py-class docutils literal"><span class="pre">MethodView</span></tt></a> 类的 API 很有意义。也就是说，你会注意到
大多数时候， API 需要不同的 URL 规则来访问相同的方法视图。譬如，想象一种
情况，你在 web 上暴露一个用户对象:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="22%" />
<col width="56%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>URL</td>
<td>HTTP 方法</td>
<td>描述</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">/users/</span></tt></td>
<td><tt class="docutils literal"><span class="pre">GET</span></tt></td>
<td>获得全部用户的列表</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">/users/</span></tt></td>
<td><tt class="docutils literal"><span class="pre">POST</span></tt></td>
<td>创建一个新用户</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">/users/&lt;id&gt;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">GET</span></tt></td>
<td>显示某个用户</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">/users/&lt;id&gt;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">PUT</span></tt></td>
<td>更新某个用户</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">/users/&lt;id&gt;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DELETE</span></tt></td>
<td>删除某个用户</td>
</tr>
</tbody>
</table>
<p>那么，你会想用 <a class="reference internal" href="index.html#flask.views.MethodView" title="flask.views.MethodView"><tt class="xref py py-class docutils literal"><span class="pre">MethodView</span></tt></a> 做什么？诀窍是利用你可以
对相同的视图提供多个规则的事实。</p>
<p>让我们假设这时视图看起来是这个样子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UserAPI</span><span class="p">(</span><span class="n">MethodView</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">user_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># return a list of users</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># expose a single user</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># create a new user</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="c"># delete a single user</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="c"># update a single user</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>如此，我们怎样把它挂载到路由系统中？添加两条规则，并且为每条规则显式地
指出 HTTP 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user_view</span> <span class="o">=</span> <span class="n">UserAPI</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;user_api&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;user_id&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span>
                 <span class="n">view_func</span><span class="o">=</span><span class="n">user_view</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,])</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">user_view</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">,])</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/users/&lt;int:user_id&gt;&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">user_view</span><span class="p">,</span>
                 <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;PUT&#39;</span><span class="p">,</span> <span class="s">&#39;DELETE&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>如果你有许多看起来类似的 API ，你可以重构上述的注册代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">register_api</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">pk</span><span class="o">=</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">pk_type</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">):</span>
    <span class="n">view_func</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="n">endpoint</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="n">pk</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span>
                     <span class="n">view_func</span><span class="o">=</span><span class="n">view_func</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,])</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">view_func</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">,])</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&lt;</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">pk_type</span><span class="p">,</span> <span class="n">pk</span><span class="p">),</span> <span class="n">view_func</span><span class="o">=</span><span class="n">view_func</span><span class="p">,</span>
                     <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;PUT&#39;</span><span class="p">,</span> <span class="s">&#39;DELETE&#39;</span><span class="p">])</span>

<span class="n">register_api</span><span class="p">(</span><span class="n">UserAPI</span><span class="p">,</span> <span class="s">&#39;user_api&#39;</span><span class="p">,</span> <span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">pk</span><span class="o">=</span><span class="s">&#39;user_id&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-appcontext"></span><div class="section" id="app-context">
<span id="id1"></span><h3>应用上下文<a class="headerlink" href="#app-context" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
<p>Flask 背后的设计理念之一就是，代码在执行时会处于两种不同的“状态”（states）。
当 <tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt> 对象被实例化后在模块层次上应用便开始隐式地处于应用配置状
态。一直到第一个请求还是到达这种状态才隐式地结束。当应用处于这个状态的时候
，你可以认为下面的假设是成立的：</p>
<ul class="simple">
<li>程序员可以安全地修改应用对象</li>
<li>目前还没有处理任何请求</li>
<li>你必须得有一个指向应用对象的引用来修改它。不会有某个神奇的代理变量指向
你刚创建的或者正在修改的应用对象的</li>
</ul>
<p>相反，到了第二个状态，在处理请求时，有一些其它的规则:</p>
<ul class="simple">
<li>当一个请求激活时，上下文的本地对象（ <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-data docutils literal"><span class="pre">flask.request</span></tt></a> 和其它对象等）
指向当前的请求</li>
<li>你可以在任何时间里使用任何代码与这些对象通信</li>
</ul>
<p>这里有一个第三种情况，有一点点差异。有时，你正在用类似请求处理时方式来
与应用交互，即使并没有活动的请求。想象一下你用交互式 Python shell 与应用
交互的情况，或是一个命令行应用的情况。</p>
<p><a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> 上下文本地变量就是应用上下文驱动的。</p>
<div class="section" id="id2">
<h4>应用上下文的作用<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>应用上下问存在的主要原因是，在过去，请求上下文被附加了一堆函数，但是又没
有什么好的解决方案。因为 Flask 设计的支柱之一是你可以在一个 Python 进程中
拥有多个应用。</p>
<p>那么代码如何找到“正确的”应用？在过去，我们推荐显式地到处传递应用，但是这
会让我们在使用不是以这种理念设计的库时遇到问题。</p>
<p>解决上述问题的常用方法是使用后面将会提到的 <a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> 代
理对象，它被绑定到当前请求的应用的引用。既然无论如何在没有请求时创建一个
这样的请求上下文是一个没有必要的昂贵操作，应用上下文就被引入了。</p>
</div>
<div class="section" id="id3">
<h4>创建应用上下文<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>有两种方式来创建应用上下文。第一种是隐式的：无论何时当一个请求上下文被压栈时，
如果有必要的话一个应用上下文会被一起创建。由于这个原因，你可以忽略应用
上下文的存在，除非你需要它。</p>
<p>第二种是显式地调用 <a class="reference internal" href="index.html#flask.Flask.app_context" title="flask.Flask.app_context"><tt class="xref py py-meth docutils literal"><span class="pre">app_context()</span></tt></a> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">current_app</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
    <span class="c"># within this block, current_app points to app.</span>
    <span class="k">print</span> <span class="n">current_app</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>在配置了 <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> 时，应用上下文也被用于 <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> 函
数。这允许你在没有请求时生成 URL 。</p>
</div>
<div class="section" id="id4">
<h4>应用上下文局部变量<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>应用上下文会在必要时被创建和销毁。它不会在线程间移动，并且也不会在不同的请求
之间共享。正因为如此，它是一个存储数据库连接信息或是别的东西的最佳位置。内部
的栈对象叫做 <a class="reference internal" href="index.html#flask._app_ctx_stack" title="flask._app_ctx_stack"><tt class="xref py py-data docutils literal"><span class="pre">flask._app_ctx_stack</span></tt></a> 。扩展可以在最顶层自由地存储额外信
息，想象一下它们用一个充分独特的名字在那里存储信息，而不是在 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">flask.g</span></tt></a>
对象里， <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">flask.g</span></tt></a> 是留给用户的代码用的。</p>
<p>更多详情见 <a class="reference internal" href="index.html#extension-dev"><em>Flask 扩展开发</em></a> 。</p>
</div>
<div class="section" id="id5">
<h4>上下文用法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>上下文的一个典型应用场景就是用来缓存一些我们需要在发生请求之前或者要使用的
资源。举个例子，比如数据库连接。当我们在应用上下文中来存储东西的时候你
得选择一个唯一的名字，这是因为应用上下文为 Flask 应用和扩展所共享。</p>
<p>最常见的应用就是把资源的管理分成如下两个部分：</p>
<ol class="arabic simple">
<li>一个缓存在上下文中的隐式资源</li>
<li>当上下文被销毁时重新分配基础资源</li>
</ol>
<p>通常来讲，这将会有一个 <tt class="docutils literal"><span class="pre">get_X()</span></tt> 函数来创建资源 <tt class="docutils literal"><span class="pre">X</span></tt> ，如果它还不存在的话。
存在的话就直接返回它。另外还会有一个 <tt class="docutils literal"><span class="pre">teardown_X()</span></tt> 的回调函数用于销毁资源
<tt class="docutils literal"><span class="pre">X</span></tt> 。</p>
<p>如下是我们刚刚提到的连接数据库的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">get_db</span><span class="p">():</span>
    <span class="n">db</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;_database&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">db</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">db</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_database</span> <span class="o">=</span> <span class="n">connect_to_database</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">db</span>

<span class="nd">@app.teardown_appcontext</span>
<span class="k">def</span> <span class="nf">teardown_db</span><span class="p">(</span><span class="n">exception</span><span class="p">):</span>
    <span class="n">db</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;_database&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>当 <tt class="docutils literal"><span class="pre">get_db()</span></tt> 这个函数第一次被调用的时候数据库连接已经被建立了。
为了使得看起来更隐式一点我们可以使用 <a class="reference external" href="http://werkzeug.pocoo.org/docs/local/#werkzeug.local.LocalProxy" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">LocalProxy</span></tt></a> 这
个类：</p>
<blockquote>
<div>from werkzeug.local import LocalProxy
db = LocalProxy(get_db)</div></blockquote>
<p>这样的话用户就可以直接通过访问 <tt class="docutils literal"><span class="pre">db</span></tt> 来获取数据句柄了， <tt class="docutils literal"><span class="pre">db</span></tt> 已经在内部完
成了对 <tt class="docutils literal"><span class="pre">get_db()</span></tt> 的调用。</p>
</div>
</div>
<span id="document-reqcontext"></span><div class="section" id="request-context">
<span id="id1"></span><h3>请求上下文<a class="headerlink" href="#request-context" title="永久链接至标题">¶</a></h3>
<p>这部分文档描述了在 Flask 0.7 中的行为，与旧的行为基本一致，但有细小微妙的
差异。</p>
<p>这里推荐先阅读 <a class="reference internal" href="index.html#app-context"><em>应用上下文</em></a> 章节。</p>
<div class="section" id="id2">
<h4>深入上下文作用域<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>比如说你有一个应用函数返回用户应该跳转到的 URL 。想象它总是会跳转到 URL
的 <tt class="docutils literal"><span class="pre">next</span></tt> 参数，或 HTTP referrer ，或索引页:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span><span class="p">,</span> <span class="n">url_for</span>

<span class="k">def</span> <span class="nf">redirect_url</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;next&#39;</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="n">request</span><span class="o">.</span><span class="n">referrer</span> <span class="ow">or</span> \
           <span class="n">url_for</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如你所见，它访问了请求对象。当你试图在纯 Python shell 中运行这段代码时，
你会看见这样的异常:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">redirect_url</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;request&#39;</span>
</pre></div>
</div>
<p>这有很大意义，因为我们当前并没有可以访问的请求。所以我们需要制造一个
请求并且绑定到当前的上下文。 <a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-attr docutils literal"><span class="pre">test_request_context</span></tt></a> 方
法为我们创建一个 <a class="reference internal" href="index.html#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><tt class="xref py py-class docutils literal"><span class="pre">RequestContext</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s">&#39;/?next=http://example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>可以通过两种方式利用这个上下文：使用 <cite>with</cite> 声明或是调用
<a class="reference internal" href="index.html#flask.ctx.RequestContext.push" title="flask.ctx.RequestContext.push"><tt class="xref py py-meth docutils literal"><span class="pre">push()</span></tt></a> 和
<a class="reference internal" href="index.html#flask.ctx.RequestContext.pop" title="flask.ctx.RequestContext.pop"><tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt></a> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
</pre></div>
</div>
<p>从这点开始，你可以使用请求对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">redirect_url</span><span class="p">()</span>
<span class="go">u&#39;http://example.com/&#39;</span>
</pre></div>
</div>
<p>直到你调用 <cite>pop</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>因为请求上下文在内部作为一个栈来维护，所以你可以多次压栈出栈。这在实现
内部重定向之类的东西时很方便。</p>
<p>更多如何从交互式 Python shell 中利用请求上下文的信息，请见 <a class="reference internal" href="index.html#shell"><em>与 Shell 共舞</em></a>
章节。</p>
</div>
<div class="section" id="id3">
<h4>上下文如何工作<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你研究 Flask WSGI 应用内部如何工作，你会找到和这非常相似的一段代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_dispatch_request</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_response</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="xref py py-meth docutils literal"><span class="pre">request_context()</span></tt> 方法返回一个新的
<a class="reference internal" href="index.html#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><tt class="xref py py-class docutils literal"><span class="pre">RequestContext</span></tt></a> 对象，并结合 <cite>with</cite> 声明来绑定上下文。
从相同线程中被调用的一切，直到 <cite>with</cite> 声明结束前，都可以访问全局的请求
变量（ <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-data docutils literal"><span class="pre">flask.request</span></tt></a> 和其它）。</p>
<p>请求上下文内部工作如同一个栈。栈顶是当前活动的请求。
<a class="reference internal" href="index.html#flask.ctx.RequestContext.push" title="flask.ctx.RequestContext.push"><tt class="xref py py-meth docutils literal"><span class="pre">push()</span></tt></a> 把上下文添加到栈顶，
<a class="reference internal" href="index.html#flask.ctx.RequestContext.pop" title="flask.ctx.RequestContext.pop"><tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt></a> 把它移出栈。在出栈时，应用的
<a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-func docutils literal"><span class="pre">teardown_request()</span></tt></a> 函数也会被执行。</p>
<p>另一件需要注意的事是，请求上下文被压入栈时，并且没有当前应用的应用上下文，
它会自动创建一个 <a class="reference internal" href="index.html#app-context"><em>应用上下文</em></a> 。</p>
</div>
<div class="section" id="callbacks-and-errors">
<span id="id4"></span><h4>回调和错误<a class="headerlink" href="#callbacks-and-errors" title="永久链接至标题">¶</a></h4>
<p>在 Flask 中，请求处理时发生一个错误时会发生什么？这个特殊的行为在 0.7 中
变更了，因为我们想要更简单地得知实际发生了什么。新的行为相当简单:</p>
<ol class="arabic simple">
<li>在每个请求之前，执行 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 上绑定的函数。
如果这些函数中的某个返回了一个响应，其它的函数将不再被调用。任何情况
下，无论如何这个返回值都会替换视图的返回值。</li>
<li>如果 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 上绑定的函数没有返回一个响应，
常规的请求处理将会生效，匹配的视图函数有机会返回一个响应。</li>
<li>视图的返回值之后会被转换成一个实际的响应对象，并交给
<a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> 上绑定的函数适当地替换或修改它。</li>
<li>在请求的最后，会执行 <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> 上绑定的函
数。这总会发生，即使在一个未处理的异常抛出后或是没有请求前处理器执行过
（例如在测试环境中你有时会想不执行请求前回调）。</li>
</ol>
<p>现在错误时会发生什么？在生产模式中，如果一个异常没有被捕获，将调用
500 internal server 的处理。在生产模式中，即便异常没有被处理过，也会往上冒
泡抛给给 WSGI 服务器。如此，像交互式调试器这样的东西可以提供有用的调试信息。</p>
<p>在 0.7 中做出的一个重大变更是内部服务器错误不再被请求后回调传递处理，而且
请求后回调也不再保证会执行。这使得内部的调度代码更简洁，易于定制和理解。</p>
<p>新的绑定于销毁请求的函数被认为是用于代替那些请求的最后绝对需要发生的事。</p>
</div>
<div class="section" id="id5">
<h4>销毁回调<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>销毁回调是是特殊的回调，因为它们在不同的点上执行。严格地说，它们不依赖实际
的请求处理，因为它们限定在 <a class="reference internal" href="index.html#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><tt class="xref py py-class docutils literal"><span class="pre">RequestContext</span></tt></a> 对象的生命周期。
当请求上下文出栈时， <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> 上绑定的函数会
被调用。</p>
<p>这对于了解请求上下文的寿命是否因为在 with 声明中使用测试客户端或在命令行
中使用请求上下文时被延长很重要:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/foo&#39;</span><span class="p">)</span>
    <span class="c"># the teardown functions are still not called at that point</span>
    <span class="c"># even though the response ended and you have the response</span>
    <span class="c"># object in your hand</span>

<span class="c"># only when the code reaches this point the teardown functions</span>
<span class="c"># are called.  Alternatively the same thing happens if another</span>
<span class="c"># request was triggered from the test client</span>
</pre></div>
</div>
<p>从这些命令行操作中，很容易看出它的行为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.teardown_request</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">teardown_request</span><span class="p">(</span><span class="n">exception</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;this runs after request&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">this runs after request</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意销毁回调总是会被执行，即使没有请求前回调执行过，或是异常发生。测试系
统的特定部分也会临时地在不调用请求前处理器的情况下创建请求上下文。确保你
写的请求销毁处理器不会报错。</p>
</div>
<div class="section" id="notes-on-proxies">
<span id="id6"></span><h4>留意代理<a class="headerlink" href="#notes-on-proxies" title="永久链接至标题">¶</a></h4>
<p>Flask 中提供的一些对象是其它对象的代理。背后的原因是，这些代理在线程间共享，
并且它们在必要的情景中被调度到限定在一个线程中的实际的对象。</p>
<p>大多数时间你不需要关心它，但是在一些例外情况中，知道一个对象实际上是代理是
有益的:</p>
<ul class="simple">
<li>代理对象不会伪造它们继承的类型，所以如果你想运行真正的实例检查，你需要
在被代理的实例上这么做（见下面的 <cite>_get_current_object</cite> ）。</li>
<li>如果对象引用是重要的（例如发送 <a class="reference internal" href="index.html#signals"><em>信号</em></a> ）</li>
</ul>
<p>如果你需要访问潜在的被代理的对象，你可以使用
<a class="reference external" href="http://werkzeug.pocoo.org/docs/local/#werkzeug.local.LocalProxy._get_current_object" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">_get_current_object()</span></tt></a> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">current_app</span><span class="o">.</span><span class="n">_get_current_object</span><span class="p">()</span>
<span class="n">my_signal</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>错误时的上下文保护<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>无论错误出现与否，在请求的最后，请求上下文会出栈，并且相关的所有数据会被
销毁。在开发中，当你想在异常发生时，长期地获取周围的信息，这会成为麻烦。
在 Flask 0.6 和更早版本中的调试模式，如果发生异常，请求上下文不会被弹出栈，
这样交互式调试器才能提供给你重要信息。</p>
<p>从 Flask 0.7 开始，我们设定 <tt class="docutils literal"><span class="pre">PRESERVE_CONTEXT_ON_EXCEPTION</span></tt> 配置变量来
更好地控制该行为。这个值默认与 <tt class="docutils literal"><span class="pre">DEBUG</span></tt> 的设置相关。当应用工作在调试模式
下时，上下文会被保护，而生产模式下相反。</p>
<p>不要在生产模式强制激活 <tt class="docutils literal"><span class="pre">PRESERVE_CONTEXT_ON_EXCEPTION</span></tt> ，因为它会导致在
异常时应用的内存泄露。不过，它在开发时获取开发模式下相同的错误行为来试图
调试一个只有生产设置下才发生的错误时很有用。</p>
</div>
</div>
<span id="document-blueprints"></span><div class="section" id="blueprints">
<span id="id1"></span><h3>用蓝图实现模块化的应用<a class="headerlink" href="#blueprints" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
<p>Flask 用 <em>蓝图（blueprints）</em> 的概念来在一个应用中或跨应用制作应用组件和支
持通用的模式。蓝图很好地简化了大型应用工作的方式，并提供给 Flask 扩展在应用
上注册操作的核心方法。一个 <tt class="xref py py-class docutils literal"><span class="pre">Blueprint</span></tt> 对象与 <tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt> 应用对
象的工作方式很像，但它确实不是一个应用，而是一个描述如何构建或扩展应用的
<em>蓝图</em> 。</p>
<div class="section" id="id2">
<h4>为什么使用蓝图？<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>Flask 中的蓝图为这些情况设计:</p>
<ul class="simple">
<li>把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化
一个应用对象，初始化几个扩展，并注册一集合的蓝图。</li>
<li>以 URL 前缀和/或子域名，在应用上注册一个蓝图。 URL 前缀/子域名中的参数即
成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）。</li>
<li>在一个应用中用不同的 URL 规则多次注册一个蓝图。</li>
<li>通过蓝图提供模板过滤器、静态文件、模板和其它功能。一个蓝图不一定要实现应
用或者视图函数。</li>
<li>初始化一个 Flask 扩展时，在这些情况中注册一个蓝图。</li>
</ul>
<p>Flask 中的蓝图不是即插应用，因为它实际上并不是一个应用——它是可以注册，甚至
可以多次注册到应用上的操作集合。为什么不使用多个应用对象？你可以做到那样
（见 <a class="reference internal" href="index.html#app-dispatch"><em>应用调度</em></a> ），但是你的应用的配置是分开的，并在 WSGI 层管理。</p>
<p>蓝图作为 Flask 层提供分割的替代，共享应用配置，并且在必要情况下可以更改所
注册的应用对象。它的缺点是你不能在应用创建后撤销注册一个蓝图而不销毁整个
应用对象。</p>
</div>
<div class="section" id="id3">
<h4>蓝图的设想<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>蓝图的基本设想是当它们注册到应用上时，它们记录将会被执行的操作。
当分派请求和生成从一个端点到另一个的 URL 时，Flask 会关联蓝图中的视图函数。</p>
</div>
<div class="section" id="id4">
<h4>我的第一个蓝图<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这看起来像是一个非常基本的蓝图。在这个案例中，我们想要实现一个简单渲染静态
模板的蓝图:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span><span class="p">,</span> <span class="n">render_template</span><span class="p">,</span> <span class="n">abort</span>
<span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">TemplateNotFound</span>

<span class="n">simple_page</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">&#39;simple_page&#39;</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span>
                        <span class="n">template_folder</span><span class="o">=</span><span class="s">&#39;templates&#39;</span><span class="p">)</span>

<span class="nd">@simple_page.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;page&#39;</span><span class="p">:</span> <span class="s">&#39;index&#39;</span><span class="p">})</span>
<span class="nd">@simple_page.route</span><span class="p">(</span><span class="s">&#39;/&lt;page&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;pages/</span><span class="si">%s</span><span class="s">.html&#39;</span> <span class="o">%</span> <span class="n">page</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">TemplateNotFound</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
</pre></div>
</div>
<p>当我们使用 <tt class="docutils literal"><span class="pre">&#64;simple_page.route</span></tt> 装饰器绑定函数时，在蓝图之后被注册时它
会记录把 <cite>show</cite> 函数注册到应用上的意图。此外，它会给函数的端点加上
由 <tt class="xref py py-class docutils literal"><span class="pre">Blueprint</span></tt> 的构造函数中给出的蓝图的名称作为前缀（在此例
中是 <tt class="docutils literal"><span class="pre">simple_page</span></tt> ）。</p>
</div>
<div class="section" id="id5">
<h4>注册蓝图<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>那么你如何注册蓝图？像这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">yourapplication.simple_page</span> <span class="kn">import</span> <span class="n">simple_page</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">simple_page</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你检查已经注册到应用的规则，你会发现这些:</p>
<div class="highlight-python"><pre>[&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;,
 &lt;Rule '/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,
 &lt;Rule '/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]</pre>
</div>
<p>第一个显然是来自应用自身，用于静态文件。其它的两个用于 <tt class="docutils literal"><span class="pre">simple_page</span></tt>
蓝图中的 <cite>show</cite> 函数。如你所见，它们的前缀是蓝图的名称，并且用一个点
（ <tt class="docutils literal"><span class="pre">.</span></tt> ）来分割。</p>
<p>不过，蓝图也可以在不同的位置挂载:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">simple_page</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">&#39;/pages&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>那么，这些果然是生成出的规则:</p>
<div class="highlight-python"><pre>[&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;,
 &lt;Rule '/pages/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,
 &lt;Rule '/pages/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]</pre>
</div>
<p>在此之上，你可以多次注册蓝图，虽然不是每个蓝图都会正确地响应这些。实际上，
蓝图能否被多次挂载，取决于蓝图是怎样实现的。</p>
</div>
<div class="section" id="id6">
<h4>蓝图资源<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>蓝图也可以提供资源。有时候你会只为它提供的资源而引入一个蓝图。</p>
<div class="section" id="id7">
<h5>蓝图资源文件夹<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h5>
<p>像常规的应用一样，蓝图被设想为包含在一个文件夹中。当多个蓝图源于同一个文件
夹时，可以不必考虑上述情况，但也这通常不是推荐的做法。</p>
<p>这个文件夹会从 <tt class="xref py py-class docutils literal"><span class="pre">Blueprint</span></tt> 的第二个参数中推断出来，通常是 <cite>__name__</cite> 。
这个参数决定对应蓝图的是哪个逻辑的 Python 模块或包。如果它指向一个存在的
Python 包，这个包（通常是文件系统中的文件夹）就是资源文件夹。如果是一个模块，
模块所在的包就是资源文件夹。你可以访问 <tt class="xref py py-attr docutils literal"><span class="pre">Blueprint.root_path</span></tt> 属性来查看
资源文件夹是什么:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_page</span><span class="o">.</span><span class="n">root_path</span>
<span class="go">&#39;/Users/username/TestProject/yourapplication&#39;</span>
</pre></div>
</div>
<p>可以使用 <tt class="xref py py-meth docutils literal"><span class="pre">open_resource()</span></tt> 函数来快速从这个文件夹打开源文件:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">simple_page</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;static/style.css&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h5>静态文件<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h5>
<p>一个蓝图可以通过 <cite>static_folder</cite> 关键字参数提供一个指向文件系统上文件夹的路
径，来暴露一个带有静态文件的文件夹。这可以是一个绝对路径，也可以是相对于蓝图
文件夹的路径:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">admin</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">static_folder</span><span class="o">=</span><span class="s">&#39;static&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>默认情况下，路径最右边的部分就是它在 web 上所暴露的地址。因为这里这个文件夹
叫做 <tt class="docutils literal"><span class="pre">static</span></tt> ，它会在 蓝图 + <tt class="docutils literal"><span class="pre">/static</span></tt> 的位置上可用。也就是说，蓝图为
<tt class="docutils literal"><span class="pre">/admin</span></tt> 把静态文件夹注册到 <tt class="docutils literal"><span class="pre">/admin/static</span></tt> 。</p>
<p>最后是命名的 <cite>blueprint_name.static</cite> ，这样你可以生成它的 URL ，就像你对应用
的静态文件夹所做的那样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;admin.static&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;style.css&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h5>模板<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h5>
<p>如果你想要蓝图暴露模板，你可以提供 <tt class="xref py py-class docutils literal"><span class="pre">Blueprint</span></tt> 构造函数中的
<cite>template_folder</cite> 参数来实现:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">admin</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">template_folder</span><span class="o">=</span><span class="s">&#39;templates&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>像对待静态文件一样，路径可以是绝对的或是相对蓝图资源文件夹的。模板文件夹会
被加入到模板的搜索路径中，但是比实际的应用模板文件夹优先级低。这样，你可以
容易地在实际的应用中覆盖蓝图提供的模板。</p>
<p>那么当你有一个 <tt class="docutils literal"><span class="pre">yourapplication/admin</span></tt> 文件夹中的蓝图并且你想要渲染
<tt class="docutils literal"><span class="pre">'admin/index.html'</span></tt> 模板，且你已经提供了 <tt class="docutils literal"><span class="pre">templates</span></tt> 作为
<cite>template_folder</cite> ，你需要这样创建文件:
<tt class="docutils literal"><span class="pre">yourapplication/admin/templates/admin/index.html</span></tt></p>
</div>
</div>
<div class="section" id="url">
<h4>构造 URL<a class="headerlink" href="#url" title="永久链接至标题">¶</a></h4>
<p>当你想要从一个页面链接到另一个页面，你可以像通常一个样使用 <tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt>
函数，只是你要在 URL 的末端加上蓝图的名称和一个点（ <tt class="docutils literal"><span class="pre">.</span></tt> ）作为前缀:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;admin.index&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>此外，如果你在一个蓝图的视图函数或是模板中想要从链接到同一蓝图下另一个端点，
你可以通过对端点只加上一个点作为前缀来使用相对的重定向:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;.index&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这个案例中，它实际上链接到 <tt class="docutils literal"><span class="pre">admin.index</span></tt> ，假如请求被分派到任何其它的
admin 蓝图端点。</p>
</div>
</div>
<span id="document-extensions"></span><div class="section" id="flask">
<h3>Flask 扩展<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h3>
<p>Flask 扩展用多种不同的方式扩充 Flask 的功能。比如加入数据库支持和其它的
常见任务。</p>
<div class="section" id="id1">
<h4>寻找扩展<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p><a class="reference external" href="http://flask.pocoo.org/extensions/">Flask Extension Registry</a> 中列出了 Flask 扩展，并且可以通过
<tt class="docutils literal"><span class="pre">easy_install</span></tt> 或 <tt class="docutils literal"><span class="pre">pip</span></tt> 下载。如果你把一个 Flask 扩展添加到
<tt class="docutils literal"><span class="pre">requirements.rst</span></tt> 或 <tt class="docutils literal"><span class="pre">setup.py</span></tt> 文件的依赖关系中，它们通常可以用一个
简单的命令或是在你应用安装时被安装。</p>
</div>
<div class="section" id="id2">
<h4>使用扩展<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>扩展通常附带有文档，来展示如何使用它。扩展的行为没有一个可以预测的一般性
规则，除了它们是从同一个位置导入的。如果你有一个名为 <tt class="docutils literal"><span class="pre">Flask-Foo</span></tt> 或是
<tt class="docutils literal"><span class="pre">Foo-Flask</span></tt> 的扩展，你可以从 <tt class="docutils literal"><span class="pre">flask.ext.foo</span></tt> 导入它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask.ext</span> <span class="kn">import</span> <span class="n">foo</span>
</pre></div>
</div>
</div>
<div class="section" id="flask-0-8">
<h4>Flask 0.8 以前<a class="headerlink" href="#flask-0-8" title="永久链接至标题">¶</a></h4>
<p>如果你在使用 Flask 0.7 或更早的版本，包 <tt class="xref py py-data docutils literal"><span class="pre">flask.ext</span></tt> 并不存在，你不得不
从 <tt class="docutils literal"><span class="pre">flaskext.foo</span></tt> 或 <tt class="docutils literal"><span class="pre">flask_foo</span></tt> 中导入，这取决与应用是如何分发的。如果你
想要开发支持 Flask 0.7 或更早版本的应用，你仍然应该从 <tt class="xref py py-data docutils literal"><span class="pre">flask.ext</span></tt> 中导
入。我们提供了一个兼容性模块来在 Flask 的老版本中提供这个包。你可以从 github
上下载它：<a class="reference external" href="https://github.com/mitsuhiko/flask/raw/master/scripts/flaskext_compat.py">flaskext_compat.py</a></p>
<p>这里是使用它的方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">flaskext_compat</span>
<span class="n">flaskext_compat</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">flask.ext</span> <span class="kn">import</span> <span class="n">foo</span>
</pre></div>
</div>
<p>一旦激活了 <tt class="docutils literal"><span class="pre">flaskext_compat</span></tt> 模块，就会存在 <tt class="xref py py-data docutils literal"><span class="pre">flask.ext</span></tt> ，并且你可以从
那里开始导入。</p>
</div>
</div>
<span id="document-shell"></span><div class="section" id="shell">
<span id="id1"></span><h3>与 Shell 共舞<a class="headerlink" href="#shell" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
<p>Python 拥有的交互式 Shell 是人人都喜欢它的一个重要原因。交互式 Shell
允许你实时的运行 Python 命令并且立即得到返回结果。Flask 本身并未内置
一个交互式 Shell ，因为它并不需要任何前台的特殊设置，仅仅导入您的应用
然后开始探索和使用即可。</p>
<p>然而这里有一些易于获得的助手，可以帮助您在 Shell 遨游时获得更为
愉悦的体验。交互式控制台回话的一个重要问题是，您并不是像在浏览器
当中那样激发一个请求，因此 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 和 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-data docutils literal"><span class="pre">request</span></tt></a>
以及其他的一些函数不能使用。然而您想要测试的代码也许依赖他们，
那么让我们瞧瞧该如何解决这个问题。</p>
<p>这就是该那些辅助函数登场的时候了。然而应当说明的是，
这些函数并非仅仅为在交互式 Shell 里使用而编写的，也
可以用于单元测试或者其他需要一个虚假的请求上下文的
情景。</p>
<p>一般来说，在阅读本章节之前还是建议大家先阅读 <a class="reference internal" href="index.html#request-context"><em>请求上下文</em></a>
相关章节。</p>
<div class="section" id="id2">
<h4>创建一个请求上下文<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>从 Shell 创建一个合适的上下文，最简单的方法是使用
<a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-attr docutils literal"><span class="pre">test_request_context</span></tt></a> 方法，此方法
会创建一个 <a class="reference internal" href="index.html#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><tt class="xref py py-class docutils literal"><span class="pre">RequestContext</span></tt></a> 对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">()</span>
</pre></div>
</div>
<p>一般来说，您可以使用 <cite>with</cite> 声明来激活这个请求对象，
但是在终端中，调用 <a class="reference internal" href="index.html#flask.ctx.RequestContext.push" title="flask.ctx.RequestContext.push"><tt class="xref py py-meth docutils literal"><span class="pre">push()</span></tt></a>
方法和 <a class="reference internal" href="index.html#flask.ctx.RequestContext.pop" title="flask.ctx.RequestContext.pop"><tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt></a> 方法
会更简单:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
</pre></div>
</div>
<p>从这里往后，您就可以使用这个请求对象直到您调用 <cite>pop</cite>
方法为止:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>激发请求发送前后的调用<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>仅仅创建一个请求上下文，您仍然不能运行请求发送前通常会运行的代码。
如果您在将连接数据库的任务分配给发送请求前的函数调用，或者在当前
用户并没有被储存在 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 对象里等等情况下，您可能无法
访问到数据库。</p>
<p>您可以很容易的自己完成这件事，仅仅手动调用
<a class="reference internal" href="index.html#flask.Flask.preprocess_request" title="flask.Flask.preprocess_request"><tt class="xref py py-meth docutils literal"><span class="pre">preprocess_request()</span></tt></a> 函数即可:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span><span class="o">.</span><span class="n">preprocess_request</span><span class="p">()</span>
</pre></div>
</div>
<p>请注意， <a class="reference internal" href="index.html#flask.Flask.preprocess_request" title="flask.Flask.preprocess_request"><tt class="xref py py-meth docutils literal"><span class="pre">preprocess_request()</span></tt></a> 函数可能会返回
一个响应对象。这时，忽略它就好了。</p>
<p>要关闭一个请求，您需要在请求后的调用函数(由 <a class="reference internal" href="index.html#flask.Flask.process_response" title="flask.Flask.process_response"><tt class="xref py py-meth docutils literal"><span class="pre">process_response()</span></tt></a>
函数激发)运行之前耍一些小小的把戏:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">app</span><span class="o">.</span><span class="n">process_response</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">response_class</span><span class="p">())</span>
<span class="go">&lt;Response 0 bytes [200 OK]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>被注册为 <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> 的函数将会在
上下文环境出栈之后自动执行。所以这是用来销毁请求上下文(如数据库
连接等)资源的最佳地点。</p>
</div>
<div class="section" id="id4">
<h4>进一步提升 Shell 使用体验<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>如果您喜欢在 Shell 里实验您的新点子，您可以创建一个包含你想要导入交互式
回话中的东西的的模块。在这里，您也可以定义更多的辅助方法用来完成一些常用的
操作，例如初始化数据库、删除一个数据表等。</p>
<p>把他们放到一个模块里（比如 <cite>shelltools</cite> 然后在 Shell 中导入它）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shelltools</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/index"></span><div class="section" id="flask">
<span id="patterns"></span><h3>Flask 代码模式<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h3>
<p>某些东西非常通用，以至于你有很大的机会在绝大部分 Web 应用中，都能找到
他们的身影。例如相当多的应用在使用关系数据库而且包含用户注册和认证模块。
在这种情况下，请求开始之前，他们会打开数据库连接、获得当前已经登陆的用户
信息。在请求结束的时候，数据库连接又会被关闭。</p>
<p>这章提供了一些由用户贡献的代码片段和模板来加速开发 <a class="reference external" href="http://flask.pocoo.org/snippets/">Flask
Snippet Archives</a>.</p>
<div class="toctree-wrapper compound">
<span id="document-patterns/packages"></span><div class="section" id="larger-applications">
<span id="id1"></span><h4>大型应用<a class="headerlink" href="#larger-applications" title="永久链接至标题">¶</a></h4>
<p>对于比较大型的应用，更好的做法是使用包管理代码，而不是模块来管理代码。
这非常简单，设想一个如下结构的应用:</p>
<div class="highlight-python"><pre>/yourapplication
    /yourapplication.py
    /static
        /style.css
    /templates
        layout.html
        index.html
        login.html
        ...</pre>
</div>
<div class="section" id="id2">
<h5>简单的包<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>将一个项目改为一个更大的包，仅仅创建一个新的 <cite>yourapplication</cite> 文件夹在
已存的文件夹下面，然后将所有的的文件都移动到它下面。之后将 <cite>yourapplication.py</cite>
重命名为 <cite>__init__.py</cite> （确保先删除了其中所有的 <cite>.pyc</cite> 文件，否则可能导致
错误的结果）</p>
<p>您最后得到的东西应该像下面这样:</p>
<div class="highlight-python"><pre>/yourapplication
    /yourapplication
        /__init__.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...</pre>
</div>
<p>如何在此种方式下运行您的应用？原来的 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">yourapplication/__init__.py</span></tt>
不能再工作了。这是由于 Python 不希望在包中的模块成为初始运行的文件。但这
不是一个大问题，仅仅添加一个名叫 <cite>runserver.py</cite> 的新文件，把这个文件放在
<cite>yourapplication</cite> 文件夹里，并添加如下功能:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>
<span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>然后，我们又能对应用做什么呢？现在我们可以重新构造我们的应用，将其
改造为多个模块。你唯一需要记住的就是下面的速记备忘表:</p>
<ol class="arabic simple">
<li><cite>Flask</cite> 程序对象的创建必须在 <cite>__init__.py</cite> 文件里完成，
这样我们就可以安全的导入每个模块，而 <cite>__name__</cite> 变量将
会被分配给正确的包。</li>
<li>所有（上面有 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器的那些）视图函数必须
导入到 <cite>__init__.py</cite> 文件。此时，请通过模块而不是对象本身作为路径
导入这些视图函数。<strong>必须在应用对象创建之后</strong> 导入视图模块。</li>
</ol>
<p>这里是 <cite>__init__.py</cite> 的一个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">yourapplication.views</span>
</pre></div>
</div>
<p>而 <cite>views.py</cite> 应该看起来像这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World!&#39;</span>
</pre></div>
</div>
<p>您最终应该得到的程序结构应该是这样:</p>
<div class="highlight-python"><pre>/yourapplication
    /runserver.py
    /yourapplication
        /__init__.py
        /views.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...</pre>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">循环导入</p>
<p>每个 Python 程序员都会讨厌他们，而我们反而还添加了几个进去:
循环导入(在两个模块相互依赖对方的时候，就会发生循环导入)。在这里
<cite>views.py</cite> 依赖于 <cite>__init__.py</cite>。通常这被认为是个不好的主意，但是
在这里实际上不会造成问题。之所以如此，是因为我们实际上没有在
<cite>__init__.py</cite> 里使用这些视图，而仅仅是保证模块被导入了。并且，我们是
在文件的结尾这么做的。</p>
<p class="last">这种做法仍然有些问题，但是如果您想要使用修饰器，那么没有
其他更好的方法了。检查 <a class="reference internal" href="index.html#becomingbig"><em>聚沙成塔</em></a> 这一章来寻找解决
问题的些许灵感吧。</p>
</div>
</div>
<div class="section" id="working-with-modules">
<span id="id3"></span><h5>与蓝图一起工作<a class="headerlink" href="#working-with-modules" title="永久链接至标题">¶</a></h5>
<p>如果您有规模较大的应用，建议您将他们分拆成小的组，让每个组
接口于蓝图提供的辅助功能。关于这一主题进一步的介绍请参考
<a class="reference internal" href="index.html#blueprints"><em>用蓝图实现模块化的应用</em></a> 这一章节的文档</p>
</div>
</div>
<span id="document-patterns/appfactories"></span><div class="section" id="app-factories">
<span id="id1"></span><h4>应用程序的工厂函数<a class="headerlink" href="#app-factories" title="永久链接至标题">¶</a></h4>
<p>如果您已经开始使用包和蓝图(<a class="reference internal" href="index.html#blueprints"><em>用蓝图实现模块化的应用</em></a>)辅助您的应用开发了，那么
这里还有一些非常好的办法可以进一步的提升开发体验。当蓝图被导入的时候，
一个通用的模板将会负责创建应用程序对象。但是如果你将这个对象的创建工作
移交给一个函数来完成，那么你就可以在此后创建它的多个实例。</p>
<p>这么做的目的在于:</p>
<ol class="arabic simple">
<li>测试。你可以使用多个应用程序的实例，为每个实例分配分配不同的配置，
从而测试每一种不同的情况。</li>
<li>多个实例。想象以下情景：您需要同时运行同一个应用的不同版本，您当然可以
在你的Web服务器中配置多个实例并分配不同的配置，但是如果你使用工厂函数，
你就可以在一个随手即得的进程中运行这一个应用的不同实例了！</li>
</ol>
<p>那么该如何使用他们呢？</p>
<div class="section" id="id2">
<h5>基础的工厂函数<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>您可以像下面展示的这样，从一个函数里启动这个应用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_app</span><span class="p">(</span><span class="n">config_filename</span><span class="p">):</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="n">config_filename</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">yourapplication.views.admin</span> <span class="kn">import</span> <span class="n">admin</span>
    <span class="kn">from</span> <span class="nn">yourapplication.views.frontend</span> <span class="kn">import</span> <span class="n">frontend</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">admin</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">frontend</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">app</span>
</pre></div>
</div>
<p>有得必有失，在导入时，您无法在蓝图中使用这个应用程序对象。然而您可以在一个
请求中使用他。如果获取当前配置下的对应的应用程序对象呢？请使用:
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> 函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span><span class="p">,</span> <span class="n">Blueprint</span><span class="p">,</span> <span class="n">render_template</span>
<span class="n">admin</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">&#39;/admin&#39;</span><span class="p">)</span>

<span class="nd">@admin.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;INDEX_TEMPLATE&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>在这里我们从配置中查找一个网页模板文件的名字。</p>
</div>
<div class="section" id="id3">
<h5>使用应用程序<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>所以，要使用这样的一个应用，你必须先创建这个应用对象，这里是一个
运行此类程序的 <cite>run.py</cite> 文件的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">create_app</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="s">&#39;/path/to/config.cfg&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h5>工厂函数的改进<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>前文所提供的工厂函数并不是特别聪明好用，您可以改进它，如下的
改变可以是直接且可行的:</p>
<ol class="arabic simple">
<li>使得在单元测试中传入配置值成为可行，以使您不必在文件系统中
创建多个配置文件。</li>
<li>在程序初始时从蓝图中调用一个函数，这样您就有机会修改应用的参数属性了
(就像在在请求处理器前后的调用钩子等)</li>
<li>如果必要的话，在应用正在被创建时添加 WSGI 中间件。</li>
</ol>
</div>
</div>
<span id="document-patterns/appdispatch"></span><div class="section" id="app-dispatch">
<span id="id1"></span><h4>应用调度<a class="headerlink" href="#app-dispatch" title="永久链接至标题">¶</a></h4>
<p>应用调度指的是在 WSGI 层次合并运行多个 Flask 的应用的进程。您不能将
Flask 与更大的东西合并，但是可以和 WSGI 应用交叉。这甚至允许您将
Django 和 Flask 的应用运行在同一个解释器下。这么做的用处依赖于
这个应用内部是如何运行的。</p>
<p>与 <a class="reference internal" href="index.html#larger-applications"><em>模块方式</em></a> 的区别在于，此时您运行的不
同 Flask 应用是相互之间完全独立的，他们运行在不同的配置，而且在 WSGI
层调度。</p>
<div class="section" id="id2">
<h5>如何使用此文档<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>下面的所有技巧和例子都将最终得到一个 <tt class="docutils literal"><span class="pre">application</span></tt> 对象，这个对象
可以在任何 WSGI 服务器上运行。在生产环境下，请参看 <a class="reference internal" href="index.html#deployment"><em>部署选择</em></a>
相关章节。在开发时，Werkzeug 提供了一个提供了一个内置的开发服务器，
可以通过 <a class="reference external" href="http://werkzeug.pocoo.org/docs/serving/#werkzeug.serving.run_simple" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">werkzeug.serving.run_simple()</span></tt></a> 函数使用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.serving</span> <span class="kn">import</span> <span class="n">run_simple</span>
<span class="n">run_simple</span><span class="p">(</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">application</span><span class="p">,</span> <span class="n">use_reloader</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>注意，<a class="reference external" href="http://werkzeug.pocoo.org/docs/serving/#werkzeug.serving.run_simple" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">run_simple</span></tt></a> 函数不是为生产
用途设计的，发布应用时可以使用 <a class="reference internal" href="index.html#deployment"><em>成熟的 WSGI 服务器</em></a> 。</p>
<p>为了能使用交互式调试器，调试必须在应用和简易开发服务器两边都被激活。
下面是一个带有调试功能的 “Hello World” 的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">werkzeug.serving</span> <span class="kn">import</span> <span class="n">run_simple</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World!&#39;</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">run_simple</span><span class="p">(</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span>
               <span class="n">use_reloader</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">use_debugger</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">use_evalex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>合并应用<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>如果您有一些完全独立的应用程序，而您希望他们使用同一个 Python 解释器，
背靠背地运行，您可以利用 <a class="reference external" href="http://werkzeug.pocoo.org/docs/middlewares/#werkzeug.wsgi.DispatcherMiddleware" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">werkzeug.wsgi.DispatcherMiddleware</span></tt></a> 这个类。
这里，每个 Flask 应用对象都是一个有效的 WSGI 应用对象，而且他们在
调度中间层当中被合并进入一个规模更大的应用，并通过前缀来实现调度。</p>
<p>例如，您可以使您的主应用运行在 <cite>/</cite> 路径，而您的后台
接口运行在 <cite>/backend</cite> 路径:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.wsgi</span> <span class="kn">import</span> <span class="n">DispatcherMiddleware</span>
<span class="kn">from</span> <span class="nn">frontend_app</span> <span class="kn">import</span> <span class="n">application</span> <span class="k">as</span> <span class="n">frontend</span>
<span class="kn">from</span> <span class="nn">backend_app</span> <span class="kn">import</span> <span class="n">application</span> <span class="k">as</span> <span class="n">backend</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">DispatcherMiddleware</span><span class="p">(</span><span class="n">frontend</span><span class="p">,</span> <span class="p">{</span>
    <span class="s">&#39;/backend&#39;</span><span class="p">:</span>     <span class="n">backend</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h5>通过子域名调度<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>有时，您希望使用对一个应用使用不同的配置，对每个配置运行一个实例，从而有
多个实例存在。假设应用对象是在函数中生成的，您就可以调用这个函数并实例化
一个实例，这相当容易实现。为了使您的应用支持在函数中创建新的对象，请先参考
<a class="reference internal" href="index.html#app-factories"><em>应用程序的工厂函数</em></a> 模式。</p>
<p>一个相当通用的例子，那就是为不同的子域名创建不同的应用对象。比如
您将您的Web服务器设置为将所有的子域名都分发给您的引用，而您接下来
使用这些子域名信息创建一个针对特定用户的实例。一旦您使得您的服务器
侦听所有的子域名请求，那么您就可以使用一个非常简单的 WSGI 对象
来进行动态的应用程序构造。</p>
<p>实现此功能最佳的抽象层就是 WSGI 层。您可以编写您自己的 WSGI 程序来
检查访问请求，然后分发给您的 Flask 应用。如果您的应用尚未存在，那么
就创建一个并且保存下来:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="k">class</span> <span class="nc">SubdomainDispatcher</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">create_app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_app</span> <span class="o">=</span> <span class="n">create_app</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get_application</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">host</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">),</span> <span class="s">&#39;Configuration error&#39;</span>
        <span class="n">subdomain</span> <span class="o">=</span> <span class="n">host</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">subdomain</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_app</span><span class="p">(</span><span class="n">subdomain</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">subdomain</span><span class="p">]</span> <span class="o">=</span> <span class="n">app</span>
            <span class="k">return</span> <span class="n">app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_application</span><span class="p">(</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;HTTP_HOST&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>
</div>
<p>调度器可以这样使用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myapplication</span> <span class="kn">import</span> <span class="n">create_app</span><span class="p">,</span> <span class="n">get_user_for_subdomain</span>
<span class="kn">from</span> <span class="nn">werkzeug.exceptions</span> <span class="kn">import</span> <span class="n">NotFound</span>

<span class="k">def</span> <span class="nf">make_app</span><span class="p">(</span><span class="n">subdomain</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">get_user_for_subdomain</span><span class="p">(</span><span class="n">subdomain</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># if there is no user for that subdomain we still have</span>
        <span class="c"># to return a WSGI application that handles that request.</span>
        <span class="c"># We can then just return the NotFound() exception as</span>
        <span class="c"># application which will render a default 404 page.</span>
        <span class="c"># You might also redirect the user to the main page then</span>
        <span class="k">return</span> <span class="n">NotFound</span><span class="p">()</span>

    <span class="c"># otherwise create the application for the specific user</span>
    <span class="k">return</span> <span class="n">create_app</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">SubdomainDispatcher</span><span class="p">(</span><span class="s">&#39;example.com&#39;</span><span class="p">,</span> <span class="n">make_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>使用路径来调度<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>通过 URL 路径分发请求跟前面的方法很相似。只需要简单检查请求路径当中到第一个
斜杠之前的部分，而不是检查用来确定子域名的 <cite>HOST</cite> 头信息就可以了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">werkzeug.wsgi</span> <span class="kn">import</span> <span class="n">pop_path_info</span><span class="p">,</span> <span class="n">peek_path_info</span>

<span class="k">class</span> <span class="nc">PathDispatcher</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_app</span><span class="p">,</span> <span class="n">create_app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_app</span> <span class="o">=</span> <span class="n">default_app</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_app</span> <span class="o">=</span> <span class="n">create_app</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get_application</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_app</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">app</span>
            <span class="k">return</span> <span class="n">app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_application</span><span class="p">(</span><span class="n">peek_path_info</span><span class="p">(</span><span class="n">environ</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pop_path_info</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_app</span>
        <span class="k">return</span> <span class="n">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>
</div>
<p>这种例子与之前子域名调度那里的区别是，这里如果创建应用对象的函数返回了 <cite>None</cite>,
那么请求就被降级回推到另一个应用当中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myapplication</span> <span class="kn">import</span> <span class="n">create_app</span><span class="p">,</span> <span class="n">default_app</span><span class="p">,</span> <span class="n">get_user_for_prefix</span>

<span class="k">def</span> <span class="nf">make_app</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">get_user_for_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">create_app</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">PathDispatcher</span><span class="p">(</span><span class="n">default_app</span><span class="p">,</span> <span class="n">make_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/urlprocessors"></span><div class="section" id="url">
<h4>使用 URL 处理器<a class="headerlink" href="#url" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
<p>Flask 0.7 版引入了 URL 处理器的概念。此概念的意义在于，对于一部分资源，
您并不是很清楚该如何设定其 URL 相同的部分。例如可能有一些 URL 包含了几个字母
来指定的多国语言语种，但是你不想在每个函数里都手动识别到底是哪个语言。</p>
<p>搭配 Blueprint 使用时，URL 处理器尤其有用。这里我们将会就具体的应用例子介绍如何使用
URL 处理器和 Blueprint</p>
<div class="section" id="id1">
<h5>国际化的应用程序 URL<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>试想如下一个网页应用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">g</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;lang_code&gt;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">lang_code</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span> <span class="o">=</span> <span class="n">lang_code</span>
    <span class="o">...</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;lang_code&gt;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">(</span><span class="n">lang_code</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span> <span class="o">=</span> <span class="n">lang_code</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这可能会产生一大片重复的代码，因为你必须在每个函数当中手动处理 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 对象。
当然，你可以使用装饰器来简化它，但想要从一个函数动态生成 URL 到另一个函数，
仍需详细地提供这段多国语言代号码，这将非常地恼人。</p>
<p>对于后者，这就是 <a class="reference internal" href="index.html#flask.Flask.url_defaults" title="flask.Flask.url_defaults"><tt class="xref py py-func docutils literal"><span class="pre">url_defaults()</span></tt></a> 函数大展神威的地方了！
这些函数可以自动地将值注入到 <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> 的调用中去。下面的
代码检查多语言代号码是否在包含各个 URL 值的字典里，以及末端调用的函数是否接受
<tt class="docutils literal"><span class="pre">'lang_code'</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.url_defaults</span>
<span class="k">def</span> <span class="nf">add_language_code</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="s">&#39;lang_code&#39;</span> <span class="ow">in</span> <span class="n">values</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">url_map</span><span class="o">.</span><span class="n">is_endpoint_expecting</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="s">&#39;lang_code&#39;</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="s">&#39;lang_code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span>
</pre></div>
</div>
<p>URL 映射的函数 <a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Map.is_endpoint_expecting" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">is_endpoint_expecting()</span></tt></a> 可以被用来
识别是否可以给末端的函数提供一个多国语言代号码。</p>
<p>相反的函数是 <tt class="xref py py-meth docutils literal"><span class="pre">url_value_preprocessor()</span></tt> 。他们在请求成功
匹配并且能够执行针对 URL 值的代码时立即执行。实际上，他们将信息从包含这些值的
字典当中取出，然后将其放在某个其他的地方:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.url_value_preprocessor</span>
<span class="k">def</span> <span class="nf">pull_lang_code</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;lang_code&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>这样，您再也不必在每个函数中都要将 <cite>lang_code</cite> 分配给 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 了。
您可以进一步的改进它，通过编写您自己的装饰器，并使用这些装饰器为包含多国语言
代号码的 URL 添加前缀。但是使用蓝图相比起来会更优雅一些。一旦 <tt class="docutils literal"><span class="pre">'lang_code'</span></tt>
被从字典里弹出，他就不会在被传递到视图函数当中。这样，代码就可简化为如下形式:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">g</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.url_defaults</span>
<span class="k">def</span> <span class="nf">add_language_code</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="s">&#39;lang_code&#39;</span> <span class="ow">in</span> <span class="n">values</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">url_map</span><span class="o">.</span><span class="n">is_endpoint_expecting</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="s">&#39;lang_code&#39;</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="s">&#39;lang_code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span>

<span class="nd">@app.url_value_preprocessor</span>
<span class="k">def</span> <span class="nf">pull_lang_code</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;lang_code&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;lang_code&gt;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="o">...</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;lang_code&gt;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="blueprint-url">
<h5>多国语言化的 Blueprint URL<a class="headerlink" href="#blueprint-url" title="永久链接至标题">¶</a></h5>
<p>因为 Blueprint 能够自动地为所有 URL 添加一个相同的字符串作为前缀，所以自动处理这些函数变得非常简单。
每个蓝图都可以有一个 URL 处理器，即从 <a class="reference internal" href="index.html#flask.Flask.url_defaults" title="flask.Flask.url_defaults"><tt class="xref py py-meth docutils literal"><span class="pre">url_defaults()</span></tt></a> 函数中
移除一整套业务逻辑，因为它不再检查URL 是否真正与 <tt class="docutils literal"><span class="pre">'lang_code'</span></tt> 相关:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span><span class="p">,</span> <span class="n">g</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">&#39;frontend&#39;</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">&#39;/&lt;lang_code&gt;&#39;</span><span class="p">)</span>

<span class="nd">@bp.url_defaults</span>
<span class="k">def</span> <span class="nf">add_language_code</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">values</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;lang_code&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span><span class="p">)</span>

<span class="nd">@bp.url_value_preprocessor</span>
<span class="k">def</span> <span class="nf">pull_lang_code</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">lang_code</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;lang_code&#39;</span><span class="p">)</span>

<span class="nd">@bp.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="o">...</span>

<span class="nd">@bp.route</span><span class="p">(</span><span class="s">&#39;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/distribute"></span><div class="section" id="distribute-deployment">
<span id="id1"></span><h4>部署和分发<a class="headerlink" href="#distribute-deployment" title="永久链接至标题">¶</a></h4>
<p><a class="reference external" href="http://pypi.python.org/pypi/distribute">distribute</a> 的前身是 <tt class="docutils literal"><span class="pre">setuptools</span></tt> ，是一个通常用于分发
Python 库和扩展程序的外部库。它依赖于随 Python 预装的 <tt class="docutils literal"><span class="pre">distutils</span></tt> 库，
而后者则是一个基础的模块安装系统，这一安装系统也支持很多复杂的构造，使得
大型应用更易于分发。</p>
<ul class="simple">
<li><strong>支持依赖关系管理</strong>: 一个库可以声明自己依赖哪些软件包，从而在安装这个
模块的时候，自动将依赖的软件包也安装到您的计算机。</li>
<li><strong>注册软件包</strong>: setuptools 将您的包注册到您的安装的 Python 环境中。
这使得您可以使一个包中的代码查询另一个包所提供的信息。这一系统最知名的
特性就是对接口机制的支持，也就是说一个包可以声明自己的一个接口，从而允许
其他的包通过这个接口对自己进行扩展。</li>
<li><strong>安装包管理器</strong>: <cite>easy_install</cite> 默认随 Python 安装，它可以用于为您安装其他
的库。您也可以使用 <cite>pip</cite> 这个可能早晚会代替 <cite>easy_install</cite> 的包管理器，它能够
完成安装软件包之外更多的任务。</li>
</ul>
<p>而对于 Flask 自己，则所有您可以在 cheessshop 上找到的软件包，都随着 distribute
分发管理器，或者更古老的 setuptools 和 distutils 分发。</p>
<p>在这里，我们假定您的应用名为 <cite>yourapplication.py</cite> ，而您没使用模块而是使用
<a class="reference internal" href="index.html#larger-applications"><em>package</em></a> 的结构来组织代码。分发带有标准模块的
代码不被 <a class="reference external" href="http://pypi.python.org/pypi/distribute">distribute</a> 支持，所以我们不去管它。如果您还没有将您的应用转化为包的形式，
请参考前文 <a class="reference internal" href="index.html#larger-applications"><em>大型应用</em></a> 的内容查找如何做到这件事。</p>
<p>利用 distribute 完成一个有效的部署进行更复杂和更自动化的部署方案的第一步，
如果您使程序完全自动化，可以阅读 <a class="reference internal" href="index.html#fabric-deployment"><em>使用 Fabric 部署</em></a> 这一章。</p>
<div class="section" id="id2">
<h5>基础的安装脚本<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>因为你已经让 Flask 运行起来了，所以不管怎么说您的系统上应该会有 setuptools
或者d istribute，如果你没有这两样，不要害怕。这里帮你准备了一个脚本：
<tt class="docutils literal"><span class="pre">distribute_setup.py</span></tt> 你只需要下载并用 Python 解释器运行它。</p>
<p>考虑这些操作可能会有风险，因此建议您参考 <a class="reference internal" href="index.html#virtualenv"><em>你最好使用 virtualenv</em></a> 一文。</p>
<p>您的安装代码将总是保存在与您应用同目录下的 <cite>setup.py</cite> 文件中。为文件
指定这一名称只是为了方便，不过一般来说每一个人自然而然的在程序目录下
寻找这个文件，所以您最好别改变它。</p>
<p>同时，即使您在使用 <cite>distribute</cite> ，您也会导入一个名为 <cite>setuptools</cite> 的包。
<cite>distribute</cite> 完全向下兼容 <cite>setuptools</cite> ，所以我们也使用这个名字来导入它。</p>
<p>一个基本的 Flask 应用的 <cite>setup.py</cite> 文件看起来像如下这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;Your Application&#39;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s">&#39;1.0&#39;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="n">__doc__</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;yourapplication&#39;</span><span class="p">],</span>
    <span class="n">include_package_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">zip_safe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Flask&#39;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>切记，您必须详细地列出子代码包，如果您想要 distribute 自动为您寻找这些包，
您可以使用 <cite>find_packages</cite> 函数:</p>
<div class="highlight-python"><pre>from setuptools import setup, find_packages

setup(
    ...
    packages=find_packages()
)</pre>
</div>
<p>大多数 <cite>setup</cite> 函数当中的参数的意义从字面意思就能看出来，然而
<cite>include_package_data</cite> 和 <cite>zip_safe</cite> 可能不在此列。
<cite>include_package_data</cite> 告诉 distribute 自动查找一个 <cite>MANIFEST.in</cite> 文件。
解析此文件获得有效的包类型的数据，并安装所有这些包。我们使用这个特性来分发
Python 模块自带的静态文件和模板(参考 <a class="reference internal" href="index.html#distributing-resources"><em>分发代码</em></a>)。而 <cite>zip_safe</cite>
标志可以被用来强制阻止 ZIP 安装包的建立。通常情况下，您不希望您的包以 ZIP 压缩
包的形式被安装，因为一些工具不支持这种方式，而且这样也会让调试代码异常麻烦。</p>
</div>
<div class="section" id="distributing-resources">
<span id="id3"></span><h5>分发代码<a class="headerlink" href="#distributing-resources" title="永久链接至标题">¶</a></h5>
<p>如果您视图安装您刚刚创建的包，您会发现诸如 <cite>static</cite> 和 <cite>templates</cite> 这样的
文件夹没有安装进去。这是因为 distribute 不知道该把哪些文件添加进去。您只要
在 <cite>setup.py</cite> 相同的文件夹下创建一个 <cite>MANIFEST.in</cite> 文件，并在此文件中列出
所有应该被添加进去的文件:</p>
<div class="highlight-python"><pre>recursive-include yourapplication/templates *
recursive-include yourapplication/static *</pre>
</div>
<p>不要忘记，即使您已经将他们列在 <cite>MANIFEST.in</cite> 文件当中，也需要您将 <cite>setup</cite> 函数的
<cite>include_package_data</cite> 参数设置为 <cite>True</cite> ，否则他们仍然不会被安装。</p>
</div>
<div class="section" id="id4">
<h5>声明依赖关系<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>您需要使用一个链表在 <cite>install_requires</cite> 参数中声明依赖关系。链表的每个元素是
需要从 PyPI 下载并安装的包的名字，默认将总会下载安装最新的的版本。但是您也
可以指定需要的最大和最小的版本区间。以下是一个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
    <span class="s">&#39;Flask&gt;=0.2&#39;</span><span class="p">,</span>
    <span class="s">&#39;SQLAlchemy&gt;=0.6&#39;</span><span class="p">,</span>
    <span class="s">&#39;BrokenPackage&gt;=0.7,&lt;=1.0&#39;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>前文曾经指出，这些依赖都从 PyPI 当中下载，如果您需要依赖一个不能在 PyPI 当中
被下载的包，比如这个包是个内部的，您不想与别人分享。这时，您可以依然照原来
那样将包列在列表里，但是同时提供一个包括所有可选下载地址的列表，以便于安装时
从这些地点寻找分发的软件包:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dependency_links</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;http://example.com/yourfiles&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>请确认那个页面包含一个文件夹列表，且页面上的连接被指向实际需要下载的软件包。
distribute 通过扫描这个页面来寻找需要安装的文件，因此文件的名字必须是正确无误的。
如您有一个内部服务器包含有这些包，将 URL 指向这个服务器。</p>
</div>
<div class="section" id="id5">
<h5>安装 / 开发<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>安装您的应用(到一个 virtualenv)，只需使用 <cite>install</cite> 指令运行 <cite>setup.py</cite> 即可。
这会将您的应用安装到一个 virtualenv 的 site-packages 文件夹下面，并且同时
下载和安装所有的依赖包:</p>
<div class="highlight-python"><pre>$ python setup.py install</pre>
</div>
<p>如果您在进行基于这个包的开发，并且希望安装开发所依赖的工具或软件包，
您可以使用 <cite>develop</cite> 命令代替 <cite>install</cite></p>
<div class="highlight-python"><pre>$ python setup.py develop</pre>
</div>
<p>此时将不会把您的文件拷贝到 site-packages 文件夹，而仅仅是在那里创建指向
这些文件的文件链接。您可以继续编辑和修改这些代码，而无需在每次修改之后
运行 <cite>install</cite> 命令。</p>
</div>
</div>
<span id="document-patterns/fabric"></span><div class="section" id="fabric">
<span id="fabric-deployment"></span><h4>使用 Fabric 部署<a class="headerlink" href="#fabric" title="永久链接至标题">¶</a></h4>
<p><a class="reference external" href="http://fabfile.org/">Fabric</a> 是一个 Python 下类似于 Makefiles 的工具，但是能够在远程服务器上
执行命令。如果您有一个良好配置过的 Python 软件包 (<a class="reference internal" href="index.html#larger-applications"><em>大型应用</em></a>) 且
对“配置”概念的理解良好，那么在外部服务器上部署 Flask 应用将会非常容易。</p>
<p>开始之前，请先检查如下列表中的事项是否都已经满足了:</p>
<ul class="simple">
<li>在本地已经安装了 Fabric 1.0 。即这个教程完成时， Fabric 的最新版本。</li>
<li>应用程序已经被封装为包的形式，而且有一个有效的 <cite>setup.py</cite> 文件
(参考 <a class="reference internal" href="index.html#distribute-deployment"><em>部署和分发</em></a>)。</li>
<li>在下文中的例子里，我们使用 <cite>mod_wsgi</cite> 作为远程服务器使用的服务端程序。
您当然也可以使用您喜欢的服务端程序，但是考虑到 Apache 和 <cite>mod_wsgi</cite> 的
组合非常简单易用且容易安装配置，并且在无 root 权限的情况下，存在一个比较
简单的方法来重启服务器。</li>
</ul>
<div class="section" id="fabfile">
<h5>创建第一个 Fabfile<a class="headerlink" href="#fabfile" title="永久链接至标题">¶</a></h5>
<p>Fabfile 用于指定 Fabric 执行的命令，它通常被命名为 <cite>fabfile.py</cite> 并使用 <cite>fab</cite>
命令运行。文件中所有的函数将被当做 <cite>fab</cite> 的子命令显示出来，他们可以在一个或
多个主机上运行。这些主机要么在 fabfile 当中定义，要么在命令输入时指定。在本文中
我们将他们定义在 fabfile 里。</p>
<p>这是第一个基础的例子，能够将现有源代码上传到指定服务器并将它们安装进如
一个已经存在的虚拟环境中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># 远程服务器登陆使用的用户名</span>
<span class="n">env</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="s">&#39;appuser&#39;</span>
<span class="c"># 需要进行操作的服务器地址</span>
<span class="n">env</span><span class="o">.</span><span class="n">hosts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;server1.example.com&#39;</span><span class="p">,</span> <span class="s">&#39;server2.example.com&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">pack</span><span class="p">():</span>
    <span class="c"># 以 tar 归档的方式创建一个新的代码分发</span>
    <span class="n">local</span><span class="p">(</span><span class="s">&#39;python setup.py sdist --formats=gztar&#39;</span><span class="p">,</span> <span class="n">capture</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">deploy</span><span class="p">():</span>
    <span class="c"># 之处发布产品的名称和版本</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">local</span><span class="p">(</span><span class="s">&#39;python setup.py --fullname&#39;</span><span class="p">,</span> <span class="n">capture</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c"># 将代码归档上传到服务器当中的临时文件夹内</span>
    <span class="n">put</span><span class="p">(</span><span class="s">&#39;dist/</span><span class="si">%s</span><span class="s">.tar.gz&#39;</span> <span class="o">%</span> <span class="n">dist</span><span class="p">,</span> <span class="s">&#39;/tmp/yourapplication.tar.gz&#39;</span><span class="p">)</span>
    <span class="c"># 创建一个文件夹，进入这个文件夹，然后将我们的归档解压到那里</span>
    <span class="n">run</span><span class="p">(</span><span class="s">&#39;mkdir /tmp/yourapplication&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s">&#39;/tmp/yourapplication&#39;</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">&#39;tar xzf /tmp/yourapplication.tar.gz&#39;</span><span class="p">)</span>
        <span class="c"># 使用我们虚拟环境下的 Python 解释器安装我们的包</span>
        <span class="n">run</span><span class="p">(</span><span class="s">&#39;/var/www/yourapplication/env/bin/python setup.py install&#39;</span><span class="p">)</span>
    <span class="c"># 现在我们的代码已经部署成功了，可以删除这个文件夹了</span>
    <span class="n">run</span><span class="p">(</span><span class="s">&#39;rm -rf /tmp/yourapplication /tmp/yourapplication.tar.gz&#39;</span><span class="p">)</span>
    <span class="c"># 最终生成 .wsgi 文件，以便于 mod_wsgi 重新加载应用程序</span>
    <span class="n">run</span><span class="p">(</span><span class="s">&#39;touch /var/www/yourapplication.wsgi&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的代码例子注释很清晰，应该很容易明白，下面是 fabric 常用命令的一个归纳:</p>
<ul class="simple">
<li><cite>run</cite> - 在远程服务器上执行所有命令</li>
<li><cite>local</cite> - 在本地执行所有命令</li>
<li><cite>put</cite> - 将指定文件上传到指定服务器</li>
<li><cite>cd</cite> - 改变远程服务器当上的当前操作目录，此命令必须与 <cite>with</cite> 声明一起使用</li>
</ul>
</div>
<div class="section" id="id1">
<h5>运行 Fabfile<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>如何执行 fabfile 呢？您应该使用 <cite>fab</cite> 命令。若要发布当前版本的代码到远程
服务器上，您只需执行如下命令:</p>
<div class="highlight-python"><pre>$ fab pack deploy</pre>
</div>
<p>然而这需要您的服务器已经创建过 <tt class="docutils literal"><span class="pre">/var/www/yourapplication</span></tt> 文件夹
而且 <tt class="docutils literal"><span class="pre">/var/www/yourapplication/env</span></tt> 是一个可用的虚拟环境。而且，
我们还没有在服务器上创建配置文件或者 <cite>.wsgi</cite> 文件。因此，我们怎么样
把一个新的服务器转换为可以使用基础设备呢。</p>
<p>这视我们想要配置的服务器数量的不同，实现起来有所差别。如果我们只有一个
远程应用服务器(大部分应用都是都属于此类)，那么 fabfile 里添加一个专门
负责此类的命令有些小题大做。但是显然我们可以这么做。在这里，您可以会
运行命令 <cite>setup</cite> 或者 <cite>bootstrap</cite> 。然后将服务器的地址详细地在命令行
当中指定:</p>
<div class="highlight-python"><pre>$ fab -H newserver.example.com bootstrap</pre>
</div>
<p>初始化一个新的服务器，您大概需要执行如下几个步骤:</p>
<ol class="arabic">
<li><p class="first">在 <tt class="docutils literal"><span class="pre">/var/www</span></tt> 目录下创建目录结构:</p>
<div class="highlight-python"><pre>$ mkdir /var/www/yourapplication
$ cd /var/www/yourapplication
$ virtualenv --distribute env</pre>
</div>
</li>
<li><p class="first">上传一个新的 <cite>application.wsgi</cite> 文件以及为应用程序准备的配置
文件(例如: <cite>application.cfg</cite>)等到服务器上</p>
</li>
<li><p class="first">为 <cite>yourapplication</cite> 创建一个新的 Apache 配置，并激活它。请确保
激活了对 <cite>.wsgi</cite> 改变的监视功能，这样在我们创建或改变这个文件时
Apache 可以自动重新加载应用 (详细内容请参考 <a class="reference internal" href="index.html#mod-wsgi-deployment"><em>mod_wsgi (Apache)</em></a>)</p>
</li>
</ol>
<p>现在的问题是， <cite>application.wsgi</cite> 和 <cite>application.cfg</cite> 文件
从何而来。</p>
</div>
<div class="section" id="wsgi">
<h5>WSGI 文件<a class="headerlink" href="#wsgi" title="永久链接至标题">¶</a></h5>
<p>WSGI 文件应导入这个应用并且设定一个环境变量，这个环境变量指定了应用程序应
到哪里寻找配置文件。下面是一个完全完成上述功能的短例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;YOURAPPLICATION_CONFIG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;/var/www/yourapplication/application.cfg&#39;</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>
</pre></div>
</div>
<p>应用程序本身则应该向下面这样，通过查询环境变量来查找配置，以此初始化自己:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;yourapplication.default_config&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_envvar</span><span class="p">(</span><span class="s">&#39;YOURAPPLICATION_CONFIG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方法在本文档的 <a class="reference internal" href="index.html#config"><em>配置处理</em></a> 这节中进行了详细介绍。</p>
</div>
<div class="section" id="id2">
<h5>配置文件<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>正如上文所属，应用程序将会通过查找 <cite>YOURAPPLICATION_CONFIG</cite> 环境变量以
找到正确的配置文件。因此我们必须将配置文件放在应用程序可以找到的地方。
配置文件有在不同电脑上表现出不同效果的特质，所以您不应该以普通的方式
对它进行版本控制。</p>
<p>一个流行的做法是将不同服务器的配置文件保存在不同的版本控制仓库里，然后
在不同的服务器中分别抽取出来。然后建立到从配置应该在的地点
(如: <tt class="docutils literal"><span class="pre">/var/www/yourapplication</span></tt>)到这个文件实际位置的符号链接。</p>
<p>我们预计只有一个或两个服务器需要部署，因此我们采用另一种方法，也就是
提前手动将配置文件上传到需要的未知。</p>
</div>
<div class="section" id="id3">
<h5>第一次部署<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>现在我们可以开始进行第一次部署了。我们已经初始化了服务器以使它拥有正确的
虚拟环境和已经激活的 Apache 配置文件。现在我们可以把应用打包然后部署了:</p>
<div class="highlight-python"><pre>$ fab pack deploy</pre>
</div>
<p>Fabric 现在就会连接到所有服务器，然后运行在 fabfile 文件中所指定的命令。
最初他会执行打包工作，为我们创建代码归档，然后他部署和上传代码到所有的
服务器，并在那里安装他们。归功于 <cite>setup.py</cite> ，所有引用依赖的包和库都将
自动被下载和安装到我们的虚拟环境中。</p>
</div>
<div class="section" id="id4">
<h5>下一步操作<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>从现在开始，我们可以做的事情变得如此之多，以至于部署代码实际上可以
看做一种乐趣:</p>
<ul class="simple">
<li>创建一个 <cite>bootstrap</cite> 命令用于初始化新的服务器，它将初始化一个新的虚拟环境
安装以及适当配置 Apache 等。</li>
<li>将配置文件放置到一个独立的版本控制仓库里，然后将活动的配置符号连接到
它应该在的地方。</li>
<li>您应该将您的应用程序也放置到一个版本控制仓库中，然后在服务器中提取
最新的版本并安装，您也可以很容易的回溯到以前的版本。</li>
<li>为测试提供函数接口，这样您就可以将测试代码部署到服务器上并在服务器端
执行测试套件。</li>
</ul>
<p>使用 Fabric 是相当有趣，键入 <tt class="docutils literal"><span class="pre">fab</span> <span class="pre">deploy</span></tt> 并看到您的应用自动
部署到一个或多个服务器上，您会有“简直像是魔术”这样的感觉。</p>
</div>
</div>
<span id="document-patterns/sqlite3"></span><div class="section" id="flask-sqlite-3">
<span id="sqlite3"></span><h4>在 Flask 中使用 SQLite 3<a class="headerlink" href="#flask-sqlite-3" title="永久链接至标题">¶</a></h4>
<p>在 Flask 中，在请求开始的时候用 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> 装饰器实现
打开数据库连接的代码，然后在请求结束的时候用 <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a>
装饰器关闭数据库连接。在这个过程中需要配合 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> 对象。</p>
<p>于是，在 Flask 里一个使用 SQLite 3 的简单例子就是下面这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span>

<span class="n">DATABASE</span> <span class="o">=</span> <span class="s">&#39;/path/to/database.db&#39;</span>

<span class="k">def</span> <span class="nf">connect_db</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">DATABASE</span><span class="p">)</span>

<span class="nd">@app.before_request</span>
<span class="k">def</span> <span class="nf">before_request</span><span class="p">():</span>
    <span class="n">g</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">connect_db</span><span class="p">()</span>

<span class="nd">@app.teardown_request</span>
<span class="k">def</span> <span class="nf">teardown_request</span><span class="p">(</span><span class="n">exception</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;db&#39;</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">请记住，teardown request 在请求结束时总会运行，即使 before-request 处理器
运行失败或者从未运行过。我们需要确保数据库连接在关闭的时候在那里。</p>
</div>
<div class="section" id="id1">
<h5>按需连接<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>上述方法的缺陷在于，它只能用于 Flask 会执行 before-request 处理器的场合下
有效，如果您想要在一个脚本或者 Python 的交互式终端中访问数据库。那么您必须
做一些类似下面的代码的事情:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">():</span>
    <span class="n">app</span><span class="o">.</span><span class="n">preprocess_request</span><span class="p">()</span>
    <span class="c"># now you can use the g.db object</span>
</pre></div>
</div>
<p>为了激发连接代码的执行，使用这种方式的话，您将不能离开对请求上下文的依赖。
但是您使用以下方法可以使应用程序在必要时才连接:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_connection</span><span class="p">():</span>
    <span class="n">db</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;_db&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">db</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">db</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_db</span> <span class="o">=</span> <span class="n">connect_db</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">db</span>
</pre></div>
</div>
<p>缺点就是，您必须使用 <tt class="docutils literal"><span class="pre">db</span> <span class="pre">=</span> <span class="pre">get_connection()</span></tt> 而不是仅仅直接使用 <tt class="docutils literal"><span class="pre">g.db</span></tt>
来访问数据库连接。</p>
</div>
<div class="section" id="easy-querying">
<span id="id2"></span><h5>简化查询<a class="headerlink" href="#easy-querying" title="永久链接至标题">¶</a></h5>
<p>现在在每个请求处理函数里，您都可以访问 <cite>g.db</cite> 来获得当前打开的数据库连接。
此时，用一个辅助函数简化 SQLite 的使用是相当有用的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">query_db</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">one</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">((</span><span class="n">cur</span><span class="o">.</span><span class="n">description</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">rv</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">one</span> <span class="k">else</span> <span class="n">rv</span>
</pre></div>
</div>
<p>相比起直接使用原始的数据指针和连接对象。这个随手即得的小函数让操作数据库的操作更为轻松。
像下面这样使用它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">query_db</span><span class="p">(</span><span class="s">&#39;select * from users&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">user</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">],</span> <span class="s">&#39;has the id&#39;</span><span class="p">,</span> <span class="n">user</span><span class="p">[</span><span class="s">&#39;user_id&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>如果您只希望得到一个单独的结果:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">query_db</span><span class="p">(</span><span class="s">&#39;select * from users where username = ?&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="n">the_username</span><span class="p">],</span> <span class="n">one</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;No such user&#39;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">the_username</span><span class="p">,</span> <span class="s">&#39;has the id&#39;</span><span class="p">,</span> <span class="n">user</span><span class="p">[</span><span class="s">&#39;user_id&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>将变量传入 SQL 语句时，使用在语句之前使用一个问号，然后将参数以链表的形式穿进去。
永远不要直接将他们添加到 SQL 语句中以字符串形式传入，这样做将会允许恶意用户
以 <a class="reference external" href="http://en.wikipedia.org/wiki/SQL_injection">SQL 注入</a> 的方式攻击您的应用。</p>
</div>
<div class="section" id="id3">
<h5>初始化数据库模型<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>关系数据库需要一个模型来定义储存数据的模式，所以应用程序通常携带一个
<cite>schema.sql</cite> 文件用于创建数据库。提供一个特定的函数来创建数据库是个
不错的主意，以下的函数就能为您做到这件事:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>

<span class="k">def</span> <span class="nf">init_db</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">connect_db</span><span class="p">())</span> <span class="k">as</span> <span class="n">db</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;schema.sql&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p>然后您就可以在 Python 的交互式终端中创建一个这样的数据库:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">init_db</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">init_db</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/sqlalchemy"></span><div class="section" id="flask-sqlalchemy">
<span id="sqlalchemy-pattern"></span><h4>在 Flask 中使用 SQLAlchemy<a class="headerlink" href="#flask-sqlalchemy" title="永久链接至标题">¶</a></h4>
<p>很多人更倾向于使用 <a class="reference external" href="http://www.sqlalchemy.org/">SQLAlchemy</a> 进行数据库操作。在这种情况下，建议您使用
包的而不是模块的方式组织您的应用代码，并将所有的模型放置到一个单独的模块中
(<a class="reference internal" href="index.html#larger-applications"><em>大型应用</em></a>)。尽管这并非必要，但是这么做将会让程序的结构更加
明晰。</p>
<p>使用 SQLAlchemy 有四种常用的方法，我们在下面列出了这几种方法的基本使用
框架:</p>
<div class="section" id="id1">
<h5>Flask-SQLAlchemy 扩展<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>因为 SQLAlchemy 是一个常用的数据库抽象层和数据库关系映射包(ORM)，并且需要
一点点设置才可以使用，因此存在一个 Flask 扩展帮助您操作它。如果您想要快速
开始使用，那么我们建议您使用这种方法。</p>
<p>您可以从 <a class="reference external" href="http://pypi.python.org/pypi/Flask-SQLAlchemy">PyPI</a>
下载到 <a class="reference external" href="http://packages.python.org/Flask-SQLAlchemy/">Flask-SQLAlchemy</a></p>
</div>
<div class="section" id="id3">
<h5>显式调用<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>SQLAlchemy 中的 declarative 扩展是最新的使用 SQLAlchemy 的方法。它允许您
同时定义表和模型，就像 Django 一样工作。除了下文所介绍的内容外，我们建议您
参考 <a class="reference external" href="http://www.sqlalchemy.org/docs/orm/extensions/declarative.html">declarative</a> 扩展的官方文档。</p>
<p>这是一个 <cite>database.py</cite> 模块的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">scoped_session</span><span class="p">,</span> <span class="n">sessionmaker</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite:////tmp/test.db&#39;</span><span class="p">,</span> <span class="n">convert_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">db_session</span> <span class="o">=</span> <span class="n">scoped_session</span><span class="p">(</span><span class="n">sessionmaker</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">autoflush</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">))</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>
<span class="n">Base</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">db_session</span><span class="o">.</span><span class="n">query_property</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">init_db</span><span class="p">():</span>
    <span class="c"># 在这里导入所有的可能与定义模型有关的模块，这样他们才会合适地</span>
    <span class="c"># 在 metadata 中注册。否则，您将不得不在第一次执行 init_db() 时</span>
    <span class="c"># 先导入他们。</span>
    <span class="kn">import</span> <span class="nn">yourapplication.models</span>
    <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<p>为了定义您的模型，仅仅构造一个上面代码编写的 <cite>Base</cite> 类的子类。如果您好奇
为何我们在这里不用担心多线程的问题(就像我们在先前使用 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a>
对象操作 SQLite3 的例子一样):那是因为 SQLAlchemy 已经在
<tt class="xref py py-class docutils literal"><span class="pre">scoped_session</span></tt> 类当中为我们完成了这些任务。</p>
<p>在您的应用当中以一个显式调用 SQLAlchemy , 您只需要将如下代码放置在您应用
的模块中。Flask 将会在请求结束时自动移除数据库会话:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">db_session</span>

<span class="nd">@app.teardown_request</span>
<span class="k">def</span> <span class="nf">shutdown_session</span><span class="p">(</span><span class="n">exception</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">db_session</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
<p>这是一个模型的例子(将代码放入 <cite>models.py</cite> 或类似文件中):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">Base</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s">&#39;users&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;User </span><span class="si">%r</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>您可以使用 <cite>init_db</cite> 函数创建一个数据库:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">init_db</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">init_db</span><span class="p">()</span>
</pre></div>
</div>
<p>按照如下方式将数据实体插入数据库:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">db_session</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yourapplication.models</span> <span class="kn">import</span> <span class="n">User</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;admin@localhost&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db_session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db_session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p>查询代码也很简单:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">[&lt;User u&#39;admin&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;admin&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">&lt;User u&#39;admin&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="orm">
<h5>手动实现 ORM<a class="headerlink" href="#orm" title="永久链接至标题">¶</a></h5>
<p>手动实现 ORM (对象关系映射) 相比前面的显式调用方法，既有一些优点，也有一些缺点。
主要差别在于这里的数据表和模型是分开定义的，然后再将其映射起来。这提供了更大的灵活性，
但是会增加了代码量。通常来说它和上面显式调用的工作的方式很相似，所以请确保您的应用已经
被合理分割到了包中的不同模块中。</p>
<p>这是一个 <cite>database.py</cite> 模块的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">scoped_session</span><span class="p">,</span> <span class="n">sessionmaker</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite:////tmp/test.db&#39;</span><span class="p">,</span> <span class="n">convert_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">db_session</span> <span class="o">=</span> <span class="n">scoped_session</span><span class="p">(</span><span class="n">sessionmaker</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">autoflush</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">init_db</span><span class="p">():</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<p>与显式调用相同，您需要在请求结束后关闭数据库会话。将下面的代码
放到您的应用程序模块中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">db_session</span>

<span class="nd">@app.teardown_request</span>
<span class="k">def</span> <span class="nf">shutdown_session</span><span class="p">(</span><span class="n">exception</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">db_session</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
<p>下面是一个数据表和模型的例子(将他们放到 <cite>models.py</cite> 当中):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapper</span>
<span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">db_session</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">db_session</span><span class="o">.</span><span class="n">query_property</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;User </span><span class="si">%r</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s">&#39;email&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">mapper</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">users</span><span class="p">)</span>
</pre></div>
</div>
<p>查询和插入操作和上面所给出的例子是一样的。</p>
</div>
<div class="section" id="sql">
<h5>SQL 抽象层<a class="headerlink" href="#sql" title="永久链接至标题">¶</a></h5>
<p>如果您仅用到数据库系统和 SQL 抽象层，那么您只需要引擎部分:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite:////tmp/test.db&#39;</span><span class="p">,</span> <span class="n">convert_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
</pre></div>
</div>
<p>然后您就可以像上文的例子一样声明数据表，或者像下面这样自动加载他们:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">autoload</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>您可以使用 <cite>insert</cite> 方法插入数据，我们需要先获取一个数据库连接，这样
我们就可以使用“事务”了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="s">&#39;admin@localhost&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQLAlchemy 将会为我们自动提交对数据库的修改。</p>
<p>查询数据可以直接通过数据库引擎，也可以使用一个数据库连接:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">(1, u&#39;admin&#39;, u&#39;admin@localhost&#39;)</span>
</pre></div>
</div>
<p>返回的结果也是字典样式的元组:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
<span class="go">u&#39;admin&#39;</span>
</pre></div>
</div>
<p>您也可以将 SQL 语句的字符串传入到
<tt class="xref py py-meth docutils literal"><span class="pre">execute()</span></tt> 函数中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&#39;select * from users where id = :1&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">(1, u&#39;admin&#39;, u&#39;admin@localhost&#39;)</span>
</pre></div>
</div>
<p>更多 SQLAlchemy 相关信息，请参考 <a class="reference external" href="http://sqlalchemy.org/">其网站</a>.</p>
</div>
</div>
<span id="document-patterns/fileuploads"></span><div class="section" id="uploading-files">
<span id="id1"></span><h4>上传文件<a class="headerlink" href="#uploading-files" title="永久链接至标题">¶</a></h4>
<p>哦，上传文件可是个经典的好问题了。文件上传的基本概念实际上非常简单，
他基本是这样工作的:</p>
<ol class="arabic simple">
<li>一个 <tt class="docutils literal"><span class="pre">&lt;form&gt;</span></tt> 标签被标记有 <tt class="docutils literal"><span class="pre">enctype=multipart/form-data</span></tt> ，并且
在里面包含一个 <tt class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=file&gt;</span></tt> 标签。</li>
<li>服务端应用通过请求对象上的 <tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt> 字典访问文件。</li>
<li>使用文件的 <a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.save" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法将文件永久地
保存在文件系统上的某处。</li>
</ol>
<div class="section" id="id2">
<h5>一点点介绍<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>让我们建立一个非常基础的小应用，这个小应用可以上传文件到一个指定的文件夹里，
然后将这个文件显示给用户。让我们看看这个应用的基础代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>
<span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">secure_filename</span>

<span class="n">UPLOAD_FOLDER</span> <span class="o">=</span> <span class="s">&#39;/path/to/the/uploads&#39;</span>
<span class="n">ALLOWED_EXTENSIONS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;txt&#39;</span><span class="p">,</span> <span class="s">&#39;pdf&#39;</span><span class="p">,</span> <span class="s">&#39;png&#39;</span><span class="p">,</span> <span class="s">&#39;jpg&#39;</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="s">&#39;gif&#39;</span><span class="p">])</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;UPLOAD_FOLDER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UPLOAD_FOLDER</span>
</pre></div>
</div>
<p>首先我们导入一些东西，大多数内容都是直接而容易的。<tt class="xref py py-func docutils literal"><span class="pre">werkzeug.secure_filename()</span></tt>
将会在稍后进行解释。 <cite>UPLOAD_FOLDER</cite> 是我们储存上传的文件的地方，而 <cite>ALLOWED_EXTENSIONS</cite>
则是允许的文件类型的集合。然后我们手动为应用添加一个的 URL 规则。我们
通常很少这样做，但是为什么这里要如此呢？原因是我们希望实际部署的服务器
(或者我们的开发服务器）来为我们提供这些文件的访问服务，所以我们只需要
一个规则用来生成指向这些文件的 URL 。</p>
<p>为什么我们限制上传文件的后缀呢？您可能不希望您的用户能够上传任何文件
到服务器上，如果服务器直接将数据发送给客户端。以这种方式，您可以确保
您的用户不能上传可能导致 XSS 问题(参考 <a class="reference internal" href="index.html#xss"><em>跨站脚本攻击（XSS）</em></a> )的 HTML 文件。也
确保会阻止 <cite>.php</cite> 文件以防其会被运行。当然，谁还会在服务器上安装
PHP 啊，是不是？ :)</p>
<p>下一步，就是检查文件类型是否有效、上传通过检查的文件、以及将用户重定向到
已经上传好的文件 URL 处的函数了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">allowed_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">and</span> \
           <span class="n">filename</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">ALLOWED_EXTENSIONS</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;file&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">file</span> <span class="ow">and</span> <span class="n">allowed_file</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">secure_filename</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="nb">file</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;UPLOAD_FOLDER&#39;</span><span class="p">],</span> <span class="n">filename</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;uploaded_file&#39;</span><span class="p">,</span>
                                    <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">return</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">    &lt;!doctype html&gt;</span>
<span class="s">    &lt;title&gt;Upload new File&lt;/title&gt;</span>
<span class="s">    &lt;h1&gt;Upload new File&lt;/h1&gt;</span>
<span class="s">    &lt;form action=&quot;&quot; method=post enctype=multipart/form-data&gt;</span>
<span class="s">      &lt;p&gt;&lt;input type=file name=file&gt;</span>
<span class="s">         &lt;input type=submit value=Upload&gt;</span>
<span class="s">    &lt;/form&gt;</span>
<span class="s">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<p>那么 <a class="reference external" href="http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">secure_filename()</span></tt></a> 函数具体做了那些事呢？现在的问题
是，有一个信条叫做“永远别相信你用户的输入” ，这句话对于上传文件的文件名也是同样
有效的。所有提交的表单数据都可以伪造，而文件名本身也可能是危险的。在摄氏只需记住:
在将文件保存在文件系统之前，要坚持使用这个函数来确保文件名是安全的。</p>
<div class="admonition- admonition">
<p class="first admonition-title">关于文件名安全的更多信息</p>
<p>您对 <a class="reference external" href="http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">secure_filename()</span></tt></a> 的具体工作和您没使用它会造成的后果
感兴趣？试想一个人可以发送下列信息作为 <cite>filename</cite> 给您的应用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;../../../../home/username/.bashrc&quot;</span>
</pre></div>
</div>
<p>假定 <tt class="docutils literal"><span class="pre">../</span></tt> 的数量是正确的，而您会将这串字符与 <cite>UPLOAD_FOLDER</cite> 所指定的
路径相连接，那么这个用户就可能有能力修改服务器文件系统上的一个文件，而他
不应该拥有这种权限。这么做需要一些关于此应用情况的技术知识，但是相信我，
骇客们都有足够的耐心 :)</p>
<p>现在我们来研究一下这个函数的功能:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">secure_filename</span><span class="p">(</span><span class="s">&#39;../../../../home/username/.bashrc&#39;</span><span class="p">)</span>
<span class="go">&#39;home_username_.bashrc&#39;</span>
</pre></div>
</div>
</div>
<p>现在还有最后一件事没有完成: 提供对已上传文件的访问服务。 在 Flask 0.5
以上的版本我们可以使用一个函数来实现此功能:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">send_from_directory</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/uploads/&lt;filename&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">uploaded_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">send_from_directory</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;UPLOAD_FOLDER&#39;</span><span class="p">],</span>
                               <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>或者，您也可以选择为 <cite>uploaded_file</cite> 注册 <cite>build_only</cite> 规则，然后使用
<a class="reference external" href="http://werkzeug.pocoo.org/docs/middlewares/#werkzeug.wsgi.SharedDataMiddleware" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">SharedDataMiddleware</span></tt></a> 类来实现下载服务。这种方法
同时支持更老版本的 Flask:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">SharedDataMiddleware</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/uploads/&lt;filename&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;uploaded_file&#39;</span><span class="p">,</span>
                 <span class="n">build_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">SharedDataMiddleware</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">,</span> <span class="p">{</span>
    <span class="s">&#39;/uploads&#39;</span><span class="p">:</span>  <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;UPLOAD_FOLDER&#39;</span><span class="p">]</span>
<span class="p">})</span>
</pre></div>
</div>
<p>运行应用，不出意外的话，一切都应该像预期那样工作了。</p>
</div>
<div class="section" id="id3">
<h5>改进上传功能<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
<p>Flask 到底是如何处理上传的呢？如果服务器相对较小，那么他会先将文件储存在
网页服务器的内存当中。否则就将其写入一个临时未知(如函数 <a class="reference external" href="http://docs.python.org/dev/library/tempfile.html#tempfile.gettempdir" title="(在 Python v3.5)"><tt class="xref py py-func docutils literal"><span class="pre">tempfile.gettempdir()</span></tt></a>
返回的路径)。但是怎么指定一个文件大小的上限，当文件大于此限制，就放弃
上传呢? 默认 Flask 会很欢乐地使用无限制的空间，但是您可以通过在配置中设定
<tt class="docutils literal"><span class="pre">MAX_CONTENT_LENGTH</span></tt> 键的值来限制它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">Request</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;MAX_CONTENT_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
</pre></div>
</div>
<p>上面的代码将会把上传文件限制为最大 16 MB 。 如果请求传输一个更大的文件，
Flask 会抛出一个 <a class="reference external" href="http://werkzeug.pocoo.org/docs/exceptions/#werkzeug.exceptions.RequestEntityTooLarge" title="(在 Werkzeug v0.10)"><tt class="xref py py-exc docutils literal"><span class="pre">RequestEntityTooLarge</span></tt></a> 异常。</p>
<p>这个特性是在 Flask 0.6 中被加入的，但是更老的版本也可以通过构建请求对象
的子类来实现。更多信息请查询 Werkzeug 文档中文件处理部分的内容。</p>
</div>
<div class="section" id="id4">
<h5>上传进度条<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>以前，很多开发者实现进度条的方法是这样的: 一边小块小块地读取传输来的文件，
一边将上传进度储存在数据库中，然后在通过客户端的 JavaScript 代码读取进度。
简单来说，客户端会每5秒钟询问服务器传输的进度。您感觉到这种讽刺了么？客户端
询问一些他本应该已经知道的事情。</p>
<p>现在有了一些性能更好、运行更可靠的解决方案。WEB 已经有了不少变化，现在您可以
使用 HTML5、Java、Silverlight 或者 Flash 来实现客户端更好的上传体验。看一看
下面列出的库的连接，可以找到一些很好的样例。</p>
<ul class="simple">
<li><a class="reference external" href="http://www.plupload.com/">Plupload</a> - HTML5, Java, Flash</li>
<li><a class="reference external" href="http://www.swfupload.org/">SWFUpload</a> - Flash</li>
<li><a class="reference external" href="http://jumploader.com/">JumpLoader</a> - Java</li>
</ul>
</div>
<div class="section" id="id5">
<h5>更简单解决方案<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>因为存在一个处理上传文件的范式，这个范式在大多数应用中机会不会有太大改变，
所以 Flask 存在一个扩展名为 <a class="reference external" href="http://packages.python.org/Flask-Uploads/">Flask-Uploads</a> ，这个扩展实现了一整套成熟的
文件上传架构。它提供了包括文件类型白名单、黑名单等多种功能。</p>
</div>
</div>
<span id="document-patterns/caching"></span><div class="section" id="caching-pattern">
<span id="id1"></span><h4>缓存<a class="headerlink" href="#caching-pattern" title="永久链接至标题">¶</a></h4>
<p>如果您的应用运行很慢，那就尝试引入一些缓存吧。好吧，至少这是提高表现
最简单的方法。缓存的工作是什么呢？比如说您有一个需要一段时间才能完成
的函数，但是这个函数的返回结果可能在5分钟之内都是足够有效的，因此您可以
将这个结果放到缓存中一段时间，而不用反复计算。</p>
<p>Flask 本身并不提供缓存功能，但是作为Flask 基础的 Werkzeug 库，则提供了一些
基础的缓存支持。Werkzeug 支持多种缓存后端，通常的选择是 Memcached 服务器。</p>
<div class="section" id="id2">
<h5>配置缓存<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>类似于建立 <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 的对象一样，您创建一个缓存对象，然后让他
保持存在。如果您使用的是开发服务器，您可以创建一个 <a class="reference external" href="http://werkzeug.pocoo.org/docs/contrib/cache/#werkzeug.contrib.cache.SimpleCache" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">SimpleCache</span></tt></a>
对象，这个对象将元素缓存在 Python 解释器的控制的内存中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.contrib.cache</span> <span class="kn">import</span> <span class="n">SimpleCache</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">SimpleCache</span><span class="p">()</span>
</pre></div>
</div>
<p>如果您希望使用 Memcached 进行缓存，请确保您已经安装了 Memcache 模块支持
(您可以通过 <cite>PyPi&lt;http://pypi.python.org/</cite> 获取)，并且有一个可用的 Memcached
服务器正在运行。然后您可以像下面这样连接到缓存服务器:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.contrib.cache</span> <span class="kn">import</span> <span class="n">MemcachedCache</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">MemcachedCache</span><span class="p">([</span><span class="s">&#39;127.0.0.1:11211&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>如果您在使用 App Engine ，您可以轻易地通过下面的代码连接到 App Engine 的
缓存服务器:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.contrib.cache</span> <span class="kn">import</span> <span class="n">GAEMemcachedCache</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">GAEMemcachedCache</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>使用缓存<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>有两个非常重要的函数可以用来使用缓存。那就是 <a class="reference external" href="http://werkzeug.pocoo.org/docs/contrib/cache/#werkzeug.contrib.cache.BaseCache.get" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>
函数和 <a class="reference external" href="http://werkzeug.pocoo.org/docs/contrib/cache/#werkzeug.contrib.cache.BaseCache.set" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> 函数。他们的使用方法
如下:</p>
<p>从缓存中读取项目，请使用 <a class="reference external" href="http://werkzeug.pocoo.org/docs/contrib/cache/#werkzeug.contrib.cache.BaseCache.get" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 函数，
如果现在缓存中存在对应项目，它将会返回。否则函数将会返回 <cite>None</cite></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rv</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my-item&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在缓存中添加项目，使用 <tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt> 函数。
第一个参数是想要设定的键，第二个参数是想要缓存的值。您可以设定一个超时时间，
当时间超过时，缓存系统将会自动清除这个项目。</p>
<p>以下是一个通常情况下实现功能完整例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_my_item</span><span class="p">():</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my-item&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">calculate_value</span><span class="p">()</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;my-item&#39;</span><span class="p">,</span> <span class="n">rv</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/viewdecorators"></span><div class="section" id="id1">
<h4>视图装饰器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>Python 拥有一件非常有趣的特性，那就是函数装饰器。这个特性允许您使用一些
非常简介的语法编辑 Web 应用。因为 Flask 中的每个视图都是一个函数装饰器，
这些装饰器被用来将附加的功能注入到一个或者多个函数中。 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a>
装饰器您可能已经使用过了。但是在一些情况下您需要实现自己的装饰器。例如，
您有一个仅供登陆后的用户访问的视图，如果未登录的用户试图访问，则把用户
转接到登陆界面。这个例子很好地说明了装饰器的用武之地。</p>
<div class="section" id="id2">
<h5>过滤未登录用户的装饰器<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>现在让我们实现一个这样的装饰器。装饰器是指返回函数的函数，它其实非常简单。
您仅需要记住，当实现一个类似的东西，其实是更新 <cite>__name__</cite> 、 <cite>__module__</cite>
以及函数的其他一些属性，这件事情经常被遗忘。但是您不必亲自动手，这里
有一个专门用于处理这些的以装饰器形式调用的函数(<a class="reference external" href="http://docs.python.org/dev/library/functools.html#functools.wraps" title="(在 Python v3.5)"><tt class="xref py py-func docutils literal"><span class="pre">functools.wraps()</span></tt></a> )。</p>
<p>这个例子家丁登陆页面的名字是 <tt class="docutils literal"><span class="pre">'login'</span></tt> 并且当前用户被保存在 <cite>g.user</cite> 当中，
如果么有用户登陆， <cite>g.user</cite> 会是 <cite>None</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>

<span class="k">def</span> <span class="nf">login_required</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;login&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">url</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorated_function</span>
</pre></div>
</div>
<p>所以您怎么使用这些装饰器呢？将它加为视图函数外最里层的装饰器。当添加更多
装饰器的话，一定要记住 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 考试最外面的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/secret_page&#39;</span><span class="p">)</span>
<span class="nd">@login_required</span>
<span class="k">def</span> <span class="nf">secret_page</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>缓存装饰器<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>试想你有一个运算量很大的函数，而且您希望能够将生成的结果在一段时间内
缓存起来，一个装饰器将会非常适合用于干这种事。我们假定您已经参考 <a class="reference internal" href="index.html#caching-pattern"><em>缓存</em></a>
中提到的内容配置好了缓存功能。</p>
<p>这里有一个用作例子的缓存函数，它从一个指定的前缀(通常是一个格式化字符串)
和当前请求的路径生成一个缓存键。请注意我们创建了一个这样的函数: 它先创建
一个装饰器，然后用这个装饰器包装目标函数。听起来很复杂？不幸的是，这的确
有些难，但是代码看起来会非常直接明了。</p>
<p>被装饰器包装的函数将能做到如下几点:</p>
<ol class="arabic simple">
<li>以当前请求和路径为基础生成缓存时使用的键。</li>
<li>从缓存中取出对应键的值，如果缓存返回的不是空，我们就将它返回回去。</li>
<li>如果缓存中没有这个键，那么最初的函数将会被执行，并且返回的值在指定时间
(默认5分钟内)被缓存起来。</li>
</ol>
<p>代码如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">&#39;view/</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cache_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rv</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cache_key</span><span class="p">,</span> <span class="n">rv</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>
        <span class="k">return</span> <span class="n">decorated_function</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>
</div>
<p>注意，这段代码假定一个示例用的 <cite>cache</cite> 对象时可用的。请参考 <a class="reference internal" href="index.html#caching-pattern"><em>缓存</em></a>
以获取更多信息。</p>
</div>
<div class="section" id="id4">
<h5>模板装饰器<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>TurboGears 的家伙们前一段时间发明了一种新的常用范式，那就是模板装饰器。
这个装饰器的关键在于，您将想要传递给模板的值组织成字典的形式，然后从
视图函数中返回，这个模板将会被自动渲染。这样，下面的三个例子就是等价的了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;index.html&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="nd">@templated</span><span class="p">(</span><span class="s">&#39;index.html&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="nd">@templated</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>正如您所看到的，如果没有模板名被指定，那么他会使用 URL 映射的最后一部分，
然后将点转换为反斜杠，最后添加上 <tt class="docutils literal"><span class="pre">'.html'</span></tt> 作为模板的名字。当装饰器
包装的函数返回，返回的字典就会被传递给模板渲染函数。如果 <cite>None</cite> 被返回
了，那么相当于一个空的字典。如果非字典类型的对象被返回，函数将照原样
将那个对象再次返回。这样您就可以继续使用重定向函数或者返回简单的字符串了。</p>
<p>这是那个装饰器的源代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">def</span> <span class="nf">templated</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">template_name</span> <span class="o">=</span> <span class="n">template</span>
            <span class="k">if</span> <span class="n">template_name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">template_name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">endpoint</span> \
                    <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.html&#39;</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ctx</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ctx</span>
            <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decorated_function</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>终端装饰器<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>如果您希望使用 werkzeug 路由系统来获得更多的灵活性。您需要将终点(Endpoint)
像 <a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Rule" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> 中定义的那样映射起来。通过一个装饰器
是可以做到的，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">werkzeug.routing</span> <span class="kn">import</span> <span class="n">Rule</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">url_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">))</span>

<span class="nd">@app.endpoint</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&quot;Hello world&quot;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/wtforms"></span><div class="section" id="wtforms">
<h4>使用 WTForms 进行表单验证<a class="headerlink" href="#wtforms" title="永久链接至标题">¶</a></h4>
<p>如果您不得不跟浏览器提交的表单数据打交道，视图函数里的代码将会很快变得
难以阅读。有不少的代码库被开发用来简化这个过程的操作。其中一个就是 <a class="reference external" href="http://wtforms.simplecodes.com/">WTForms</a> ，
这也是我们今天主要讨论的。如果您发现您自己陷入处理很多表单的境地，那您也许
应该尝试一下他。</p>
<p>要使用 WTForms ，您需要先将您的表单定义为类。我建议您将应用分割为多个模块
(<a class="reference internal" href="index.html#larger-applications"><em>大型应用</em></a>) ，这样的话您仅需为表单添加一个独立的模块。</p>
<div class="admonition-wtforms admonition">
<p class="first admonition-title">挖掘 WTForms 的最大潜力</p>
<p class="last"><a class="reference external" href="http://packages.python.org/Flask-WTF/">Flask-WTF</a> 扩展在这个模式的基础上扩展并添加了一些随手即得的精巧
的帮助函数，这些函数将会使在 Flask 里使用表单更加有趣，您可以通过
<a class="reference external" href="http://pypi.python.org/pypi/Flask-WTF">PyPI</a> 获取它。</p>
</div>
<div class="section" id="id1">
<h5>表单<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>以下是一个典型的注册页面的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">wtforms</span> <span class="kn">import</span> <span class="n">Form</span><span class="p">,</span> <span class="n">BooleanField</span><span class="p">,</span> <span class="n">TextField</span><span class="p">,</span> <span class="n">PasswordField</span><span class="p">,</span> <span class="n">validators</span>

<span class="k">class</span> <span class="nc">RegistrationForm</span><span class="p">(</span><span class="n">Form</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">(</span><span class="s">&#39;Username&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">validators</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">25</span><span class="p">)])</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">(</span><span class="s">&#39;Email Address&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">validators</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">35</span><span class="p">)])</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">PasswordField</span><span class="p">(</span><span class="s">&#39;New Password&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">validators</span><span class="o">.</span><span class="n">Required</span><span class="p">(),</span>
        <span class="n">validators</span><span class="o">.</span><span class="n">EqualTo</span><span class="p">(</span><span class="s">&#39;confirm&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&#39;Passwords must match&#39;</span><span class="p">)</span>
    <span class="p">])</span>
    <span class="n">confirm</span> <span class="o">=</span> <span class="n">PasswordField</span><span class="p">(</span><span class="s">&#39;Repeat Password&#39;</span><span class="p">)</span>
    <span class="n">accept_tos</span> <span class="o">=</span> <span class="n">BooleanField</span><span class="p">(</span><span class="s">&#39;I accept the TOS&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">validators</span><span class="o">.</span><span class="n">Required</span><span class="p">()])</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h5>在视图里<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>在视图函数中，表单的使用是像下面这个样子的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/register&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">register</span><span class="p">():</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">RegistrationForm</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span> <span class="ow">and</span> <span class="n">form</span><span class="o">.</span><span class="n">validate</span><span class="p">():</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">form</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">form</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">form</span><span class="o">.</span><span class="n">password</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">db_session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        <span class="n">flash</span><span class="p">(</span><span class="s">&#39;Thanks for registering&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;login&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;register.html&#39;</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>
</pre></div>
</div>
<p>注意到我们视图中使用了 SQLAlchemy (参考 <a class="reference internal" href="index.html#sqlalchemy-pattern"><em>在 Flask 中使用 SQLAlchemy</em></a> )。但是
这并非必要的，请按照您的需要修正代码。</p>
<p>备忘表:</p>
<ol class="arabic simple">
<li>如果数据是以 <cite>POST</cite> 方式提交的，那么基于请求的 <tt class="xref py py-attr docutils literal"><span class="pre">form</span></tt>
属性的值创建表单。反过来，如果是使用 <cite>GET</cite> 提交的，就从
<tt class="xref py py-attr docutils literal"><span class="pre">args</span></tt> 属性创建。</li>
<li>验证表单数据，调用 <tt class="xref py py-func docutils literal"><span class="pre">validate()</span></tt> 方法。如果数据验证
通过，此方法将会返回 <cite>True</cite> ，否则返回 <cite>False</cite> 。</li>
<li>访问表单的单个值，使用 <cite>form.&lt;NAME&gt;.data</cite> 。</li>
</ol>
</div>
<div class="section" id="id3">
<h5>在模板中使用表单<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>在模板这边，如果您将表单传递给模板，您可以很容易地渲染他们。参看如下代码，
您就会发现这有多么简单了。WTForms 已经为我们完成了一半的表单生成工作。更
棒的是，我们可以编写一个宏来渲染表单的字段，让这个字段包含一个标签，如果
存在验证错误，则列出列表来。</p>
<p>以下是一个使用这种宏的 <cite>_formhelpers.html</cite> 模板的例子:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">macro</span> <span class="nv">render_field</span><span class="o">(</span><span class="nv">field</span><span class="o">)</span> <span class="cp">%}</span>
  <span class="nt">&lt;dt&gt;</span><span class="cp">{{</span> <span class="nv">field.label</span> <span class="cp">}}</span>
  <span class="nt">&lt;dd&gt;</span><span class="cp">{{</span> <span class="nv">field</span><span class="o">(**</span><span class="nv">kwargs</span><span class="o">)|</span><span class="nf">safe</span> <span class="cp">}}</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">field.errors</span> <span class="cp">%}</span>
    <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">errors</span><span class="nt">&gt;</span>
    <span class="cp">{%</span> <span class="k">for</span> <span class="nv">error</span> <span class="k">in</span> <span class="nv">field.errors</span> <span class="cp">%}</span>
      <span class="nt">&lt;li&gt;</span><span class="cp">{{</span> <span class="nv">error</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
    <span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
  <span class="nt">&lt;/dd&gt;</span>
<span class="cp">{%</span> <span class="k">endmacro</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>这些宏接受一对键值对，WTForms 的字段函数接收这个宏然后为我们渲染他们。
键值对参数将会被转化为 HTML 属性，所以在这个例子里，您可以调用
<tt class="docutils literal"><span class="pre">render_field(form.username,class=&quot;username&quot;)</span></tt> 来将一个类添加到这个
输入框元素中。请注意 WTForms 返回标准 Python unicode 字符串，所以我们
使用 <cite>|safe</cite> 告诉 Jinjan2 这些数据已经是经过 HTML 过滤处理的了。</p>
<p>以下是 <cite>register.html</cite> 模板，它对应于上面我们使用过的函数，同时也利用
了 <cite>_formhelpers.html</cite> 模板:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">from</span> <span class="s2">&quot;_formhelpers.html&quot;</span> <span class="k">import</span> <span class="nv">render_field</span> <span class="cp">%}</span>
<span class="nt">&lt;form</span> <span class="na">method=</span><span class="s">post</span> <span class="na">action=</span><span class="s">&quot;/register&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;dl&gt;</span>
    <span class="cp">{{</span> <span class="nv">render_field</span><span class="o">(</span><span class="nv">form.username</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">render_field</span><span class="o">(</span><span class="nv">form.email</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">render_field</span><span class="o">(</span><span class="nv">form.password</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">render_field</span><span class="o">(</span><span class="nv">form.confirm</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">render_field</span><span class="o">(</span><span class="nv">form.accept_tos</span><span class="o">)</span> <span class="cp">}}</span>
  <span class="nt">&lt;/dl&gt;</span>
  <span class="nt">&lt;p&gt;&lt;input</span> <span class="na">type=</span><span class="s">submit</span> <span class="na">value=</span><span class="s">Register</span><span class="nt">&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
<p>关于 WTForms 的更多信息，请访问 <a class="reference external" href="http://wtforms.simplecodes.com/">WTForms 网站</a> 。</p>
</div>
</div>
<span id="document-patterns/templateinheritance"></span><div class="section" id="template-inheritance">
<span id="id1"></span><h4>模板继承<a class="headerlink" href="#template-inheritance" title="永久链接至标题">¶</a></h4>
<p>Jinja 最为强大的地方在于他的模板继承功能，模板继承允许你创建一个基础的骨架模板，
这个模板包含您网站的通用元素，并且定义子模板可以重载的 <strong>blocks</strong> 。</p>
<p>听起来虽然复杂，但是其实非常初级。理解概念的最好方法就是通过例子。</p>
<div class="section" id="id2">
<h5>基础模板<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>在这个叫做 <tt class="docutils literal"><span class="pre">layout.html</span></tt> 的模板中定义了一个简单的 HTML 文档骨架，你可以
将这个骨架用作一个简单的双栏页面。而子模板负责填充空白的 block:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="cp">{%</span> <span class="k">block</span> <span class="nv">head</span> <span class="cp">%}</span>
    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;static&#39;</span><span class="o">,</span> <span class="nv">filename</span><span class="o">=</span><span class="s1">&#39;style.css&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span><span class="cp">{%</span> <span class="k">block</span> <span class="nv">title</span> <span class="cp">%}{%</span> <span class="k">endblock</span> <span class="cp">%}</span> - My Webpage<span class="nt">&lt;/title&gt;</span>
    <span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
  <span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;content&quot;</span><span class="nt">&gt;</span><span class="cp">{%</span> <span class="k">block</span> <span class="nv">content</span> <span class="cp">%}{%</span> <span class="k">endblock</span> <span class="cp">%}</span><span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;footer&quot;</span><span class="nt">&gt;</span>
    <span class="cp">{%</span> <span class="k">block</span> <span class="nv">footer</span> <span class="cp">%}</span>
    <span class="ni">&amp;copy;</span> Copyright 2010 by <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://domain.invalid/&quot;</span><span class="nt">&gt;</span>you<span class="nt">&lt;/a&gt;</span>.
    <span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</div>
<p>在这个例子中，使用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 标签定义了四个子模板可以重载的块。 <cite>block</cite>
标签所做的的所有事情就是告诉模板引擎: 一个子模板可能会重写父模板的这个部分。</p>
</div>
<div class="section" id="id3">
<h5>子模板<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>子模板看起来像这个样子:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;layout.html&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">title</span> <span class="cp">%}</span>Index<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">head</span> <span class="cp">%}</span>
  <span class="cp">{{</span> <span class="nb">super</span><span class="o">()</span> <span class="cp">}}</span>
  <span class="nt">&lt;style </span><span class="na">type=</span><span class="s">&quot;text/css&quot;</span><span class="nt">&gt;</span>
    <span class="nc">.important</span> <span class="p">{</span> <span class="k">color</span><span class="o">:</span> <span class="m">#336699</span><span class="p">;</span> <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">content</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Index<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;important&quot;</span><span class="nt">&gt;</span>
    Welcome on my awesome homepage.
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">extends</span> <span class="pre">%}</span></tt> 是这个例子的关键，它会告诉模板引擎这个模板继承自另一个模板的，
模板引擎分析这个模板时首先会定位其父父模板。extends 标签必须是模板的首个标签。
想要渲染父模板中的模板需要使用 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">super()</span> <span class="pre">}}</span></tt>。</p>
</div>
</div>
<span id="document-patterns/flashing"></span><div class="section" id="message-flashing-pattern">
<span id="id1"></span><h4>消息闪现<a class="headerlink" href="#message-flashing-pattern" title="永久链接至标题">¶</a></h4>
<p>好的应用和用户界面的重点是回馈。如果用户没有得到足够的反馈，他们可能最终
会对您的应用产生不好的评价。Flask 提供了一个非常简单的方法来使用闪现系统
向用户反馈信息。闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在
下一个请求中访问这个数据。这通常配合一个布局模板实现。</p>
<div class="section" id="id2">
<h5>简单的闪现<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>这里是一个完成的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">flash</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">render_template</span><span class="p">,</span> \
     <span class="n">request</span><span class="p">,</span> <span class="n">url_for</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="s">&#39;some_secret&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;index.html&#39;</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;admin&#39;</span> <span class="ow">or</span> \
                <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;secret&#39;</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s">&#39;Invalid credentials&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flash</span><span class="p">(</span><span class="s">&#39;You were successfully logged in&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;login.html&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>这里的 <tt class="docutils literal"><span class="pre">layout.html</span></tt> 模板完成了所有的魔术:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;title&gt;</span>My Application<span class="nt">&lt;/title&gt;</span>
<span class="cp">{%</span> <span class="k">with</span> <span class="nv">messages</span> <span class="o">=</span> <span class="nv">get_flashed_messages</span><span class="o">()</span> <span class="cp">%}</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">messages</span> <span class="cp">%}</span>
    <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">flashes</span><span class="nt">&gt;</span>
    <span class="cp">{%</span> <span class="k">for</span> <span class="nv">message</span> <span class="k">in</span> <span class="nv">messages</span> <span class="cp">%}</span>
      <span class="nt">&lt;li&gt;</span><span class="cp">{{</span> <span class="nv">message</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
    <span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">endwith</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>这里是 <cite>index.html</cite> 模板:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;layout.html&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Overview<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;p&gt;</span>Do you want to <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;login&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>log in?<span class="nt">&lt;/a&gt;</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>这里是登陆模板:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;layout.html&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Login<span class="nt">&lt;/h1&gt;</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">error</span> <span class="cp">%}</span>
    <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">error</span><span class="nt">&gt;&lt;strong&gt;</span>Error:<span class="nt">&lt;/strong&gt;</span> <span class="cp">{{</span> <span class="nv">error</span> <span class="cp">}}</span>
  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
  <span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;&quot;</span> <span class="na">method=</span><span class="s">post</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dl&gt;</span>
      <span class="nt">&lt;dt&gt;</span>Username:
      <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">text</span> <span class="na">name=</span><span class="s">username</span> <span class="na">value=</span><span class="s">&quot;</span><span class="cp">{{</span>
          <span class="nv">request.form.username</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;dt&gt;</span>Password:
      <span class="nt">&lt;dd&gt;&lt;input</span> <span class="na">type=</span><span class="s">password</span> <span class="na">name=</span><span class="s">password</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/dl&gt;</span>
    <span class="nt">&lt;p&gt;&lt;input</span> <span class="na">type=</span><span class="s">submit</span> <span class="na">value=</span><span class="s">Login</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/form&gt;</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>分类闪现<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
<p>当闪现一个消息时，是可以提供一个分类的。未指定分类时默认的分类为 <tt class="docutils literal"><span class="pre">'message'</span></tt> 。
可以使用分类来提供给用户更好的反馈，例如，错误信息应该被显示为红色北京。</p>
<p>要使用一个自定义的分类，只要使用 <a class="reference internal" href="index.html#flask.flash" title="flask.flash"><tt class="xref py py-func docutils literal"><span class="pre">flash()</span></tt></a> 函数的第二个参数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flash</span><span class="p">(</span><span class="s">u&#39;Invalid password provided&#39;</span><span class="p">,</span> <span class="s">&#39;error&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在模板中，您接下来可以调用 <a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a> 函数来返回
这个分类，在下面的情景中，循环看起来将会有一点点不一样:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">with</span> <span class="nv">messages</span> <span class="o">=</span> <span class="nv">get_flashed_messages</span><span class="o">(</span><span class="nv">with_categories</span><span class="o">=</span><span class="kp">true</span><span class="o">)</span> <span class="cp">%}</span>
  <span class="cp">{%</span> <span class="k">if</span> <span class="nv">messages</span> <span class="cp">%}</span>
    <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">flashes</span><span class="nt">&gt;</span>
    <span class="cp">{%</span> <span class="k">for</span> <span class="nv">category</span><span class="o">,</span> <span class="nv">message</span> <span class="k">in</span> <span class="nv">messages</span> <span class="cp">%}</span>
      <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">category</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span><span class="cp">{{</span> <span class="nv">message</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
    <span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">endwith</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>这仅仅是一个渲染闪现信息的例子，您可也可以使用分类来加入一个诸如
<tt class="docutils literal"><span class="pre">&lt;strong&gt;Error:&lt;/strong&gt;</span></tt> 的前缀给信息。</p>
</div>
<div class="section" id="id4">
<h5>过滤闪现消息<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
<p>可选地，您可以将一个分类的列表传入到 <a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a> 中，
以过滤函数返回的结果。如果您希望将每个分类渲染到独立的块中，这会非常有用。</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">with</span> <span class="nv">errors</span> <span class="o">=</span> <span class="nv">get_flashed_messages</span><span class="o">(</span><span class="nv">category_filter</span><span class="o">=[</span><span class="s2">&quot;error&quot;</span><span class="o">])</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">if</span> <span class="nv">errors</span> <span class="cp">%}</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;alert-message block-message error&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;close&quot;</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span><span class="nt">&gt;</span>×<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;ul&gt;</span>
    <span class="cp">{%</span>- <span class="k">for</span> <span class="nv">msg</span> <span class="k">in</span> <span class="nv">errors</span> <span class="cp">%}</span>
    <span class="nt">&lt;li&gt;</span><span class="cp">{{</span> <span class="nv">msg</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
    <span class="cp">{%</span> <span class="k">endfor</span> -<span class="cp">%}</span>
  <span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">endwith</span> <span class="cp">%}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/jquery"></span><div class="section" id="jquery-ajax">
<h4>用 jQuery 实现 Ajax<a class="headerlink" href="#jquery-ajax" title="永久链接至标题">¶</a></h4>
<p><a class="reference external" href="http://jquery.com/">jQuery</a> 是一个小型的 JavaScript 库，它通常被用来简化 DOM 和 JavaScript
操作。通过在服务器和客户端之间交换 JSON 数据是使得 Web 应用动态化的完美方式。</p>
<p>JSON 本身是一个很清量级的数据传输格式，非常近似于 Python 的原始数据类型
(数字、字符串、字典和链表等)，这一数据格式被广泛支持，而且非常容易解析。
它几年前开始流行，然后迅速取代了 XML 在 Web 应用常用数据传输格式中的地位。</p>
<p>如果您使用 Python 2.6 以上版本，JSON 的解析库是开箱即用的。在 Python 2.5 中
您则必须从 PyPI 安装 <a class="reference external" href="http://pypi.python.org/pypi/simplejson">simplejson</a> 库。</p>
<div class="section" id="id1">
<h5>加载 jQuery<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>为了使用 jQuery 您需要先下载它，然后将其放置在您应用的静态文件夹中，并
确认他被加载了。理想的情况下是，您有一个用于所有页面的布局模板。要加载 jQuery
您只需要在这个布局模板中 <cite>&lt;body&gt;</cite> 标签的最下方添加一个 script 标签。</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span> <span class="na">src=</span><span class="s">&quot;{{</span>
<span class="s">  url_for(&#39;static&#39;, filename=&#39;jquery.js&#39;) }}&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>
</div>
<p>另一个加载 jQuery 的技巧是使用 Google 的 <a class="reference external" href="http://code.google.com/apis/ajaxlibs/documentation/">AJAX Libraries API</a> :</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;//ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span><span class="nb">window</span><span class="p">.</span><span class="nx">jQuery</span> <span class="o">||</span> <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">&#39;&lt;script src=&quot;{{</span>
<span class="s1">  url_for(&#39;</span><span class="kr">static</span><span class="s1">&#39;, filename=&#39;</span><span class="nx">jquery</span><span class="p">.</span><span class="nx">js</span><span class="s1">&#39;) }}&quot;&gt;\x3C/script&gt;&#39;</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</pre></div>
</div>
<p>在以上配置的情况下，您需要将 jQuery 放置到静态文件夹当中作为一个备份。浏览器将会
首先尝试直接从 Google 加载 jQuery。如果您的用户至少一次访问过使用 Google 提供的
的 jQuery 版本的话，浏览器就会缓存这个代码，这样您的网站就可以从中获得加载更快的
好处了。</p>
</div>
<div class="section" id="id2">
<h5>我的站点在哪?<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>您知道您的应用在哪里运行么？如果您在开发过程当中，那么答案非常简单:
它运行在本地端口，而且就在这个 URL 的根路径位置。但是如果您后来决定将
您的应哟ing移动到一个不同的未知怎么办？比如 <tt class="docutils literal"><span class="pre">http://example.com/myapp</span></tt> ？
在服务器这边，这从来不是一个问题，原因是我们使用的 <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a>
函数可以帮我们回答这个问题。但是如果我们在使用 jQuery 我们不应该将指向
应用的路径硬编码到程序中，而是将它动态化。该如何做到这点呢？</p>
<p>一个简单的技巧可能是为我们的页面添加一个 script 标签，然后设定一个全局变量
作为一个应用根路径的前缀。如下所示:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
  <span class="nx">$SCRIPT_ROOT</span> <span class="o">=</span> <span class="cp">{{</span> <span class="nv">request.script_root</span><span class="o">|</span><span class="nf">tojson</span><span class="o">|</span><span class="nf">safe</span> <span class="cp">}}</span><span class="p">;</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
</div>
<p>这里的 <tt class="docutils literal"><span class="pre">|safe</span></tt> 是必要的。这样 Jinja 才不会将 JSON 编码的字符串以 HTML 的规则
过滤处理掉。通常这种过滤是必要的，但是在 <cite>script</cite> 标签块当中有着不同于原先的过滤
规则。</p>
<div class="admonition- admonition">
<p class="first admonition-title">可能有用的信息</p>
<p class="last">在 HTML 中， <cite>script</cite> 标签被声明为 <cite>CDATA</cite> 。这意味着 HTML 转义实体将不会
被解析。在 <tt class="docutils literal"><span class="pre">&lt;/script&gt;</span></tt> 出现之前的所有内容都被当做脚本处理。这也意味着在
script 标签的内容之中不应该出现 <tt class="docutils literal"><span class="pre">&lt;/</span></tt> 字样。<tt class="docutils literal"><span class="pre">|tojson</span></tt> 足以在这里完成
正确的事情，他将会为您过滤掉斜杠(<tt class="docutils literal"><span class="pre">{{</span> <span class="pre">&quot;&lt;/script&gt;&quot;|tojson|safe</span> <span class="pre">}}</span></tt> 将会被
渲染成 <tt class="docutils literal"><span class="pre">&quot;&lt;\/script&gt;&quot;</span></tt>)。</p>
</div>
</div>
<div class="section" id="json">
<h5>JSON 视图函数<a class="headerlink" href="#json" title="永久链接至标题">¶</a></h5>
<p>现在让我们创建一个服务端函数，这个服务端函数接收两个数字形式的 URL 参数，
然后将这两个数字相加并以 JSON 对象的形式返回给应用。这是一个相当可笑的例子，
您通常会在服务端直接实现这个功能。但是这是一个方便展示如何配合使用 jQuery 和
Flask 最简单的例子了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span><span class="p">,</span> <span class="n">render_template</span><span class="p">,</span> <span class="n">request</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/_add_numbers&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_numbers</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">result</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;index.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>正如您所见，我们在这里添加了一个 <cite>index</cite> 函数，这个函数用于渲染一个模板。
这个模板将会按照上面的提供的方法加载 jQuery ，并且包含一个小表单用于提供
加法运算的两个数，同时表单还提供了用于激发服务器端函数的一个链接。</p>
<p>注意，这里我们使用不会抛出错误的 <a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.MultiDict.get" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> 方法。
如果对应的键不存在，一个默认值(这里是 <tt class="docutils literal"><span class="pre">0</span></tt>)将hi被返回。更进一步，我们还可以将值转换
为一个特定类型(就像我们这里的 <cite>int</cite> 类型)。这对于由脚本(APIs,JavaScript等)激发的代码
来说是个非常顺手的工具，因为在这种情况下您不需要特别的错误报告。</p>
</div>
<div class="section" id="html">
<h5>HTML 部分<a class="headerlink" href="#html" title="永久链接至标题">¶</a></h5>
<p>您的 index.html 要么继承一个已经加载了 jQuery 且设定了 <cite>$SCRIPT_ROOT</cite> 环境变量的
<cite>layout.html</cite> 模板，要么自己在上方完成了这些事。以下是我们的小应用 (<cite>index.html</cite>)
所需的 HTML 代码。请注意这里我们也将脚本直接写入了 HTML。通常来讲，将脚本代码放置
到一个独立的脚本文件里是一个更好的点子。</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
  <span class="nx">$</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;a#calculate&#39;</span><span class="p">).</span><span class="nx">bind</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="nx">$SCRIPT_ROOT</span> <span class="o">+</span> <span class="s1">&#39;/_add_numbers&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">a</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;input[name=&quot;a&quot;]&#39;</span><span class="p">).</span><span class="nx">val</span><span class="p">(),</span>
        <span class="nx">b</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;input[name=&quot;b&quot;]&#39;</span><span class="p">).</span><span class="nx">val</span><span class="p">()</span>
      <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#result&quot;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">result</span><span class="p">);</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;h1&gt;</span>jQuery Example<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;p&gt;&lt;input</span> <span class="na">type=</span><span class="s">text</span> <span class="na">size=</span><span class="s">5</span> <span class="na">name=</span><span class="s">a</span><span class="nt">&gt;</span> +
   <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">text</span> <span class="na">size=</span><span class="s">5</span> <span class="na">name=</span><span class="s">b</span><span class="nt">&gt;</span> =
   <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">result</span><span class="nt">&gt;</span>?<span class="nt">&lt;/span&gt;</span>
<span class="nt">&lt;p&gt;&lt;a</span> <span class="na">href=</span><span class="s">#</span> <span class="na">id=</span><span class="s">calculate</span><span class="nt">&gt;</span>calculate server side<span class="nt">&lt;/a&gt;</span>
</pre></div>
</div>
<p>我们不会过多介绍 jQuery 使用的细节，仅仅对以上代买做一个快速的解释:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">$(function()</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">})</span></tt> 将会在浏览器加载完页面的基础内容之后立即执行。</li>
<li><tt class="docutils literal"><span class="pre">$('selector')</span></tt> 选择一个用于操作的元素。</li>
<li><tt class="docutils literal"><span class="pre">element.bind('event',</span> <span class="pre">func)</span></tt> 指定元素被单击时运行的函数，如果这个函数
返回 <cite>false</cite> ，那么单击操作的默认行为将被取消。在本例中，点击操作的默认
行为是导航到 <cite>#</cite> 链接标签。</li>
<li><tt class="docutils literal"><span class="pre">$.getJSON(url,</span> <span class="pre">data,</span> <span class="pre">func)</span></tt> 发送一个 <cite>GET</cite> 请求给 <cite>url</cite> ，其中 <cite>data</cite>
对象的内容将以查询参数的形式发送。一旦数据抵达，它将以返回值作为参数执行
给定的函数。请注意，我们在这里可以使用我们先前设定的 <cite>$SCRIPT_ROOT</cite> 变量。</li>
</ol>
<p>如果您还没有完全了解这个例子，可以从 github 上下载 <a class="reference external" href="http://github.com/mitsuhiko/flask/tree/master/examples/jqueryexample">本例源码</a> 。</p>
</div>
</div>
<span id="document-patterns/errorpages"></span><div class="section" id="id1">
<h4>自定义错误页面<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>Flask 自带了很顺手的 <a class="reference internal" href="index.html#flask.abort" title="flask.abort"><tt class="xref py py-func docutils literal"><span class="pre">abort()</span></tt></a> 函数用于以一个 HTTP 失败代码
中断一个请求，他也会提供一个非常简单的错误页面，用于提供一些基础的描述。
这个页面太朴素了以至于缺乏一点灵气。</p>
<p>依赖于错误代码的不同，用户看到某个错误的可能性大小也不同。</p>
<div class="section" id="id2">
<h5>通常的错误代码<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>下面列出了一些用户经常遇到的错误代码，即使在这个应用准确无误的情况下也可能发生:</p>
<dl class="docutils">
<dt><em>404 Not Found</em></dt>
<dd>经典的“哎呦，您输入的 URL 当中有错误”消息。这个消息太常见了，即使是
互联网的新手也知道 404 代号的意义: 该死，我寻找的东西不在那儿。确保
404 页面上有一些有用的信息是一个好主意，至少应该提供一个返回主页的链接。</dd>
<dt><em>403 Forbidden</em></dt>
<dd>如果您的网站包含一些类型的访问控制，您必须向非法的请求返回 403 错误代号。
所以请确保用户不会在试图访问了一个禁止访问的资源后不知所措。</dd>
<dt><em>410 Gone</em></dt>
<dd>您知道 404 Not Found 代号还有一个兄弟名为 410 Gone 么? 很少有人真正实现
它，您可以考虑将其返回给对以前曾经存在、但是现在已经删除的资源的请求，而
不是直接返回 404 。 如果您还没有从数据库里永久删除这个文档，仅仅是将他们
标记为删除。那么可以为用户展示一个消息，说明他们寻找的东西已经永远删除了。</dd>
<dt><em>500 Internal Server Error</em></dt>
<dd>通常在出现编程错误或者服务器过载的时候会返回这个错误代号。在这里放一个
漂亮的页面是一个非常好的主意。因为您的应用 <em>总有一天</em> 会出现错误(请参考
<a class="reference internal" href="index.html#application-errors"><em>记录应用错误</em></a> )</dd>
</dl>
</div>
<div class="section" id="id3">
<h5>错误处理器<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>一个错误处理器是一个类似于视图函数的函数，但是它在错误发生时被执行，并且
错误被当成一个参数传递进来。一般来说错误可能是 <tt class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></tt> ，
但是在有些情况下会是其他错误: 内部服务器的错误的处理器在被执行时，将会
同时得到被捕捉到的实际代码错误作为参数。</p>
<p>错误处理器和要捕捉的错误代码使用 <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> 装饰器注册。
请记住 Flask <em>不会</em> 替您设置错误代码，所以请确保在返回 response 对象时，提供了
对应的 HTTP 状态代码。</p>
<p>如下实现了一个 “404 Page Not Found” 错误处理的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">render_template</span>

<span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;404.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>一个示例模板可能会如下所示:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;layout.html&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">title</span> <span class="cp">%}</span>Page Not Found<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">body</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Page Not Found<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;p&gt;</span>What you were looking for is just not there.
  <span class="nt">&lt;p&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;index&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>go somewhere nice<span class="nt">&lt;/a&gt;</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/lazyloading"></span><div class="section" id="id1">
<h4>延迟加载视图<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>Flask 通常配合装饰器使用，装饰器使用非常简单，而且使您可以将 URL 和处理它的函数
放在一起。然而这种方法也有一种不足: 这就意味着您使用装饰器的代码必须在前面导入，
否则 Flask 将无法找到您的函数。</p>
<p>这对于需要很快导入的应用程序来说是一个问题，这种情况可能出现在类似谷歌的
App Engine 这样的系统上。所以如果您突然发现您的引用超出了这种方法可以处理
的能力，您可以降级到中央 URL 映射的方法。</p>
<p>用于激活中央 URL 映射的函数是 <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a> 方法。
您需要提供一个设置应用程序所有 URL 的文件，而不是使用装饰器。</p>
<div class="section" id="url">
<h5>转换到中央 URL 映射<a class="headerlink" href="#url" title="永久链接至标题">¶</a></h5>
<p>假象现在的应用的样子如下所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>而中央 URL 映射的方法下，您需要一个不包含任何装饰器的文件(<cite>views.py</cite>)，
如下所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>然后使用一个文件初始化应用并将函数映射到 URLs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">views</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">views</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/user/&lt;username&gt;&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">views</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h5>延迟加载<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>目前我们仅仅将视图和路径配置分开了，但是模块仍然是在前面导入的。下面的技巧
使得视图函数可以按需加载。可以使用一个辅助类来实现，这个辅助类以函数的方式
作用，但是当第一次使用某个函数时，它才在内部导入这个函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">import_string</span><span class="p">,</span> <span class="n">cached_property</span>

<span class="k">class</span> <span class="nc">LazyView</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">import_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">import_name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">import_name</span> <span class="o">=</span> <span class="n">import_name</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">import_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">import_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>在使用这种方法时，将 <cite>__module__</cite> 和 <cite>__name__</cite> 变量设定为合适的值是很重要的。
在你没有手动指定一个 URL 规则时，这两个变量被 Flask 用于在内部确定如何命名
URL 规则。</p>
<p>现在您就可以定义您将视图整合到的位置，如下所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">yourapplication.helpers</span> <span class="kn">import</span> <span class="n">LazyView</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span>
                 <span class="n">view_func</span><span class="o">=</span><span class="n">LazyView</span><span class="p">(</span><span class="s">&#39;yourapplication.views.index&#39;</span><span class="p">))</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/user/&lt;username&gt;&#39;</span><span class="p">,</span>
                 <span class="n">view_func</span><span class="o">=</span><span class="n">LazyView</span><span class="p">(</span><span class="s">&#39;yourapplication.views.user&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>您可以进一步改进它，以便于节省键盘敲击次数。通过编写一个在内部调用
<a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a> 方法的函数，自动将一个包含项目名称
以及点符号的字符串添加为前缀，并按需将 <cite>view_func</cite> 封装进 <cite>LazyView</cite></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">url</span><span class="p">(</span><span class="n">url_rule</span><span class="p">,</span> <span class="n">import_name</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">LazyView</span><span class="p">(</span><span class="s">&#39;yourapplication.&#39;</span> <span class="o">+</span> <span class="n">import_name</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="n">url_rule</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">view</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

<span class="n">url</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;views.index&#39;</span><span class="p">)</span>
<span class="n">url</span><span class="p">(</span><span class="s">&#39;/user/&lt;username&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;views.user&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>需要记住的是，请求前后激发的回调处理器必须在一个文件里，并在前面导入，
使之在第一个请求到来之间能够合适地工作。对于其他所有的装饰器来说也是
一样的。</p>
</div>
</div>
<span id="document-patterns/mongokit"></span><div class="section" id="flask-mongokit">
<h4>在 Flask 中使用 MongoKit<a class="headerlink" href="#flask-mongokit" title="永久链接至标题">¶</a></h4>
<p>近些日子，使用基于文档的数据库而不是基于表的关系数据库变得越来越流行。
这一方案展示了如何使用文档映射库 MongoKit ，来与 MongoDB 交互。</p>
<p>这一方案的使用需要一个可用的 MongoDB 服务器，并且安装有 MongoKit 库。</p>
<p>使用 MongoKit 有两种常用的方法，我们将会逐一介绍:</p>
<div class="section" id="id1">
<h5>显式调用<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>MongoKit 的默认行为是这种显式调用的方法。这种方法跟 Django 或者 SQLAlchemy
扩展显示调用扩展大体精神是相同的。</p>
<p>下面是一个 <cite>app.py</cite> 模块的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">mongokit</span> <span class="kn">import</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">Document</span>

<span class="c"># configuration</span>
<span class="n">MONGODB_HOST</span> <span class="o">=</span> <span class="s">&#39;localhost&#39;</span>
<span class="n">MONGODB_PORT</span> <span class="o">=</span> <span class="mi">27017</span>

<span class="c"># create the little application object</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="c"># connect to the database</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;MONGODB_HOST&#39;</span><span class="p">],</span>
                        <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;MONGODB_PORT&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>要定义您的模型，只需编写一个从 MongoKit 导入的 <cite>Document</cite> 类的子类。如果您
已经看过了 SQLAlchemy 的方案，您可能会奇怪为什么这里没有一个会话，甚至没有
定义 <cite>init_db</cite> 函数。一方面， MongoKit 并没有类似会话这种东西。这有时会增加
代码量，但是同时也使得数据库操作非常高效。另一方面， MongoDB 是没有模式的。
这意味着您在相同的插入查询，可以使用不同的数据结构。 MongoKit 本身也是没有
模式的。但是实现了一些用来确保数据完整的验证。</p>
<p>以下是一个文档的例子 (您可以将这个也放进 <cite>app.py</cite> 文件里):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">max_length</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> must be at most </span><span class="si">%s</span><span class="s"> characters long&#39;</span> <span class="o">%</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">validate</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="nb">unicode</span><span class="p">,</span>
        <span class="s">&#39;email&#39;</span><span class="p">:</span> <span class="nb">unicode</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">validators</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="n">max_length</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
        <span class="s">&#39;email&#39;</span><span class="p">:</span> <span class="n">max_length</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">use_dot_notation</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;User </span><span class="si">%r</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="c"># register the User document with our current connection</span>
<span class="n">connection</span><span class="o">.</span><span class="n">register</span><span class="p">([</span><span class="n">User</span><span class="p">])</span>
</pre></div>
</div>
<p>这个例子向您展示了怎么定义您自己的结构(名为 structure)、一个最大字符长度
的验证器以及使用 Monkit 的一项名为 <cite>use_dot_notation</cite> 的特性。某人情况下
MongoKit 按照字典的方式行为，但是将 <cite>use_dot_notation</cite> 为真之后，您可以
像您在几乎所有的 ORM 当中那样，使用点运算符来分割属性的方式访问您的文档。</p>
<p>向数据库里添加数据的方法如下所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yourapplication.database</span> <span class="kn">import</span> <span class="n">connection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yourapplication.models</span> <span class="kn">import</span> <span class="n">User</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">collection</span> <span class="o">=</span> <span class="n">connection</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">users</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">u&#39;admin&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="p">[</span><span class="s">&#39;email&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">u&#39;admin@localhost&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>注意，MongoKit 在列的类型方面有些严格，您必须使用一个通常的 <cite>unicode</cite> 来
作为 <cite>name</cite> 和 <cite>email</cite> 的类型，而不是普通的 <cite>str</cite> 类型。</p>
<p>查询也很简单:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">User</span><span class="o">.</span><span class="n">find</span><span class="p">())</span>
<span class="go">[&lt;User u&#39;admin&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">collection</span><span class="o">.</span><span class="n">User</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">u&#39;admin&#39;</span><span class="p">})</span>
<span class="go">&lt;User u&#39;admin&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="pymongo">
<h5>PyMongo 兼容层<a class="headerlink" href="#pymongo" title="永久链接至标题">¶</a></h5>
<p>如果您想直接使用 PyMongo 。 您也可以利用 MongoKit 实现。如果您希望应用程序实现
最佳的表现，您也许希望使用这种方法。注意，例子并没有展示配合 Flask 使用的具体
方法。请参考上面 MongoKit 的例子代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">MongoKit</span> <span class="kn">import</span> <span class="n">Connection</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">()</span>
</pre></div>
</div>
<p>插入数据可以使用 <cite>insert</cite> 方法。我们必须先获得一个连接。这跟
在 SQL 的世界使用表有些类似。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">collection</span> <span class="o">=</span> <span class="n">connection</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">users</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">u&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;email&#39;</span><span class="p">:</span> <span class="s">u&#39;admin@localhost&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">collection</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
<p>print list(collection.find())
print collection.find_one({&#8216;name&#8217;: u&#8217;admin&#8217;})</p>
<p>MongoKit 将会为我们自动提交修改。</p>
<p>查询数据库，您要直接使用数据库连接:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">find</span><span class="p">())</span>
<span class="go">[{u&#39;_id&#39;: ObjectId(&#39;4c271729e13823182f000000&#39;), u&#39;name&#39;: u&#39;admin&#39;, u&#39;email&#39;: u&#39;admin@localhost&#39;}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">collection</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">u&#39;admin&#39;</span><span class="p">})</span>
<span class="go">{u&#39;_id&#39;: ObjectId(&#39;4c271729e13823182f000000&#39;), u&#39;name&#39;: u&#39;admin&#39;, u&#39;email&#39;: u&#39;admin@localhost&#39;}</span>
</pre></div>
</div>
<p>返回的结果也同样是类字典的对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">u&#39;admin&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="s">&#39;email&#39;</span><span class="p">]</span>
<span class="go">u&#39;admin@localhost&#39;</span>
</pre></div>
</div>
<p>关于 MongoKit 的更多信息，请访问
<a class="reference external" href="https://github.com/namlook/mongokit">website</a>.</p>
</div>
</div>
<span id="document-patterns/favicon"></span><div class="section" id="favicon">
<h4>添加 Favicon<a class="headerlink" href="#favicon" title="永久链接至标题">¶</a></h4>
<p>“Favicon” 是指您的网页浏览器显示在标签页或者历史记录里的图标。
这个图标能帮助用户将您的网站与其他网站区分开，因此请使用一个
独特的标志</p>
<p>一个普遍的问题是如何将一个 Favicon 添加到您的 Flask 应用中。首先，您当然得
先有一个可用的图标，此图标应该是 16 x 16 像素的，且格式为 ICO 。这些虽然不是
必需的规则，但是是被所有浏览器所支持的事实标准。将这个图标放置到您的静态文件
目录下，文件名为 <tt class="file docutils literal"><span class="pre">favicon.ico</span></tt> 。</p>
<p>现在，为了让浏览器找到您的图标，正确的方法是添加一个 Link 标签到 HTML 当中
例如:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;shortcut icon&quot;</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;static&#39;</span><span class="o">,</span> <span class="nv">filename</span><span class="o">=</span><span class="s1">&#39;favicon.ico&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>
</pre></div>
</div>
<p>对于大多数浏览器来说，这就足够了。然后一些非常老的浏览器不支持这个标准。
原来的标准是在网站的根路径下，查找 favicon 文件，并使用它。如果应用程序
不是挂在在域名的根路径，您要么需要配置 Web 服务器来在根路径提供这一图标，
要么您就很不幸地无法实现这一功能了。然而，如果您饿应用是在根路径，您就可以
简单的配置一条重定向的路由:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/favicon.ico&#39;</span><span class="p">,</span>
                 <span class="n">redirect_to</span><span class="o">=</span><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;static&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;favicon.ico&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>如果想要保存额外的重定向请求，您也可以使用 <a class="reference internal" href="index.html#flask.send_from_directory" title="flask.send_from_directory"><tt class="xref py py-func docutils literal"><span class="pre">send_from_directory()</span></tt></a>
函数写一个视图函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">send_from_directory</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/favicon.ico&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">favicon</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">send_from_directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">root_path</span><span class="p">,</span> <span class="s">&#39;static&#39;</span><span class="p">),</span>
                               <span class="s">&#39;favicon.ico&#39;</span><span class="p">,</span> <span class="n">mimetype</span><span class="o">=</span><span class="s">&#39;image/vnd.microsoft.icon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以不详细指定 mimetype ，浏览器将会自行猜测文件的类型。但是我们也可以
指定它以便于避免额外的猜测，因为这个 mimetype 总是固定的。</p>
<p>以上的代码将会通过您的应用程序来提供图标文件的访问。然而，如果可能的话
配置您的网页服务器来提供访问服务会更好。请参考对应网页服务器的文档。</p>
<div class="section" id="id1">
<h5>参考<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<ul class="simple">
<li>Wikipedia 上有关 <a class="reference external" href="http://en.wikipedia.org/wiki/Favicon">Favicon</a> 的文章</li>
</ul>
</div>
</div>
<span id="document-patterns/streaming"></span><div class="section" id="id1">
<h4>数据流<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>有时，您希望发送非常巨量的数据到客户端，远远超过您可以保存在内存中的量。
在您实时地产生这些数据时，如何才能直接把他发送给客户端，而不需要在文件
系统中中转呢?</p>
<p>答案是生成器和 Direct Response。</p>
<div class="section" id="id2">
<h5>基本使用<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>下面是一个简单的视图函数，这一视图函数实时生成大量的 CSV 数据，
这一技巧使用了一个内部函数，这一函数使用生成器来生成数据，并且
稍后激发这个生成器函数时，把返回值传递给一个 response 对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/large.csv&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">generate_large_csv</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">iter_all_rows</span><span class="p">():</span>
            <span class="k">yield</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">generate</span><span class="p">(),</span> <span class="n">mimetype</span><span class="o">=</span><span class="s">&#39;text/csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>每一个 <tt class="docutils literal"><span class="pre">yield</span></tt> 表达式直接被发送给浏览器。现在，仍然有一些 WSGI 中间件可能
打断数据流，所以在这里请注意那些在带缓存快照的调试环境，以及其他一些您可能
激活了的东西。</p>
</div>
<div class="section" id="id3">
<h5>在模板中生成流<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>Jinja2 模板引擎同样支持分块逐个渲染模板。Flask 没有直接暴露这一功能到
模板中，因为它很少被用到，但是您可以很轻易的自己实现:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">stream_template</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="o">**</span><span class="n">context</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">update_template_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">jinja_env</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="n">template_name</span><span class="p">)</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">rv</span><span class="o">.</span><span class="n">enable_buffering</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/my-large-page.html&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">render_large_template</span><span class="p">():</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">iter_all_rows</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">stream_template</span><span class="p">(</span><span class="s">&#39;the_template.html&#39;</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">))</span>
</pre></div>
</div>
<p>这一技巧是从应用程序上的 Jinja2 的环境中得到那个模板对象，然后调用
<tt class="xref py py-meth docutils literal"><span class="pre">stream()</span></tt> 函数而不是 <tt class="xref py py-meth docutils literal"><span class="pre">render()</span></tt>
函数。前者返回的是一个流对象，而不是后者的字符串。因为我们绕过了 Flask
的模板渲染函数，而是直接使用了模板对象，所以我们手动必须调用
<a class="reference internal" href="index.html#flask.Flask.update_template_context" title="flask.Flask.update_template_context"><tt class="xref py py-meth docutils literal"><span class="pre">update_template_context()</span></tt></a> 函数来确保更新了模板的渲染上下文。
这一模板随后以流的方式迭代直到结束。因为每一次您使用使用一个 yield 。服务器
都会将所有的已经产生的内容塞给给客户端，因可能希望在模板中缓冲一部分元素
之后再发送，而不是每次都直接发送。您可以使用 <tt class="docutils literal"><span class="pre">rv.enable_buffering(size)</span></tt>
来实现，size 的较为合理的默认值是 <tt class="docutils literal"><span class="pre">5</span></tt> 。</p>
</div>
</div>
<span id="document-patterns/deferredcallbacks"></span><div class="section" id="deferred-callbacks">
<span id="id1"></span><h4>延迟请求回调<a class="headerlink" href="#deferred-callbacks" title="永久链接至标题">¶</a></h4>
<p>Flask 的设计原则中有一条是响应对象被创建并在一条可能的回调链中传递，而在
这条回调链但中的任意一个回调，您都可以修改或者替换掉他们。当请求开始被
处理时，还没有响应对象，响应对象将在这一过程中，被某个视图函数或者系统
的其他组件按照实际需要来闯将。</p>
<p>但是，如果您想在响应过程的结尾修改响应对象，但是这是对象还不存在，那么会发生
什么呢？一个常见的例子是您可能需要在 before-request 函数当中在响应对象上
设定 Cookie 。</p>
<p>解决这一情况的一个常用方法是改变代码的逻辑，将这一部分代码迁移到
after-request 回调中。然而有些时候这种迁移并不是一个非常容易的敬礼
而且可能使代码看起来非常糟糕。</p>
<p>一个可能的替代方法是将一些回调函数绑定到 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 对象中。然后在
请求结束的时候调用他们。使用这种方法，您可以从应用里的任何一个地方来指定
代码延迟执行。</p>
<div class="section" id="id2">
<h5>装饰器<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>下面的装饰器就是关键，它将一个函数注册到 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 对象上的
一个函数列表中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">after_this_request</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;after_request_callbacks&#39;</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">after_request_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">g</span><span class="o">.</span><span class="n">after_request_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>调用延迟函数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>现在您可以使用 <cite>after_this_request</cite> 装饰器来将一个函数标记为在请求结束之后
执行，但是我们仍然需要手动调用他们。为此，如下函数将被注册为
<a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> 回调:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.after_request</span>
<span class="k">def</span> <span class="nf">call_after_request_callbacks</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;after_request_callbacks&#39;</span><span class="p">,</span> <span class="p">()):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h5>一个实际应用的例子<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>现在我们可以在任何时间点将一个函数注册为在某个特定请求结束后执行，例如您可以
在 before-request 中将用户当前语言的信息保存在 Cookie 中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.before_request</span>
<span class="k">def</span> <span class="nf">detect_user_language</span><span class="p">():</span>
    <span class="n">language</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;user_lang&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">language</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">language</span> <span class="o">=</span> <span class="n">guess_language_from_request</span><span class="p">()</span>
        <span class="nd">@after_this_request</span>
        <span class="k">def</span> <span class="nf">remember_language</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
            <span class="n">response</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s">&#39;user_lang&#39;</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">language</span>
</pre></div>
</div>
</div>
</div>
<span id="document-patterns/methodoverrides"></span><div class="section" id="http-method-overrides">
<h4>添加 HTTP Method Overrides<a class="headerlink" href="#http-method-overrides" title="永久链接至标题">¶</a></h4>
<p>某些 HTTP 代理不支持任意的 HTTP 方法或更新的 HTTP 方法（比如 PATCH）。
这种情况下，通过另一种完全违背协议的 HTTP 方法来“代理” HTTP 方法是可行
的。</p>
<p>这个方法使客户端发出 HTTP POST 请求并设置 <tt class="docutils literal"><span class="pre">X-HTTP-Method-Override</span></tt>
标头的值为想要的 HTTP 方法（比如 <tt class="docutils literal"><span class="pre">PATCH</span></tt> ）。</p>
<p>这很容易通过一个 HTTP 中间件来完成:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HTTPMethodOverrideMiddleware</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">allowed_methods</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span>
        <span class="s">&#39;GET&#39;</span><span class="p">,</span>
        <span class="s">&#39;HEAD&#39;</span><span class="p">,</span>
        <span class="s">&#39;POST&#39;</span><span class="p">,</span>
        <span class="s">&#39;DELETE&#39;</span><span class="p">,</span>
        <span class="s">&#39;PUT&#39;</span><span class="p">,</span>
        <span class="s">&#39;PATCH&#39;</span><span class="p">,</span>
        <span class="s">&#39;OPTIONS&#39;</span>
    <span class="p">])</span>
    <span class="n">bodyless_methods</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;HEAD&#39;</span><span class="p">,</span> <span class="s">&#39;OPTIONS&#39;</span><span class="p">,</span> <span class="s">&#39;DELETE&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_methods</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">,</span> <span class="s">&#39;replace&#39;</span><span class="p">)</span>
            <span class="n">environ</span><span class="p">[</span><span class="s">&#39;REQUEST_METHOD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyless_methods</span><span class="p">:</span>
            <span class="n">environ</span><span class="p">[</span><span class="s">&#39;CONTENT_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;0&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>
</div>
<p>在 Flask 中使用它的必要步骤见下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">HTTPMethodOverrideMiddleware</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-patterns/requestchecksum"></span><div class="section" id="id1">
<h4>请求内容校验码<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>许多代码可以消耗请求数据并对其进行预处理。例如最终出现在已读取的请求对
象上的 JSON 数据、通过另外的代码路径出现的表单数据。当你想要校验收到的
请求数据时，这似乎带来不便。而有时这对某些 API 是必要的。</p>
<p>幸运的是，无论如何可以包装输入流来简单地改变这种状况。</p>
<p>下面的例子计算收到数据的 SHA1 校验码，它从 WSGI 环境中读取数据并把校验
码存放到其中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">hashlib</span>

<span class="k">class</span> <span class="nc">ChecksumCalcStream</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size_hint</span><span class="p">):</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">readline</span><span class="p">(</span><span class="n">size_hint</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

<span class="k">def</span> <span class="nf">generate_checksum</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">environ</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">ChecksumCalcStream</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="s">&#39;wsgi.input&#39;</span><span class="p">])</span>
    <span class="n">env</span><span class="p">[</span><span class="s">&#39;wsgi.input&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span>
    <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">_hash</span>
</pre></div>
</div>
<p>要使用这段代码，所有你需要做的就是在请求消耗数据之前调用计算流。（例如：
小心访问 <tt class="docutils literal"><span class="pre">request.form</span></tt> 或其它此类的东西。例如，应注意避免
<tt class="docutils literal"><span class="pre">before_request_handlers</span></tt> 访问它）。</p>
<p>用法示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/special-api&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">special_api</span><span class="p">():</span>
    <span class="nb">hash</span> <span class="o">=</span> <span class="n">generate_checksum</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="c"># Accessing this parses the input stream</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span>
    <span class="c"># At this point the hash is fully constructed.</span>
    <span class="n">checksum</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="k">return</span> <span class="s">&#39;Hash was: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">checksum</span>
</pre></div>
</div>
</div>
<span id="document-patterns/celery"></span><div class="section" id="celery">
<h4>基于 Celery 的后台任务<a class="headerlink" href="#celery" title="永久链接至标题">¶</a></h4>
<p>Celery 是一个 Python 的任务队列，包含线程/进程池。曾经有一个 Flask 的集成，
但在 Celery 3 重构了内部细节后变得不必要了。本指导补充了如何妥善在 Flask
中使用 Celery 的空白，但假设你已经读过了 Celery 官方文档中的教程
<a class="reference external" href="http://docs.celeryproject.org/en/master/getting-started/first-steps-with-celery.html">使用 Celery 的首要步骤</a></p>
<div class="section" id="id2">
<h5>安装 Celery<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>Celery 提交到了 Python Package Index (PyPI)，所以可以通过标准 Python 工具
<tt class="docutils literal"><span class="pre">pip</span></tt> 或 <tt class="docutils literal"><span class="pre">easy_install</span></tt> 安装:</p>
<div class="highlight-python"><pre>$ pip install celery</pre>
</div>
</div>
<div class="section" id="id3">
<h5>配置 Celery<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h5>
<p>你需要的第一个东西是一个 Celery 实例，称为 Celery 应用。仅就 Celery 而言
其与 Flask 中的 <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 对象有异曲同工之妙。因为这个实例用
于你在 Celery 中做任何事——诸如创建任务和管理职程（Worker）——的入口点，
它必须可以在其它模块中导入。</p>
<p>例如，你可以把它放置到 <tt class="docutils literal"><span class="pre">tasks</span></tt> 模块中。虽然你可以在不重新配置 Flask 的
情况下使用 Celery，但继承任务、添加对 Flask 应用上下文的支持以及关联
Flask 配置会让情况变得更好。</p>
<p>这就是把 Celery 集成到 Flask 的全部必要步骤:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">Celery</span>

<span class="k">def</span> <span class="nf">make_celery</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">celery</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">import_name</span><span class="p">,</span> <span class="n">broker</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;CELERY_BROKER_URL&#39;</span><span class="p">])</span>
    <span class="n">celery</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">)</span>
    <span class="n">TaskBase</span> <span class="o">=</span> <span class="n">celery</span><span class="o">.</span><span class="n">Task</span>
    <span class="k">class</span> <span class="nc">ContextTask</span><span class="p">(</span><span class="n">TaskBase</span><span class="p">):</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">TaskBase</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">celery</span><span class="o">.</span><span class="n">Task</span> <span class="o">=</span> <span class="n">ContextTask</span>
    <span class="k">return</span> <span class="n">celery</span>
</pre></div>
</div>
<p>该函数创建一个新的 Celery 对象，并用应用配置来配置中间人（Broker），
用 Flask 配置更新其余的 Celery 配置，之后在应用上下文中创建一个封装任务
执行的任务子类。</p>
</div>
<div class="section" id="id4">
<h5>最简示例<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>通过上面的步骤，下面即是在 Flask 中使用 Celery 的最简示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">CELERY_BROKER_URL</span><span class="o">=</span><span class="s">&#39;redis://localhost:6379&#39;</span><span class="p">,</span>
    <span class="n">CELERY_RESULT_BACKEND</span><span class="o">=</span><span class="s">&#39;redis://localhost:6379&#39;</span>
<span class="p">)</span>
<span class="n">celery</span> <span class="o">=</span> <span class="n">make_celery</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>


<span class="nd">@celery.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add_together</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>这项任务可以在后台调用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">add_together</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="go">65</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>运行 Celery 职程<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>现在如果你行动迅速，已经执行过了上述的代码，你会失望地得知 <tt class="docutils literal"><span class="pre">.wait()</span></tt>
永远不会实际地返回。这是因为你也需要运行 Celery。你可以这样把 Celery
以职程运行:</p>
<div class="highlight-python"><pre>$ celery -A your_application worker</pre>
</div>
<p><tt class="docutils literal"><span class="pre">your_application</span></tt> 字符串需要指向创建 <cite>celery</cite> 对象的应用所在包或模块。</p>
</div>
</div>
</div>
</div>
<span id="document-deploying/index"></span><div class="section" id="deployment">
<span id="id1"></span><h3>部署选择<a class="headerlink" href="#deployment" title="永久链接至标题">¶</a></h3>
<p>取决于你现有的，有多种途径来运行 Flask 应用。你可以在开发过程中使用内置的
服务器，但是你应该为用于生产的应用选择使用完整的部署。（不要在生产环境中使
用内置的开发服务器）。这里给出几个可选择的方法并且给出了文档。</p>
<p>如果你有一个不同的 WSGI 服务器，查阅文档中关于如何用它运行一个 WSGI 应用
度部分。请记住你的 <tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt> 应用对象就是实际的 WSGI 应用。</p>
<p>选择托管服务来快速配置并运行，参阅快速上手中的
<a class="reference internal" href="index.html#quickstart-deployment"><em>部署到 Web 服务器</em></a> 部分。</p>
<div class="toctree-wrapper compound">
<span id="document-deploying/mod_wsgi"></span><div class="section" id="mod-wsgi-apache">
<span id="mod-wsgi-deployment"></span><h4>mod_wsgi (Apache)<a class="headerlink" href="#mod-wsgi-apache" title="永久链接至标题">¶</a></h4>
<p>如果你使用 <a class="reference external" href="http://httpd.apache.org/">Apache</a> web 服务器，请考虑使用 <a class="reference external" href="http://code.google.com/p/modwsgi/">mod_wsgi</a> 。</p>
<div class="admonition- admonition">
<p class="first admonition-title">注意</p>
<p class="last">请确保在任何 <tt class="docutils literal"><span class="pre">app.run()</span></tt> 调用之前，你应该把应用文件放在一个 <tt class="docutils literal"><span class="pre">if</span>
<span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">`__main__`:</span></tt> 块中或移动到独立的文件。只确保它没被调用是
因为这总是会启动一个本地的 WSGI 服务器，而当我们使用 mod_wsgi 部署应用
时并不想让它出现。</p>
</div>
<div class="section" id="mod-wsgi">
<h5>安装 <cite>mod_wsgi</cite><a class="headerlink" href="#mod-wsgi" title="永久链接至标题">¶</a></h5>
<p>如果你还没有安装过 <cite>mod_wsgi</cite> ，你需要使用包管理器来安装或手动编译它。
mod_wsgi 的 <a class="reference external" href="http://code.google.com/p/modwsgi/wiki/QuickInstallationGuide">安装指引</a> 涵盖了 UNIX 系统中的源码安装。</p>
<p>如果你使用 Ubuntu/Debian 你可以按照下面的命令使用 apt-get 获取并激活它:</p>
<div class="highlight-text"><div class="highlight"><pre># apt-get install libapache2-mod-wsgi
</pre></div>
</div>
<p>在 FreeBSD 上，通过编译 <cite>www/mode_wsgi</cite> port 或使用 pkg_add 来安装:</p>
<div class="highlight-text"><div class="highlight"><pre># pkg_add -r mod_wsgi
</pre></div>
</div>
<p>如果你在使用 pkgsrc 你可以编译 <cite>www/ap2-wsgi</cite> 包来安装 <cite>mod_wsgi</cite> 。</p>
<p>如果你在 apache 第一次重加载后遇到子进程段错误，你可以安全地忽略它们。
只需要重启服务器。</p>
</div>
<div class="section" id="wsgi">
<h5>创建一个 <cite>.wsgi</cite> 文件<a class="headerlink" href="#wsgi" title="永久链接至标题">¶</a></h5>
<p>你需要一个 <cite>yourapplication.wsgi</cite> 文件来运行你的应用。这个文件包含 <cite>mod_wsgi</cite>
启动时执行的获取应用对象的代码。这个对象在该文件中名为 <cite>application</cite> ，并在
之后作为应用。</p>
<p>对于大多数应用，下面度文件就可以胜任:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span> <span class="k">as</span> <span class="n">application</span>
</pre></div>
</div>
<p>如果你没有一个用于创建应用的工厂函数而是单例的应用，你可以直接导入它为
<cite>application</cite> 。</p>
<p>把这个文件放在你可以找到的地方（比如 <cite>/var/www/yourapplication</cite> ）并确保
<cite>yourapplication</cite> 和所有使用的库在 python 载入的路径。如果你不想在系统全局
安装它，请考虑使用 <a class="reference external" href="http://pypi.python.org/pypi/virtualenv">virtual python</a> 实例。记住你也会需要在 virtualenv
中安装应用。可选地，你可以在 <cite>.wsgi</cite> 文件中在导入前修补路径:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;/path/to/the/application&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h5>配置 Apache<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>你需要做的最后一件事情就是为你的应用创建一个 Apache 配置文件。在本例中，考虑
安全因素，我们让 <cite>mod_wsgi</cite> 来在不同度用户下执行应用:</p>
<div class="highlight-apache"><div class="highlight"><pre><span class="nt">&lt;VirtualHost</span> <span class="s">*</span><span class="nt">&gt;</span>
    <span class="nb">ServerName</span> example.com

    <span class="nb">WSGIDaemonProcess</span> yourapplication <span class="k">user</span>=user1 <span class="k">group</span>=group1 threads=5
    <span class="nb">WSGIScriptAlias</span> / <span class="sx">/var/www/yourapplication/yourapplication.wsgi</span>

    <span class="nt">&lt;Directory</span> <span class="s">/var/www/yourapplication</span><span class="nt">&gt;</span>
        <span class="nb">WSGIProcessGroup</span> yourapplication
        <span class="nb">WSGIApplicationGroup</span> %{GLOBAL}
        <span class="nb">Order</span> deny,allow
        <span class="nb">Allow</span> from <span class="k">all</span>
    <span class="nt">&lt;/Directory&gt;</span>
<span class="nt">&lt;/VirtualHost&gt;</span>
</pre></div>
</div>
<p>更多信息请翻阅 <a class="reference external" href="http://code.google.com/p/modwsgi/wiki/">mod_wsgi wiki</a> 。</p>
</div>
<div class="section" id="id4">
<h5>故障排除<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>如果你的应用不能运行，按照下面的指导来排除故障:</p>
<dl class="docutils">
<dt><strong>问题:</strong> 应用不能运行，错误日志显示, SystemExit 忽略</dt>
<dd>你的应用文件中有一个不在 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></tt> 声明保护下的
<tt class="docutils literal"><span class="pre">app.run()</span></tt> 调用。把 <a class="reference internal" href="index.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 从文件中移除，或者把
它移到一个独立的 <cite>run.py</cite> 文件，再或者把它放到这样一个 if 块中。</dd>
<dt><strong>问题:</strong> 应用报出权限错误</dt>
<dd>可能是因为使用了错误的用户运行应用。确保需要访问的应用有合适的权限设置，
并且使用正确的用户来运行（ <cite>WSGIDaemonProcess</cite> 指令的 <tt class="docutils literal"><span class="pre">user</span></tt> 和
<tt class="docutils literal"><span class="pre">group</span></tt> 参数）</dd>
<dt><strong>问题:</strong> 应用崩溃时打印一条错误</dt>
<dd><p class="first">记住 mod_wsgi 禁止对 <a class="reference external" href="http://docs.python.org/dev/library/sys.html#sys.stdout" title="(在 Python v3.5)"><tt class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></tt></a> 和 <a class="reference external" href="http://docs.python.org/dev/library/sys.html#sys.stderr" title="(在 Python v3.5)"><tt class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></tt></a> 做操作。
你可以通过设定配置中的 <cite>WSGIRestrictStdout</cite> 为 <tt class="docutils literal"><span class="pre">off</span></tt> 来禁用这个保护。</p>
<div class="highlight-apache"><div class="highlight"><pre><span class="nb">WSGIRestrictStdout</span> <span class="k">Off</span>
</pre></div>
</div>
<p>或者，你可以在 .wsgi 文件中用不同的流来替换标准输出:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
</pre></div>
</div>
</dd>
<dt><strong>问题:</strong> 访问资源时报出 IO 错误</dt>
<dd><p class="first">你的应用可能是一个你符号链接到 site-packages 文件夹的单个 .py 文件。
请注意这不会正常工作，除非把这个文件放进 pythonpath 包含的文件夹中，
或是把应用转换成一个包。</p>
<p class="last">这个问题同样适用于非安装的包，模块文件名用于定位资源，而符号链接会获取
错误的文件名。</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h5>自动重加载支持<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h5>
<p>你可以激活自动重载入支持来协助部署工具。无论何时，当 <cite>.wsgi</cite> 文件，
<cite>mod_wsgi</cite> 会为我们自动重新加载所有的守护进程。</p>
<p>为此，只需要直接在你的 <cite>Directory</cite> 节中添加如下内容:</p>
<div class="highlight-apache"><div class="highlight"><pre><span class="nb">WSGIScriptReloading</span> <span class="k">On</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h5>使用虚拟环境<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h5>
<p>虚拟环境的优势是它们永远不在系统全局安装所需的依赖关系，这样你可以更好
地控制使用什么。如果你想要同 mod_wsgi 使用虚拟环境，你需要稍微修改一下
<cite>.wsgi</cite> 文件。</p>
<p>把下面的几行添加到你 <cite>.wsgi</cite> 文件的顶部:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">activate_this</span> <span class="o">=</span> <span class="s">&#39;/path/to/env/bin/activate_this.py&#39;</span>
<span class="nb">execfile</span><span class="p">(</span><span class="n">activate_this</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">__file__</span><span class="o">=</span><span class="n">activate_this</span><span class="p">))</span>
</pre></div>
</div>
<p>这根据虚拟环境的设置设定了加载路径。记住这个路径一经是绝对的。</p>
</div>
</div>
<span id="document-deploying/wsgi-standalone"></span><div class="section" id="wsgi">
<span id="deploying-wsgi-standalone"></span><h4>独立 WSGI 容器<a class="headerlink" href="#wsgi" title="永久链接至标题">¶</a></h4>
<p>有用 Python 编写的流行服务器来容纳 WSGI 应用并提供 HTTP 服务。这些服务器在运行
时是独立的：你可以从你的 web 服务器设置到它的代理。如果你遇见问题，请注意
<a class="reference internal" href="index.html#deploying-proxy-setups"><em>代理设置</em></a> 一节的内容。</p>
<div class="section" id="gunicorn">
<h5>Gunicorn<a class="headerlink" href="#gunicorn" title="永久链接至标题">¶</a></h5>
<p><a class="reference external" href="http://gunicorn.org/">Gunicorn</a> &#8216;Green Unicorn&#8217; 是一个给 UNIX 用的 WSGI HTTP 服务器。这是一个从
Ruby 的 Unicorn 项目移植的 pre-fork worker 模式。它既支持 <a class="reference external" href="http://eventlet.net/">eventlet</a> ，也
支持 <a class="reference external" href="http://codespeak.net/py/0.9.2/greenlet.html">greenlet</a> 。在这个服务器上运行 Flask 应用是相当简单的:</p>
<div class="highlight-python"><pre>gunicorn myproject:app</pre>
</div>
<p><a class="reference external" href="http://gunicorn.org/">Gunicorn</a> 提供了许多命令行选项 —— 见 <tt class="docutils literal"><span class="pre">gunicorn</span> <span class="pre">-h</span></tt> 。
例如，用四个 worker 进程（ <tt class="docutils literal"><span class="pre">gunicorn</span> <span class="pre">-h</span></tt> ）来运行一个 Flask 应用，绑定
到 localhost 的4000 端口（ <tt class="docutils literal"><span class="pre">-b</span> <span class="pre">127.0.0.1:4000</span></tt> ）:</p>
<div class="highlight-python"><pre>gunicorn -w 4 -b 127.0.0.1:4000 myproject:app</pre>
</div>
</div>
<div class="section" id="tornado">
<h5>Tornado<a class="headerlink" href="#tornado" title="永久链接至标题">¶</a></h5>
<p><a class="reference external" href="http://www.tornadoweb.org/">Tornado</a> 是一个开源的可伸缩的、非阻塞式的 web 服务器和工具集，它驱动了
<a class="reference external" href="http://friendfeed.com/">FriendFeed</a> 。因为它使用了 epoll 模型且是非阻塞的，它可以处理数以千计
的并发固定连接，这意味着它对实时 web 服务是理想的。把 Flask 集成这个服务
是直截了当的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">tornado.wsgi</span> <span class="kn">import</span> <span class="n">WSGIContainer</span>
<span class="kn">from</span> <span class="nn">tornado.httpserver</span> <span class="kn">import</span> <span class="n">HTTPServer</span>
<span class="kn">from</span> <span class="nn">tornado.ioloop</span> <span class="kn">import</span> <span class="n">IOLoop</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>

<span class="n">http_server</span> <span class="o">=</span> <span class="n">HTTPServer</span><span class="p">(</span><span class="n">WSGIContainer</span><span class="p">(</span><span class="n">app</span><span class="p">))</span>
<span class="n">http_server</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">IOLoop</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="gevent">
<h5>Gevent<a class="headerlink" href="#gevent" title="永久链接至标题">¶</a></h5>
<p><a class="reference external" href="http://www.gevent.org/">Gevent</a> 是一个基于协同程序的 Python 网络库，使用 <a class="reference external" href="http://codespeak.net/py/0.9.2/greenlet.html">greenlet</a> 来在
<a class="reference external" href="http://monkey.org/~provos/libevent/">libevent</a> 的事件循环上提供高层的同步 API</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">gevent.wsgi</span> <span class="kn">import</span> <span class="n">WSGIServer</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>

<span class="n">http_server</span> <span class="o">=</span> <span class="n">WSGIServer</span><span class="p">((</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">app</span><span class="p">)</span>
<span class="n">http_server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="deploying-proxy-setups">
<span id="id5"></span><h5>代理设置<a class="headerlink" href="#deploying-proxy-setups" title="永久链接至标题">¶</a></h5>
<p>如果你在一个 HTTP 代理后把你的应用部署到这些服务器中的之一，你需要重写一些标头
来让应用正常工作。在 WSGI 环境中两个有问题的值通常是 <cite>REMOTE_ADDR</cite> 和
<cite>HTTP_HOST</cite> 。你可以配置你的 httpd 来传递这些标头，或者在中间件中手动修正。
Werkzeug 带有一个修正工具来解决常见的配置，但是你可能想要为特定的安装自己写
WSGI 中间件。</p>
<p>这是一个简单的 nginx 配置，它监听 localhost 的 8000 端口，并提供到一个应用的
代理，设置了合适的标头:</p>
<div class="highlight-nginx"><div class="highlight"><pre><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>

    <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

    <span class="kn">access_log</span>  <span class="s">/var/log/nginx/access.log</span><span class="p">;</span>
    <span class="kn">error_log</span>  <span class="s">/var/log/nginx/error.log</span><span class="p">;</span>

    <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span>         <span class="s">http://127.0.0.1:8000/</span><span class="p">;</span>
        <span class="kn">proxy_redirect</span>     <span class="no">off</span><span class="p">;</span>

        <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你的 httpd 不提供这些标头，最常见的配置引用从 <cite>X-Forwarded-Host</cite> 设置的主机
名和从 <cite>X-Forwarded-For</cite> 设置的远程地址:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.contrib.fixers</span> <span class="kn">import</span> <span class="n">ProxyFix</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">ProxyFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">信任标头</p>
<p class="last">请记住在一个非代理配置中使用这样一个中间件会是一个安全问题，因为它盲目地信任
一个可能由恶意客户端伪造的标头。</p>
</div>
<p>如果你想从另一个标头重写标头，你可能会使用这样的一个修正程序:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CustomProxyFix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">host</span> <span class="o">=</span> <span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;HTTP_X_FHOST&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">host</span><span class="p">:</span>
            <span class="n">environ</span><span class="p">[</span><span class="s">&#39;HTTP_HOST&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">host</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">CustomProxyFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-deploying/uwsgi"></span><div class="section" id="uwsgi">
<span id="deploying-uwsgi"></span><h4>uWSGI<a class="headerlink" href="#uwsgi" title="永久链接至标题">¶</a></h4>
<p>uWSGI 是在像 <a class="reference external" href="http://nginx.org/">nginx</a> 、 <a class="reference external" href="http://www.lighttpd.net/">lighttpd</a> 以及 <a class="reference external" href="http://www.cherokee-project.com/">cherokee</a> 服务器上的一个部署的选
择。更多选择见 <a class="reference internal" href="index.html#deploying-fastcgi"><em>FastCGI</em></a> 和 <a class="reference internal" href="index.html#deploying-wsgi-standalone"><em>独立 WSGI 容器</em></a> 。
你会首先需要一个 uWSGI 服务器来用 uWSGI 协议来使用你的 WSGI 应用。 uWSGI 是
一个协议，同样也是一个应用服务器，可以提供 uWSGI 、FastCGI 和 HTTP 协议。</p>
<p>最流行的 uWSGI 服务器是 <a class="reference external" href="http://projects.unbit.it/uwsgi/">uwsgi</a> ，我们会在本指导中使用。确保你已经安装
好它来跟随下面的说明。</p>
<div class="admonition- admonition">
<p class="first admonition-title">注意</p>
<p class="last">请提前确保你在应用文件中的任何 <tt class="docutils literal"><span class="pre">app.run()</span></tt> 调用在 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span>
<span class="pre">'__main__':</span></tt> 块中或是移到一个独立的文件。这是因为它总会启动一个本地
的 WSGI 服务器，并且我们在部署应用到 uWSGI 时不需要它。</p>
</div>
<div class="section" id="id1">
<h5>用 uwsgi 启动你的应用<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p><cite>uwsgi</cite> 被设计为操作在 python 模块中找到的 WSGI 可调用量。</p>
<p>已知在 myapp.py 中有一个 flask 应用，使用下面的命令:</p>
<div class="highlight-text"><div class="highlight"><pre>$ uwsgi -s /tmp/uwsgi.sock --module myapp --callable app
</pre></div>
</div>
<p>或者，你喜欢这样:</p>
<div class="highlight-text"><div class="highlight"><pre>$ uwsgi -s /tmp/uwsgi.sock -w myapp:app
</pre></div>
</div>
</div>
<div class="section" id="nginx">
<h5>配置 nginx<a class="headerlink" href="#nginx" title="永久链接至标题">¶</a></h5>
<p>一个基本的 flaks uWSGI 的给 nginx 的 配置看起来是这样:</p>
<div class="highlight-python"><pre>location = /yourapplication { rewrite ^ /yourapplication/; }
location /yourapplication { try_files $uri @yourapplication; }
location @yourapplication {
  include uwsgi_params;
  uwsgi_param SCRIPT_NAME /yourapplication;
  uwsgi_modifier1 30;
  uwsgi_pass unix:/tmp/uwsgi.sock;
}</pre>
</div>
<p>这个配置绑定应用到 <cite>/yourapplication</cite> 。如果你想要绑定到 URL 根会更简单，因
你不许要告诉它 WSGI <cite>SCRIPT_NAME</cite> 或设置 uwsgi modifier 来使用它:</p>
<div class="highlight-python"><pre>location / { try_files $uri @yourapplication; }
location @yourapplication {
    include uwsgi_params;
    uwsgi_pass unix:/tmp/uwsgi.sock;
}</pre>
</div>
</div>
</div>
<span id="document-deploying/fastcgi"></span><div class="section" id="fastcgi">
<span id="deploying-fastcgi"></span><h4>FastCGI<a class="headerlink" href="#fastcgi" title="永久链接至标题">¶</a></h4>
<p>FastCGI 是在像 <a class="reference external" href="http://nginx.org/">nginx</a> 、 <a class="reference external" href="http://www.lighttpd.net/">lighttpd</a> 和 <a class="reference external" href="http://www.cherokee-project.com/">cherokee</a> 服务器上的一个部署选择。
其它选择见 <a class="reference internal" href="index.html#deploying-uwsgi"><em>uWSGI</em></a> 和 <a class="reference internal" href="index.html#deploying-wsgi-standalone"><em>独立 WSGI 容器</em></a> 章节。
在它们上的任何一个运行你的 WSGI 应用首先需要一个 FastCGI 服务器。最流行的一个
是 <a class="reference external" href="http://trac.saddi.com/flup">flup</a> ，我们会在本指导中使用它。确保你已经安装好它来跟随下面的说明。</p>
<div class="admonition- admonition">
<p class="first admonition-title">注意</p>
<p class="last">请提前确保你在应用文件中的任何 <tt class="docutils literal"><span class="pre">app.run()</span></tt> 调用在 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span>
<span class="pre">'__main__':</span></tt> 块中或是移到一个独立的文件。这是因为它总会启动一个本地
的 WSGI 服务器，并且我们在部署应用到 uWSGI 时不需要它。</p>
</div>
<div class="section" id="fcgi">
<h5>创建一个 <cite>.fcgi</cite> 文件<a class="headerlink" href="#fcgi" title="永久链接至标题">¶</a></h5>
<p>首先你需要创建一个 FastCGI 服务器文件。让我们把它叫做
<cite>yourapplication.fcgi</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/python</span>
<span class="kn">from</span> <span class="nn">flup.server.fcgi</span> <span class="kn">import</span> <span class="n">WSGIServer</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">WSGIServer</span><span class="p">(</span><span class="n">app</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>这已经可以为 Apache 工作，而 nginx 和老版本的 lighttpd 需要传递一个
显式的 socket 来与 FastCGI 通信。为此，你需要传递 socket 的路径到
<tt class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">WSGIServer</span><span class="p">(</span><span class="n">application</span><span class="p">,</span> <span class="n">bindAddress</span><span class="o">=</span><span class="s">&#39;/path/to/fcgi.sock&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>这个路径一定与你在服务器配置中定义的路径相同。</p>
<p>把 <cite>yourapplication.fcgi</cite> 文件保存到你能找到的地方。保存在
<cite>/var/www/yourapplication</cite> 或类似的地方是有道理的。</p>
<p>确保这个文件有执行权限，这样服务器才能执行它:</p>
<div class="highlight-text"><div class="highlight"><pre># chmod +x /var/www/yourapplication/yourapplication.fcgi
</pre></div>
</div>
</div>
<div class="section" id="lighttpd">
<h5>配置 lighttpd<a class="headerlink" href="#lighttpd" title="永久链接至标题">¶</a></h5>
<p>一个给 lighttpd 的基本的 FastCGI 配置看起来是这样:</p>
<div class="highlight-python"><pre>fastcgi.server = ("/yourapplication.fcgi" =&gt;
    ((
        "socket" =&gt; "/tmp/yourapplication-fcgi.sock",
        "bin-path" =&gt; "/var/www/yourapplication/yourapplication.fcgi",
        "check-local" =&gt; "disable",
        "max-procs" =&gt; 1
    ))
)

alias.url = (
    "/static/" =&gt; "/path/to/your/static"
)

url.rewrite-once = (
    "^(/static.*)$" =&gt; "$1",
    "^(/.*)$" =&gt; "/yourapplication.fcgi$1"</pre>
</div>
<p>记得启用 FastCGI ，别名和重写模块。这份配置把应用绑定到
<cite>/yourapplication</cite> 。如果想要应用运行在 URL 根路径，你需要用
<tt class="xref py py-class docutils literal"><span class="pre">LighttpdCGIRootFix</span></tt> 中间件来处理
一个 lighttpd 的 bug 。</p>
<p>确保只在应用挂载到 URL 根路径时才应用它。同样，更多信息请翻阅 Lighty
的文档关于 <a class="reference external" href="http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModFastCGI">FastCGI and
Python</a>
的部分（注意显示传递一个 socket 到 run() 不再是必须的）。</p>
</div>
<div class="section" id="nginx">
<h5>配置 nginx<a class="headerlink" href="#nginx" title="永久链接至标题">¶</a></h5>
<p>在 nginx 上安装 FastCGI 应用有一点不同，因为默认没有 FastCGI 参数被转
发。</p>
<p>一个给 nginx 的基本的 FastCGI 配置看起来是这样:</p>
<div class="highlight-python"><pre>location = /yourapplication { rewrite ^ /yourapplication/ last; }
location /yourapplication { try_files $uri @yourapplication; }
location @yourapplication {
    include fastcgi_params;
    fastcgi_split_path_info ^(/yourapplication)(.*)$;
    fastcgi_param PATH_INFO $fastcgi_path_info;
    fastcgi_param SCRIPT_NAME $fastcgi_script_name;
    fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
}</pre>
</div>
<p>这份配置把应用绑定到 <cite>/yourapplication</cite> 。如果你想要绑定到 URL 跟了路径
会更简单，因为你不需要指出如何获取 <cite>PATH_INFO</cite> 和 <cite>SCRIPT_NAME</cite>:</p>
<div class="highlight-python"><pre>location / { try_files $uri @yourapplication; }
location @yourapplication {
    include fastcgi_params;
    fastcgi_param PATH_INFO $fastcgi_script_name;
    fastcgi_param SCRIPT_NAME "";
    fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
}</pre>
</div>
</div>
<div class="section" id="id1">
<h5>运行 FastCGI 进程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>既然 Nginx 和其它服务器并不加载 FastCGI 应用，你需要手动这么做。
<a class="reference external" href="http://supervisord.org/configuration.html#fcgi-program-x-section-settings">Supervisor 可以管理 FastCGI 进程。</a>
你可以寻找其它 FastCGI 进程管理器或写一个启动时运行 <cite>.fcgi</cite> 文件的脚本，
例如使用一个 SysV <tt class="docutils literal"><span class="pre">init.d</span></tt> 脚本。对于临时的解决方案，你总是可以在 GNU
screen 中运行 <tt class="docutils literal"><span class="pre">.fcgi</span></tt> 。更多细节见 <tt class="docutils literal"><span class="pre">man</span> <span class="pre">screen</span></tt> ，注意这是一个手动
的解决方案，并且不会在系统重启后保留:</p>
<div class="highlight-python"><pre>$ screen
$ /var/www/yourapplication/yourapplication.fcgi</pre>
</div>
</div>
<div class="section" id="id2">
<h5>调试<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>FastCGI 在大多数 web 服务器上的部署，对于调试趋于复杂。服务器日志最经常
告诉发生的事就是成行的“未预期的标头结尾”。为了调试应用，唯一可以让你了解
什么东西破碎的方案就是切换到正确的用户并手动执行应用。</p>
<p>这个例子假设你的应用叫做 <cite>application.fcgi</cite> 并且你的 web 服务器用户是
<cite>www-data</cite>:</p>
<div class="highlight-python"><pre>$ su www-data
$ cd /var/www/yourapplication
$ python application.fcgi
Traceback (most recent call last):
  File "yourapplication.fcgi", line 4, in &lt;module&gt;
ImportError: No module named yourapplication</pre>
</div>
<p>在这种情况下，错误看起来是“yourapplication”不在 python 路径下。常见的
问题是:</p>
<ul class="simple">
<li>使用了相对路径。不要依赖于当前工作目录</li>
<li>代码依赖于不是从 web 服务器设置的环境变量</li>
<li>使用了不同的 python 解释器</li>
</ul>
</div>
</div>
<span id="document-deploying/cgi"></span><div class="section" id="cgi">
<h4>CGI<a class="headerlink" href="#cgi" title="永久链接至标题">¶</a></h4>
<p>如果所有其它的部署方式都不能奏效，那么 CGI 毫无疑问会奏效。 CGI 被
所有主流服务器支持，但通常性能欠佳。</p>
<p>这也是你在 Google 的 <a class="reference external" href="http://code.google.com/appengine/">App Engine</a> 上使用 Flask 应用的方式，其执行方式
恰好是一个 CGI-like 的环境。</p>
<div class="admonition- admonition">
<p class="first admonition-title">注意</p>
<p class="last">请提前确保你在应用文件中的任何 <tt class="docutils literal"><span class="pre">app.run()</span></tt> 调用在 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span>
<span class="pre">'__main__':</span></tt> 块中或是移到一个独立的文件。这是因为它总会启动一个本地
的 WSGI 服务器，并且我们在部署应用到 uWSGI 时不需要它。</p>
</div>
<div class="section" id="id1">
<h5>创建一个 <cite>.cgi</cite> 文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h5>
<p>首先你需要创建一个 CGI 应用程序文件。我们把它叫做
<cite>yourapplication.cgi</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/python</span>
<span class="kn">from</span> <span class="nn">wsgiref.handlers</span> <span class="kn">import</span> <span class="n">CGIHandler</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">app</span>

<span class="n">CGIHandler</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h5>服务器配置<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h5>
<p>通常有两种方式来配置服务器。直接把 <cite>.cgi</cite> 复制到 <cite>cgi-bin</cite> （并且使用
<cite>mod_rewrite</cite> 或其它类似的东西来重写 URL ） 或让服务器直接指向这个文件。</p>
<p>例如，在 Apache 中你可以在配置中写入这样的语句:</p>
<div class="highlight-apache"><div class="highlight"><pre><span class="nb">ScriptAlias</span> <span class="sx">/app</span> <span class="sx">/path/to/the/application.cgi</span>
</pre></div>
</div>
<p>更多信息请查阅你的 web 服务器的文档。</p>
</div>
</div>
</div>
</div>
<span id="document-becomingbig"></span><div class="section" id="becomingbig">
<span id="id1"></span><h3>聚沙成塔<a class="headerlink" href="#becomingbig" title="永久链接至标题">¶</a></h3>
<p>这里是增长你的代码库或是扩大应用规模的一些选择。</p>
<div class="section" id="id2">
<h4>阅读源码<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>Flask 的创建一定程度上是为了展示如何在现有的常用工具 Werkzeug（WSGI）
和 Jinja（模板）之上构建你自己的框架，并且当它开发出来之后，它对广大
受众很有用。当你增长你的代码库时，不要仅仅使用 Flask——去理解它。阅读源码。
Flask 的代码是为了阅读而写；它是发布的文档，所以你可以使用它的内部 API。
Flask 坚持为上游库里的 API 写文档，并且为内部工具写文档，这样你们可以
找到你的项目需要的钩子注册点。</p>
</div>
<div class="section" id="id3">
<h4>钩子，继承<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="index.html#api"><em>API</em></a> 文档里面全都是可用的覆盖、钩子注册点和 <a class="reference internal" href="index.html#signals"><em>信号</em></a> 。
你可以提供诸如请求和响应对象的自定义类。深入你所用的 API，并且在
Flask 中探寻框架外可用的定制。去寻找把你的项目重构为实用工具集合和
Flask 扩展的方法，探索社区中的大量的 <a class="reference external" href="http://flask.pocoo.org/extensions/">扩展</a> ，
如果你没找到你需要的工具，就去寻找可以用于构建你自己扩展的
<a class="reference external" href="http://docs.torriacg.org/docs/flask/patterns/">模式</a>。</p>
</div>
<div class="section" id="id6">
<h4>继承<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 类有许多为继承设计的方法。你可以继承
<a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 快速添加或自定义行为（见链接的方法文档），并且
无论你在哪里实例化一个应用类都会使用那个子类。这与
<a class="reference internal" href="index.html#app-factories"><em>应用程序的工厂函数</em></a> 工作良好。</p>
</div>
<div class="section" id="id7">
<h4>用中间件包装<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="index.html#app-dispatch"><em>应用调度</em></a> 章节描述了如何应用中间件的细节。你可以引入 WSGI 中
间件来包装你的 Flask 实例并在 Flask 应用和 HTTP 服务器之间的中间层引入
修正和变更。Werkzeug包含了一些
<a class="reference external" href="http://werkzeug.pocoo.org/docs/middlewares/">中间件</a> 。</p>
</div>
<div class="section" id="id9">
<h4>分支<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>如果上述选择都不奏效，分支(fork) Flask。Flask 的大部分代码都限定在 Werkzeug
和 Jinja2 中。这些库做了大部分工作。Flask 只作为胶水把它们粘合在一起。
对每个项目，都有一个底层框架带来阻碍的点（归咎于原始开发者的假设）。
这很正常，因为如果不是这样，框架本身会是一个非常复杂的系统，导致学习曲
线陡峭，给用户带来许多挫折。</p>
<p>不仅仅是对 Flask，许多人用打了补丁的或修改过的框架来弥补短处。这个思路
也体现在 Flask 的许可证上。如果你决定修改这个框架，你不需要回馈任何的修
改。</p>
<p>分支的消极面当然就是 Flask 扩展会更容易不可用，因为新的框架有一个不同
的导入名称。此外，集成上游的修改可能是一个复杂的过程，取决于修改的数目。
为此，分支应该作为最后手段。</p>
</div>
<div class="section" id="id10">
<h4>像专家一样扩大规模<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>对许多 web 应用，代码的复杂程度比起为预期的用户或数据条目而扩大规模就不
是问题了。 Flask 自己扩大规模的限制只在于你的应用代码、你想用的数据存储
和 Python 解释器以及你运行的 web 服务器。</p>
<p>良好的规模扩张意味着，如果你把服务器的数量加倍，你会得到大约两倍于原来的性能。
而糟糕的则意味着，当你添加了一台新的服务器，应用不会有任何性能提升或根本不
支持第二台服务器。</p>
<p>在 Flask 中关于应用的扩张只有一个制约因素，那就是上下文局部代理。它们依赖于在
Flask 中上下文是被定义为是线程、还是进程或 greenlet。如果你的服务器使用不是基于
线程或 greenlet 的并行计算， Flask 不再能支持这些全局代理。然而大多数
服务器使用线程、 greenlet 或独立进程来实现并发，而这些方法在底层的
Werkzeug 库中有着良好的支持。</p>
</div>
<div class="section" id="id11">
<h4>与社区对话<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>Flask 开发者维护框架对大小代码库用户的可理解性，所以一旦你遇到了由
Flask 引起的麻烦，不要犹豫，用邮件列表或 IRC 频道联系开发者。 Flask 和
Flask 扩展开发者为更大型应用改进的最佳途径就是从用户那里获取反馈。</p>
</div>
</div>
</div>
</div>
<div class="section" id="api">
<h2>API 参考<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h2>
<p>如果你在寻找一个特定函数、类或方法的信息，那么这部分文档就是给你准备的。</p>
<div class="toctree-wrapper compound">
<span id="document-api"></span><div class="section" id="api">
<span id="id1"></span><h3>API<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h3>
<span class="target" id="module-flask"></span><p>这部分文档涵盖了 Flask 的所有接口。对于那些 Flask 依赖外部库的部分，我们
这里提供了最重要的部分的文档，并且提供其官方文档的链接。</p>
<div class="section" id="id2">
<h4>应用对象<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.Flask">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Flask</tt><big>(</big><em>import_name</em>, <em>static_path=None</em>, <em>static_url_path=None</em>, <em>static_folder='static'</em>, <em>template_folder='templates'</em>, <em>instance_path=None</em>, <em>instance_relative_config=False</em><big>)</big><a class="headerlink" href="#flask.Flask" title="永久链接至目标">¶</a></dt>
<dd><p>The flask object implements a WSGI application and acts as the central
object.  It is passed the name of the module or package of the
application.  Once it is created it will act as a central registry for
the view functions, the URL rules, template configuration and much more.</p>
<p>The name of the package is used to resolve resources from inside the
package or the folder the module is contained in depending on if the
package parameter resolves to an actual python package (a folder with
an <cite>__init__.py</cite> file inside) or a standard module (just a <cite>.py</cite> file).</p>
<p>For more information about resource loading, see <a class="reference internal" href="index.html#flask.Flask.open_resource" title="flask.Flask.open_resource"><tt class="xref py py-func docutils literal"><span class="pre">open_resource()</span></tt></a>.</p>
<p>Usually you create a <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> instance in your main module or
in the <cite>__init__.py</cite> file of your package like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-about-the-first-parameter admonition">
<p class="first admonition-title">About the First Parameter</p>
<p>The idea of the first parameter is to give Flask an idea what
belongs to your application.  This name is used to find resources
on the file system, can be used by extensions to improve debugging
information and a lot more.</p>
<p>So it&#8217;s important what you provide there.  If you are using a single
module, <cite>__name__</cite> is always the correct value.  If you however are
using a package, it&#8217;s usually recommended to hardcode the name of
your package there.</p>
<p>For example if your application is defined in <cite>yourapplication/app.py</cite>
you should create it with one of the two versions below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="s">&#39;yourapplication&#39;</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="last">Why is that?  The application will work even with <cite>__name__</cite>, thanks
to how resources are looked up.  However it will make debugging more
painful.  Certain extensions can make assumptions based on the
import name of your application.  For example the Flask-SQLAlchemy
extension will look for the code in your application that triggered
an SQL query in debug mode.  If the import name is not properly set
up, that debugging information is lost.  (For example it would only
pick up SQL queries in <cite>yourapplication.app</cite> and not
<cite>yourapplication.views.frontend</cite>)</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能: </span>The <cite>static_url_path</cite>, <cite>static_folder</cite>, and <cite>template_folder</cite>
parameters were added.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能: </span>The <cite>instance_path</cite> and <cite>instance_relative_config</cite> parameters were
added.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>import_name</strong> &#8211; the name of the application package</li>
<li><strong>static_url_path</strong> &#8211; can be used to specify a different path for the
static files on the web.  Defaults to the name
of the <cite>static_folder</cite> folder.</li>
<li><strong>static_folder</strong> &#8211; the folder with static files that should be served
at <cite>static_url_path</cite>.  Defaults to the <tt class="docutils literal"><span class="pre">'static'</span></tt>
folder in the root path of the application.</li>
<li><strong>template_folder</strong> &#8211; the folder that contains the templates that should
be used by the application.  Defaults to
<tt class="docutils literal"><span class="pre">'templates'</span></tt> folder in the root path of the
application.</li>
<li><strong>instance_path</strong> &#8211; An alternative instance path for the application.
By default the folder <tt class="docutils literal"><span class="pre">'instance'</span></tt> next to the
package or module is assumed to be the instance
path.</li>
<li><strong>instance_relative_config</strong> &#8211; if set to <cite>True</cite> relative filenames
for loading the config are assumed to
be relative to the instance path instead
of the application root.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flask.Flask.add_template_filter">
<tt class="descname">add_template_filter</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.add_template_filter" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template filter.  Works exactly like the
<a class="reference internal" href="index.html#flask.Flask.template_filter" title="flask.Flask.template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">template_filter()</span></tt></a> decorator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the filter, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.add_template_global">
<tt class="descname">add_template_global</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.add_template_global" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template global function. Works exactly like the
<a class="reference internal" href="index.html#flask.Flask.template_global" title="flask.Flask.template_global"><tt class="xref py py-meth docutils literal"><span class="pre">template_global()</span></tt></a> decorator.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the global function, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.add_template_test">
<tt class="descname">add_template_test</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.add_template_test" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template test.  Works exactly like the
<a class="reference internal" href="index.html#flask.Flask.template_test" title="flask.Flask.template_test"><tt class="xref py py-meth docutils literal"><span class="pre">template_test()</span></tt></a> decorator.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the test, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.add_url_rule" title="永久链接至目标">¶</a></dt>
<dd><p>Connects a URL rule.  Works exactly like the <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a>
decorator.  If a view_func is provided it will be registered with the
endpoint.</p>
<p>Basically this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Is equivalent to the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;index&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>If the view_func is not provided you will need to connect the endpoint
to a view function like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">view_functions</span><span class="p">[</span><span class="s">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
</pre></div>
</div>
<p>Internally <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> invokes <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a> so if you want
to customize the behavior via subclassing you only need to change
this method.</p>
<p>For more information refer to <a class="reference internal" href="index.html#url-route-registrations"><em>URL 路由注册</em></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.2 版更改: </span><cite>view_func</cite> parameter added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.6 版更改: </span><cite>OPTIONS</cite> is added automatically as method.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>rule</strong> &#8211; the URL rule as string</li>
<li><strong>endpoint</strong> &#8211; the endpoint for the registered URL rule.  Flask
itself assumes the name of the view function as
endpoint</li>
<li><strong>view_func</strong> &#8211; the function to call when serving a request to the
provided endpoint</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
<a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Rule" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> object.  A change
to Werkzeug is handling of method options.  methods
is a list of methods this rule should be limited
to (<cite>GET</cite>, <cite>POST</cite> etc.).  By default a rule
just listens for <cite>GET</cite> (and implicitly <cite>HEAD</cite>).
Starting with Flask 0.6, <cite>OPTIONS</cite> is implicitly
added and handled by the standard request handling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.after_request">
<tt class="descname">after_request</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.after_request" title="永久链接至目标">¶</a></dt>
<dd><p>Register a function to be run after each request.  Your function
must take one parameter, a <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> object and return
a new response object or the same (see <a class="reference internal" href="index.html#flask.Flask.process_response" title="flask.Flask.process_response"><tt class="xref py py-meth docutils literal"><span class="pre">process_response()</span></tt></a>).</p>
<p>As of Flask 0.7 this function might not be executed at the end of the
request in case an unhandled exception occurred.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.after_request_funcs">
<tt class="descname">after_request_funcs</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.after_request_funcs" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with lists of functions that should be called after
each request.  The key of the dictionary is the name of the blueprint
this function is active for, <cite>None</cite> for all requests.  This can for
example be used to open database connections or getting hold of the
currently logged in user.  To register a function here, use the
<a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.app_context">
<tt class="descname">app_context</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.app_context" title="永久链接至目标">¶</a></dt>
<dd><p>Binds the application only.  For as long as the application is bound
to the current context the <a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">flask.current_app</span></tt></a> points to that
application.  An application context is automatically created when a
request context is pushed if necessary.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.app_ctx_globals_class">
<tt class="descname">app_ctx_globals_class</tt><a class="headerlink" href="#flask.Flask.app_ctx_globals_class" title="永久链接至目标">¶</a></dt>
<dd><p>The class that is used for the <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> instance.</p>
<p>Example use cases for a custom class:</p>
<ol class="arabic simple">
<li>Store arbitrary attributes on flask.g.</li>
<li>Add a property for lazy per-request database connectors.</li>
<li>Return None instead of AttributeError on expected attributes.</li>
<li>Raise exception if an unexpected attr is set, a &#8220;controlled&#8221; flask.g.</li>
</ol>
<p>In Flask 0.9 this property was called <cite>request_globals_class</cite> but it
was changed in 0.10 to <a class="reference internal" href="index.html#flask.Flask.app_ctx_globals_class" title="flask.Flask.app_ctx_globals_class"><tt class="xref py py-attr docutils literal"><span class="pre">app_ctx_globals_class</span></tt></a> because the
flask.g object is not application context scoped.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">_AppCtxGlobals</span></tt> 的别名</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.auto_find_instance_path">
<tt class="descname">auto_find_instance_path</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.auto_find_instance_path" title="永久链接至目标">¶</a></dt>
<dd><p>Tries to locate the instance path if it was not provided to the
constructor of the application class.  It will basically calculate
the path to a folder named <tt class="docutils literal"><span class="pre">instance</span></tt> next to your main file or
the package.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.before_first_request">
<tt class="descname">before_first_request</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.before_first_request" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a function to be run before the first request to this
instance of the application.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.before_first_request_funcs">
<tt class="descname">before_first_request_funcs</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.before_first_request_funcs" title="永久链接至目标">¶</a></dt>
<dd><p>A lists of functions that should be called at the beginning of the
first request to this instance.  To register a function here, use
the <a class="reference internal" href="index.html#flask.Flask.before_first_request" title="flask.Flask.before_first_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_first_request()</span></tt></a> decorator.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.before_request">
<tt class="descname">before_request</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.before_request" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a function to run before each request.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.before_request_funcs">
<tt class="descname">before_request_funcs</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.before_request_funcs" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with lists of functions that should be called at the
beginning of the request.  The key of the dictionary is the name of
the blueprint this function is active for, <cite>None</cite> for all requests.
This can for example be used to open database connections or
getting hold of the currently logged in user.  To register a
function here, use the <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.blueprints">
<tt class="descname">blueprints</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.blueprints" title="永久链接至目标">¶</a></dt>
<dd><p>all the attached blueprints in a dictionary by name.  Blueprints
can be attached multiple times so this dictionary does not tell
you how often they got attached.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.config">
<tt class="descname">config</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.config" title="永久链接至目标">¶</a></dt>
<dd><p>The configuration dictionary as <a class="reference internal" href="index.html#flask.Config" title="flask.Config"><tt class="xref py py-class docutils literal"><span class="pre">Config</span></tt></a>.  This behaves
exactly like a regular dictionary but supports additional methods
to load a config from files.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.context_processor">
<tt class="descname">context_processor</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.context_processor" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a template context processor function.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.create_global_jinja_loader">
<tt class="descname">create_global_jinja_loader</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.create_global_jinja_loader" title="永久链接至目标">¶</a></dt>
<dd><p>Creates the loader for the Jinja2 environment.  Can be used to
override just the loader and keeping the rest unchanged.  It&#8217;s
discouraged to override this function.  Instead one should override
the <a class="reference internal" href="index.html#flask.Flask.jinja_loader" title="flask.Flask.jinja_loader"><tt class="xref py py-meth docutils literal"><span class="pre">jinja_loader()</span></tt></a> function instead.</p>
<p>The global loader dispatches between the loaders of the application
and the individual blueprints.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.create_jinja_environment">
<tt class="descname">create_jinja_environment</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.create_jinja_environment" title="永久链接至目标">¶</a></dt>
<dd><p>Creates the Jinja2 environment based on <a class="reference internal" href="index.html#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><tt class="xref py py-attr docutils literal"><span class="pre">jinja_options</span></tt></a>
and <a class="reference internal" href="index.html#flask.Flask.select_jinja_autoescape" title="flask.Flask.select_jinja_autoescape"><tt class="xref py py-meth docutils literal"><span class="pre">select_jinja_autoescape()</span></tt></a>.  Since 0.7 this also adds
the Jinja2 globals and filters after initialization.  Override
this function to customize the behavior.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.create_url_adapter">
<tt class="descname">create_url_adapter</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#flask.Flask.create_url_adapter" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a URL adapter for the given request.  The URL adapter
is created at a point where the request context is not yet set up
so the request is passed explicitly.</p>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span>This can now also be called without a request object when the
URL adapter is created for the application context.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.debug">
<tt class="descname">debug</tt><a class="headerlink" href="#flask.Flask.debug" title="永久链接至目标">¶</a></dt>
<dd><p>The debug flag.  Set this to <cite>True</cite> to enable debugging of the
application.  In debug mode the debugger will kick in when an unhandled
exception occurs and the integrated server will automatically reload
the application if changes in the code are detected.</p>
<p>This attribute can also be configured from the config with the <cite>DEBUG</cite>
configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.debug_log_format">
<tt class="descname">debug_log_format</tt><em class="property"> = '--------------------------------------------------------------------------------\n%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\n%(message)s\n--------------------------------------------------------------------------------'</em><a class="headerlink" href="#flask.Flask.debug_log_format" title="永久链接至目标">¶</a></dt>
<dd><p>The logging format used for the debug logger.  This is only used when
the application is in debug mode, otherwise the attached logging
handler does the formatting.</p>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.default_config">
<tt class="descname">default_config</tt><em class="property"> = ImmutableDict({'JSON_AS_ASCII': True, 'USE_X_SENDFILE': False, 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_DOMAIN': None, 'SESSION_COOKIE_NAME': 'session', 'LOGGER_NAME': None, 'DEBUG': False, 'SECRET_KEY': None, 'MAX_CONTENT_LENGTH': None, 'APPLICATION_ROOT': None, 'SERVER_NAME': None, 'PREFERRED_URL_SCHEME': 'http', 'JSONIFY_PRETTYPRINT_REGULAR': True, 'TESTING': False, 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(31), 'PROPAGATE_EXCEPTIONS': None, 'TRAP_BAD_REQUEST_ERRORS': False, 'JSON_SORT_KEYS': True, 'SESSION_COOKIE_HTTPONLY': True, 'SEND_FILE_MAX_AGE_DEFAULT': 43200, 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'SESSION_COOKIE_SECURE': False, 'TRAP_HTTP_EXCEPTIONS': False})</em><a class="headerlink" href="#flask.Flask.default_config" title="永久链接至目标">¶</a></dt>
<dd><p>Default configuration parameters.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.dispatch_request">
<tt class="descname">dispatch_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.dispatch_request" title="永久链接至目标">¶</a></dt>
<dd><p>Does the request dispatching.  Matches the URL and returns the
return value of the view or error handler.  This does not have to
be a response object.  In order to convert the return value to a
proper response object, call <a class="reference internal" href="index.html#flask.make_response" title="flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.7 版更改: </span>This no longer does the exception handling, this code was
moved to the new <a class="reference internal" href="index.html#flask.Flask.full_dispatch_request" title="flask.Flask.full_dispatch_request"><tt class="xref py py-meth docutils literal"><span class="pre">full_dispatch_request()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.do_teardown_appcontext">
<tt class="descname">do_teardown_appcontext</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#flask.Flask.do_teardown_appcontext" title="永久链接至目标">¶</a></dt>
<dd><p>Called when an application context is popped.  This works pretty
much the same as <a class="reference internal" href="index.html#flask.Flask.do_teardown_request" title="flask.Flask.do_teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">do_teardown_request()</span></tt></a> but for the application
context.</p>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.do_teardown_request">
<tt class="descname">do_teardown_request</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#flask.Flask.do_teardown_request" title="永久链接至目标">¶</a></dt>
<dd><p>Called after the actual request dispatching and will
call every as <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> decorated function.  This is
not actually called by the <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> object itself but is always
triggered when the request context is popped.  That way we have a
tighter control over certain resources under testing environments.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span>Added the <cite>exc</cite> argument.  Previously this was always using the
current exception information.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.enable_modules">
<tt class="descname">enable_modules</tt><em class="property"> = True</em><a class="headerlink" href="#flask.Flask.enable_modules" title="永久链接至目标">¶</a></dt>
<dd><p>Enable the deprecated module support?  This is active by default
in 0.7 but will be changed to False in 0.8.  With Flask 1.0 modules
will be removed in favor of Blueprints</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.endpoint">
<tt class="descname">endpoint</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.endpoint" title="永久链接至目标">¶</a></dt>
<dd><p>A decorator to register a function as an endpoint.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.endpoint</span><span class="p">(</span><span class="s">&#39;example.endpoint&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&quot;example&quot;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>endpoint</strong> &#8211; the name of the endpoint</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.error_handler_spec">
<tt class="descname">error_handler_spec</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.error_handler_spec" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary of all registered error handlers.  The key is <cite>None</cite>
for error handlers active on the application, otherwise the key is
the name of the blueprint.  Each key points to another dictionary
where they key is the status code of the http exception.  The
special key <cite>None</cite> points to a list of tuples where the first item
is the class for the instance check and the second the error handler
function.</p>
<p>To register a error handler, use the <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a>
decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.errorhandler">
<tt class="descname">errorhandler</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.errorhandler" title="永久链接至目标">¶</a></dt>
<dd><p>A decorator that is used to register a function give a given
error code.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;This page does not exist&#39;</span><span class="p">,</span> <span class="mi">404</span>
</pre></div>
</div>
<p>You can also register handlers for arbitrary exceptions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="n">DatabaseError</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">special_exception_handler</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;Database connection failed&#39;</span><span class="p">,</span> <span class="mi">500</span>
</pre></div>
</div>
<p>You can also register a function as error handler without using
the <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> decorator.  The following example is
equivalent to the one above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;This page does not exist&#39;</span><span class="p">,</span> <span class="mi">404</span>
<span class="n">app</span><span class="o">.</span><span class="n">error_handler_spec</span><span class="p">[</span><span class="bp">None</span><span class="p">][</span><span class="mi">404</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_not_found</span>
</pre></div>
</div>
<p>Setting error handlers via assignments to <a class="reference internal" href="index.html#flask.Flask.error_handler_spec" title="flask.Flask.error_handler_spec"><tt class="xref py py-attr docutils literal"><span class="pre">error_handler_spec</span></tt></a>
however is discouraged as it requires fiddling with nested dictionaries
and the special case for arbitrary exception types.</p>
<p>The first <cite>None</cite> refers to the active blueprint.  If the error
handler should be application wide <cite>None</cite> shall be used.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能: </span>One can now additionally also register custom exception types
that do not necessarily have to be a subclass of the
<tt class="xref py py-class docutils literal"><span class="pre">HTTPException</span></tt> class.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>code</strong> &#8211; the code as integer for the handler</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.extensions">
<tt class="descname">extensions</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.extensions" title="永久链接至目标">¶</a></dt>
<dd><p>a place where extensions can store application specific state.  For
example this is where an extension could store database engines and
similar things.  For backwards compatibility extensions should register
themselves like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="s">&#39;extensions&#39;</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">app</span><span class="o">.</span><span class="n">extensions</span><span class="p">[</span><span class="s">&#39;extensionname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SomeObject</span><span class="p">()</span>
</pre></div>
</div>
<p>The key must match the name of the <cite>flaskext</cite> module.  For example in
case of a &#8220;Flask-Foo&#8221; extension in <cite>flaskext.foo</cite>, the key would be
<tt class="docutils literal"><span class="pre">'foo'</span></tt>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.full_dispatch_request">
<tt class="descname">full_dispatch_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.full_dispatch_request" title="永久链接至目标">¶</a></dt>
<dd><p>Dispatches the request and on top of that performs request
pre and postprocessing as well as HTTP exception catching and
error handling.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.get_send_file_max_age">
<tt class="descname">get_send_file_max_age</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Flask.get_send_file_max_age" title="永久链接至目标">¶</a></dt>
<dd><p>Provides default cache_timeout for the <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> functions.</p>
<p>By default, this function returns <tt class="docutils literal"><span class="pre">SEND_FILE_MAX_AGE_DEFAULT</span></tt> from
the configuration of <a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a>.</p>
<p>Static file functions such as <a class="reference internal" href="index.html#flask.send_from_directory" title="flask.send_from_directory"><tt class="xref py py-func docutils literal"><span class="pre">send_from_directory()</span></tt></a> use this
function, and <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> calls this function on
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> when the given cache_timeout is <cite>None</cite>. If a
cache_timeout is given in <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>, that timeout is used;
otherwise, this method is called.</p>
<p>This allows subclasses to change the behavior when sending files based
on the filename.  For example, to set the cache timeout for .js files
to 60 seconds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyFlask</span><span class="p">(</span><span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_send_file_max_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.js&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">60</span>
        <span class="k">return</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="o">.</span><span class="n">get_send_file_max_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.got_first_request">
<tt class="descname">got_first_request</tt><a class="headerlink" href="#flask.Flask.got_first_request" title="永久链接至目标">¶</a></dt>
<dd><p>This attribute is set to <cite>True</cite> if the application started
handling the first request.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_exception">
<tt class="descname">handle_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_exception" title="永久链接至目标">¶</a></dt>
<dd><p>Default exception handling that kicks in when an exception
occurs that is not caught.  In debug mode the exception will
be re-raised immediately, otherwise it is logged and the handler
for a 500 internal server error is used.  If no such handler
exists, a default 500 internal server error message is displayed.</p>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_http_exception">
<tt class="descname">handle_http_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_http_exception" title="永久链接至目标">¶</a></dt>
<dd><p>Handles an HTTP exception.  By default this will invoke the
registered error handlers and fall back to returning the
exception as response.</p>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_url_build_error">
<tt class="descname">handle_url_build_error</tt><big>(</big><em>error</em>, <em>endpoint</em>, <em>values</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_url_build_error" title="永久链接至目标">¶</a></dt>
<dd><p>Handle <tt class="xref py py-class docutils literal"><span class="pre">BuildError</span></tt> on <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-meth docutils literal"><span class="pre">url_for()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_user_exception">
<tt class="descname">handle_user_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_user_exception" title="永久链接至目标">¶</a></dt>
<dd><p>This method is called whenever an exception occurs that should be
handled.  A special case are
<tt class="xref py py-class docutils literal"><span class="pre">HTTPException</span></tt>s which are forwarded by
this function to the <a class="reference internal" href="index.html#flask.Flask.handle_http_exception" title="flask.Flask.handle_http_exception"><tt class="xref py py-meth docutils literal"><span class="pre">handle_http_exception()</span></tt></a> method.  This
function will either return a response value or reraise the
exception with the same traceback.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.has_static_folder">
<tt class="descname">has_static_folder</tt><a class="headerlink" href="#flask.Flask.has_static_folder" title="永久链接至目标">¶</a></dt>
<dd><p>This is <cite>True</cite> if the package bound object&#8217;s container has a
folder named <tt class="docutils literal"><span class="pre">'static'</span></tt>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.init_jinja_globals">
<tt class="descname">init_jinja_globals</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.init_jinja_globals" title="永久链接至目标">¶</a></dt>
<dd><p>Deprecated.  Used to initialize the Jinja2 globals.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.7 版更改: </span>This method is deprecated with 0.7.  Override
<a class="reference internal" href="index.html#flask.Flask.create_jinja_environment" title="flask.Flask.create_jinja_environment"><tt class="xref py py-meth docutils literal"><span class="pre">create_jinja_environment()</span></tt></a> instead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.inject_url_defaults">
<tt class="descname">inject_url_defaults</tt><big>(</big><em>endpoint</em>, <em>values</em><big>)</big><a class="headerlink" href="#flask.Flask.inject_url_defaults" title="永久链接至目标">¶</a></dt>
<dd><p>Injects the URL defaults for the given endpoint directly into
the values dictionary passed.  This is used internally and
automatically called on URL building.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.instance_path">
<tt class="descname">instance_path</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.instance_path" title="永久链接至目标">¶</a></dt>
<dd><p>Holds the path to the instance folder.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_env">
<tt class="descname">jinja_env</tt><a class="headerlink" href="#flask.Flask.jinja_env" title="永久链接至目标">¶</a></dt>
<dd><p>The Jinja2 environment used to load templates.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_loader">
<tt class="descname">jinja_loader</tt><a class="headerlink" href="#flask.Flask.jinja_loader" title="永久链接至目标">¶</a></dt>
<dd><p>The Jinja loader for this package bound object.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_options">
<tt class="descname">jinja_options</tt><em class="property"> = ImmutableDict({'extensions': ['jinja2.ext.autoescape', 'jinja2.ext.with_']})</em><a class="headerlink" href="#flask.Flask.jinja_options" title="永久链接至目标">¶</a></dt>
<dd><p>Options that are passed directly to the Jinja2 environment.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.json_decoder">
<tt class="descname">json_decoder</tt><a class="headerlink" href="#flask.Flask.json_decoder" title="永久链接至目标">¶</a></dt>
<dd><p>The JSON decoder class to use.  Defaults to <a class="reference internal" href="index.html#flask.json.JSONDecoder" title="flask.json.JSONDecoder"><tt class="xref py py-class docutils literal"><span class="pre">JSONDecoder</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">JSONDecoder</span></tt> 的别名</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.json_encoder">
<tt class="descname">json_encoder</tt><a class="headerlink" href="#flask.Flask.json_encoder" title="永久链接至目标">¶</a></dt>
<dd><p>The JSON encoder class to use.  Defaults to <a class="reference internal" href="index.html#flask.json.JSONEncoder" title="flask.json.JSONEncoder"><tt class="xref py py-class docutils literal"><span class="pre">JSONEncoder</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">JSONEncoder</span></tt> 的别名</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.log_exception">
<tt class="descname">log_exception</tt><big>(</big><em>exc_info</em><big>)</big><a class="headerlink" href="#flask.Flask.log_exception" title="永久链接至目标">¶</a></dt>
<dd><p>Logs an exception.  This is called by <a class="reference internal" href="index.html#flask.Flask.handle_exception" title="flask.Flask.handle_exception"><tt class="xref py py-meth docutils literal"><span class="pre">handle_exception()</span></tt></a>
if debugging is disabled and right before the handler is called.
The default implementation logs the exception as error on the
<a class="reference internal" href="index.html#flask.Flask.logger" title="flask.Flask.logger"><tt class="xref py py-attr docutils literal"><span class="pre">logger</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.logger">
<tt class="descname">logger</tt><a class="headerlink" href="#flask.Flask.logger" title="永久链接至目标">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Logger" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">logging.Logger</span></tt></a> object for this application.  The
default configuration is to log to stderr if the application is
in debug mode.  This logger can be used to (surprise) log messages.
Here some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;A warning occurred (</span><span class="si">%d</span><span class="s"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;An error occurred&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.logger_name">
<tt class="descname">logger_name</tt><a class="headerlink" href="#flask.Flask.logger_name" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the logger to use.  By default the logger name is the
package name passed to the constructor.</p>
<div class="versionadded">
<p><span class="versionmodified">0.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.make_config">
<tt class="descname">make_config</tt><big>(</big><em>instance_relative=False</em><big>)</big><a class="headerlink" href="#flask.Flask.make_config" title="永久链接至目标">¶</a></dt>
<dd><p>Used to create the config attribute by the Flask constructor.
The <cite>instance_relative</cite> parameter is passed in from the constructor
of Flask (there named <cite>instance_relative_config</cite>) and indicates if
the config should be relative to the instance path or the root path
of the application.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.make_default_options_response">
<tt class="descname">make_default_options_response</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.make_default_options_response" title="永久链接至目标">¶</a></dt>
<dd><p>This method is called to create the default <cite>OPTIONS</cite> response.
This can be changed through subclassing to change the default
behavior of <cite>OPTIONS</cite> responses.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.make_null_session">
<tt class="descname">make_null_session</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.make_null_session" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a new instance of a missing session.  Instead of overriding
this method we recommend replacing the <a class="reference internal" href="index.html#flask.Flask.session_interface" title="flask.Flask.session_interface"><tt class="xref py py-class docutils literal"><span class="pre">session_interface</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.make_response">
<tt class="descname">make_response</tt><big>(</big><em>rv</em><big>)</big><a class="headerlink" href="#flask.Flask.make_response" title="永久链接至目标">¶</a></dt>
<dd><p>Converts the return value from a view function to a real
response object that is an instance of <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a>.</p>
<p>The following types are allowed for <cite>rv</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a></td>
<td>the object is returned unchanged</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#str" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a></td>
<td>a response object is created with the
string as body</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></td>
<td>a response object is created with the
string encoded to utf-8 as body</td>
</tr>
<tr class="row-even"><td>a WSGI function</td>
<td>the function is called as WSGI application
and buffered as response object</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#tuple" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a></td>
<td>A tuple in the form <tt class="docutils literal"><span class="pre">(response,</span> <span class="pre">status,</span>
<span class="pre">headers)</span></tt> where <cite>response</cite> is any of the
types defined here, <cite>status</cite> is a string
or an integer and <cite>headers</cite> is a list of
a dictionary with header values.</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>rv</strong> &#8211; the return value from the view function</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span>Previously a tuple was interpreted as the arguments for the
response object.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.name">
<tt class="descname">name</tt><a class="headerlink" href="#flask.Flask.name" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the application.  This is usually the import name
with the difference that it&#8217;s guessed from the run file if the
import name is main.  This name is used as a display name when
Flask needs the name of the application.  It can be set and overridden
to change the value.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.open_instance_resource">
<tt class="descname">open_instance_resource</tt><big>(</big><em>resource</em>, <em>mode='rb'</em><big>)</big><a class="headerlink" href="#flask.Flask.open_instance_resource" title="永久链接至目标">¶</a></dt>
<dd><p>Opens a resource from the application&#8217;s instance folder
(<a class="reference internal" href="index.html#flask.Flask.instance_path" title="flask.Flask.instance_path"><tt class="xref py py-attr docutils literal"><span class="pre">instance_path</span></tt></a>).  Otherwise works like
<a class="reference internal" href="index.html#flask.Flask.open_resource" title="flask.Flask.open_resource"><tt class="xref py py-meth docutils literal"><span class="pre">open_resource()</span></tt></a>.  Instance resources can also be opened for
writing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>resource</strong> &#8211; the name of the resource.  To access resources within
subfolders use forward slashes as separator.</li>
<li><strong>mode</strong> &#8211; resource file opening mode, default is &#8216;rb&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.open_resource">
<tt class="descname">open_resource</tt><big>(</big><em>resource</em>, <em>mode='rb'</em><big>)</big><a class="headerlink" href="#flask.Flask.open_resource" title="永久链接至目标">¶</a></dt>
<dd><p>Opens a resource from the application&#8217;s resource folder.  To see
how this works, consider the following folder structure:</p>
<div class="highlight-python"><pre>/myapplication.py
/schema.sql
/static
    /style.css
/templates
    /layout.html
    /index.html</pre>
</div>
<p>If you want to open the <cite>schema.sql</cite> file you would do the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;schema.sql&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>resource</strong> &#8211; the name of the resource.  To access resources within
subfolders use forward slashes as separator.</li>
<li><strong>mode</strong> &#8211; resource file opening mode, default is &#8216;rb&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.open_session">
<tt class="descname">open_session</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#flask.Flask.open_session" title="永久链接至目标">¶</a></dt>
<dd><p>Creates or opens a new session.  Default implementation stores all
session data in a signed cookie.  This requires that the
<a class="reference internal" href="index.html#flask.Flask.secret_key" title="flask.Flask.secret_key"><tt class="xref py py-attr docutils literal"><span class="pre">secret_key</span></tt></a> is set.  Instead of overriding this method
we recommend replacing the <a class="reference internal" href="index.html#flask.Flask.session_interface" title="flask.Flask.session_interface"><tt class="xref py py-class docutils literal"><span class="pre">session_interface</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>request</strong> &#8211; an instance of <a class="reference internal" href="index.html#flask.Flask.request_class" title="flask.Flask.request_class"><tt class="xref py py-attr docutils literal"><span class="pre">request_class</span></tt></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.permanent_session_lifetime">
<tt class="descname">permanent_session_lifetime</tt><a class="headerlink" href="#flask.Flask.permanent_session_lifetime" title="永久链接至目标">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/dev/library/datetime.html#datetime.timedelta" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">timedelta</span></tt></a> which is used to set the expiration
date of a permanent session.  The default is 31 days which makes a
permanent session survive for roughly one month.</p>
<p>This attribute can also be configured from the config with the
<cite>PERMANENT_SESSION_LIFETIME</cite> configuration key.  Defaults to
<tt class="docutils literal"><span class="pre">timedelta(days=31)</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.preprocess_request">
<tt class="descname">preprocess_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.preprocess_request" title="永久链接至目标">¶</a></dt>
<dd><p>Called before the actual request dispatching and will
call every as <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorated function.
If any of these function returns a value it&#8217;s handled as
if it was the return value from the view and further
request handling is stopped.</p>
<p>This also triggers the <tt class="xref py py-meth docutils literal"><span class="pre">url_value_processor()</span></tt> functions before
the actual <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> functions are called.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.preserve_context_on_exception">
<tt class="descname">preserve_context_on_exception</tt><a class="headerlink" href="#flask.Flask.preserve_context_on_exception" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the value of the <cite>PRESERVE_CONTEXT_ON_EXCEPTION</cite>
configuration value in case it&#8217;s set, otherwise a sensible default
is returned.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.process_response">
<tt class="descname">process_response</tt><big>(</big><em>response</em><big>)</big><a class="headerlink" href="#flask.Flask.process_response" title="永久链接至目标">¶</a></dt>
<dd><p>Can be overridden in order to modify the response object
before it&#8217;s sent to the WSGI server.  By default this will
call all the <a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> decorated functions.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.5 版更改: </span>As of Flask 0.5 the functions registered for after request
execution are called in reverse order of registration.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>response</strong> &#8211; a <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> object.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">a new response object or the same, has to be an
instance of <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.propagate_exceptions">
<tt class="descname">propagate_exceptions</tt><a class="headerlink" href="#flask.Flask.propagate_exceptions" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the value of the <cite>PROPAGATE_EXCEPTIONS</cite> configuration
value in case it&#8217;s set, otherwise a sensible default is returned.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.register_blueprint">
<tt class="descname">register_blueprint</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.register_blueprint" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a blueprint on the application.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.register_error_handler">
<tt class="descname">register_error_handler</tt><big>(</big><em>code_or_exception</em>, <em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.register_error_handler" title="永久链接至目标">¶</a></dt>
<dd><p>Alternative error attach function to the <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a>
decorator that is more straightforward to use for non decorator
usage.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.register_module">
<tt class="descname">register_module</tt><big>(</big><em>module</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.register_module" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a module with this application.  The keyword argument
of this function are the same as the ones for the constructor of the
<tt class="xref py py-class docutils literal"><span class="pre">Module</span></tt> class and will override the values of the module if
provided.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.7 版更改: </span>The module system was deprecated in favor for the blueprint
system.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.request_class">
<tt class="descname">request_class</tt><a class="headerlink" href="#flask.Flask.request_class" title="永久链接至目标">¶</a></dt>
<dd><p>The class that is used for request objects.  See <a class="reference internal" href="index.html#flask.Request" title="flask.Request"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a>
for more information.</p>
<p><a class="reference internal" href="index.html#flask.Request" title="flask.Request"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a> 的别名</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.request_context">
<tt class="descname">request_context</tt><big>(</big><em>environ</em><big>)</big><a class="headerlink" href="#flask.Flask.request_context" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="index.html#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><tt class="xref py py-class docutils literal"><span class="pre">RequestContext</span></tt></a> from the given
environment and binds it to the current context.  This must be used in
combination with the <cite>with</cite> statement because the request is only bound
to the current context for the duration of the <cite>with</cite> block.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</div>
<p>The object returned can also be used without the <cite>with</cite> statement
which is useful for working in the shell.  The example above is
doing exactly the same as this code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.3 版更改: </span>Added support for non-with statement usage and <cite>with</cite> statement
is now passed the ctx object.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>environ</strong> &#8211; a WSGI environment</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.response_class">
<tt class="descname">response_class</tt><a class="headerlink" href="#flask.Flask.response_class" title="永久链接至目标">¶</a></dt>
<dd><p>The class that is used for response objects.  See
<a class="reference internal" href="index.html#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> for more information.</p>
<p><a class="reference internal" href="index.html#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> 的别名</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.route">
<tt class="descname">route</tt><big>(</big><em>rule</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.route" title="永久链接至目标">¶</a></dt>
<dd><p>A decorator that is used to register a view function for a
given URL rule.  This does the same thing as <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a>
but is intended for decorator usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>For more information refer to <a class="reference internal" href="index.html#url-route-registrations"><em>URL 路由注册</em></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>rule</strong> &#8211; the URL rule as string</li>
<li><strong>endpoint</strong> &#8211; the endpoint for the registered URL rule.  Flask
itself assumes the name of the view function as
endpoint</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
<a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Rule" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> object.  A change
to Werkzeug is handling of method options.  methods
is a list of methods this rule should be limited
to (<cite>GET</cite>, <cite>POST</cite> etc.).  By default a rule
just listens for <cite>GET</cite> (and implicitly <cite>HEAD</cite>).
Starting with Flask 0.6, <cite>OPTIONS</cite> is implicitly
added and handled by the standard request handling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.run">
<tt class="descname">run</tt><big>(</big><em>host=None</em>, <em>port=None</em>, <em>debug=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.run" title="永久链接至目标">¶</a></dt>
<dd><p>Runs the application on a local development server.  If the
<a class="reference internal" href="index.html#flask.Flask.debug" title="flask.Flask.debug"><tt class="xref py py-attr docutils literal"><span class="pre">debug</span></tt></a> flag is set the server will automatically reload
for code changes and show a debugger in case an exception happened.</p>
<p>If you want to run the application in debug mode, but disable the
code execution on the interactive debugger, you can pass
<tt class="docutils literal"><span class="pre">use_evalex=False</span></tt> as parameter.  This will keep the debugger&#8217;s
traceback screen active, but disable code execution.</p>
<div class="admonition-keep-in-mind admonition">
<p class="first admonition-title">Keep in Mind</p>
<p class="last">Flask will suppress any server error with a generic error page
unless it is in debug mode.  As such to enable just the
interactive debugger without the code reloading, you have to
invoke <a class="reference internal" href="index.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> with <tt class="docutils literal"><span class="pre">debug=True</span></tt> and <tt class="docutils literal"><span class="pre">use_reloader=False</span></tt>.
Setting <tt class="docutils literal"><span class="pre">use_debugger</span></tt> to <cite>True</cite> without being in debug mode
won&#8217;t catch any exceptions because there won&#8217;t be any to
catch.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.10 版更改: </span>The default port is now picked from the <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> variable.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>host</strong> &#8211; the hostname to listen on. Set this to <tt class="docutils literal"><span class="pre">'0.0.0.0'</span></tt> to
have the server available externally as well. Defaults to
<tt class="docutils literal"><span class="pre">'127.0.0.1'</span></tt>.</li>
<li><strong>port</strong> &#8211; the port of the webserver. Defaults to <tt class="docutils literal"><span class="pre">5000</span></tt> or the
port defined in the <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> config variable if
present.</li>
<li><strong>debug</strong> &#8211; if given, enable or disable debug mode.
See <a class="reference internal" href="index.html#flask.Flask.debug" title="flask.Flask.debug"><tt class="xref py py-attr docutils literal"><span class="pre">debug</span></tt></a>.</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
Werkzeug server.  See
<a class="reference external" href="http://werkzeug.pocoo.org/docs/serving/#werkzeug.serving.run_simple" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">werkzeug.serving.run_simple()</span></tt></a> for more
information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.save_session">
<tt class="descname">save_session</tt><big>(</big><em>session</em>, <em>response</em><big>)</big><a class="headerlink" href="#flask.Flask.save_session" title="永久链接至目标">¶</a></dt>
<dd><p>Saves the session if it needs updates.  For the default
implementation, check <a class="reference internal" href="index.html#flask.Flask.open_session" title="flask.Flask.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a>.  Instead of overriding this
method we recommend replacing the <a class="reference internal" href="index.html#flask.Flask.session_interface" title="flask.Flask.session_interface"><tt class="xref py py-class docutils literal"><span class="pre">session_interface</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>session</strong> &#8211; the session to be saved (a
<a class="reference external" href="http://werkzeug.pocoo.org/docs/contrib/securecookie/#werkzeug.contrib.securecookie.SecureCookie" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">SecureCookie</span></tt></a>
object)</li>
<li><strong>response</strong> &#8211; an instance of <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.secret_key">
<tt class="descname">secret_key</tt><a class="headerlink" href="#flask.Flask.secret_key" title="永久链接至目标">¶</a></dt>
<dd><p>If a secret key is set, cryptographic components can use this to
sign cookies and other things.  Set this to a complex random value
when you want to use the secure cookie for instance.</p>
<p>This attribute can also be configured from the config with the
<cite>SECRET_KEY</cite> configuration key.  Defaults to <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.select_jinja_autoescape">
<tt class="descname">select_jinja_autoescape</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Flask.select_jinja_autoescape" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <cite>True</cite> if autoescaping should be active for the given
template name.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.send_static_file">
<tt class="descname">send_static_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Flask.send_static_file" title="永久链接至目标">¶</a></dt>
<dd><p>Function used internally to send static files from the static
folder to the browser.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.session_cookie_name">
<tt class="descname">session_cookie_name</tt><a class="headerlink" href="#flask.Flask.session_cookie_name" title="永久链接至目标">¶</a></dt>
<dd><p>The secure cookie uses this for the name of the session cookie.</p>
<p>This attribute can also be configured from the config with the
<cite>SESSION_COOKIE_NAME</cite> configuration key.  Defaults to <tt class="docutils literal"><span class="pre">'session'</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.session_interface">
<tt class="descname">session_interface</tt><em class="property"> = &lt;flask.sessions.SecureCookieSessionInterface object at 0x3001b10&gt;</em><a class="headerlink" href="#flask.Flask.session_interface" title="永久链接至目标">¶</a></dt>
<dd><p>the session interface to use.  By default an instance of
<a class="reference internal" href="index.html#flask.sessions.SecureCookieSessionInterface" title="flask.sessions.SecureCookieSessionInterface"><tt class="xref py py-class docutils literal"><span class="pre">SecureCookieSessionInterface</span></tt></a> is used here.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.should_ignore_error">
<tt class="descname">should_ignore_error</tt><big>(</big><em>error</em><big>)</big><a class="headerlink" href="#flask.Flask.should_ignore_error" title="永久链接至目标">¶</a></dt>
<dd><p>This is called to figure out if an error should be ignored
or not as far as the teardown system is concerned.  If this
function returns <cite>True</cite> then the teardown handlers will not be
passed the error.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.teardown_appcontext">
<tt class="descname">teardown_appcontext</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.teardown_appcontext" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a function to be called when the application context
ends.  These functions are typically also called when the request
context is popped.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">ctx.pop()</span></tt> is executed in the above example, the teardown
functions are called just before the app context moves from the
stack of active contexts.  This becomes relevant if you are using
such constructs in tests.</p>
<p>Since a request context typically also manages an application
context it would also be called when you pop a request context.</p>
<p>When a teardown function was called because of an exception it will
be passed an error object.</p>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.teardown_appcontext_funcs">
<tt class="descname">teardown_appcontext_funcs</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.teardown_appcontext_funcs" title="永久链接至目标">¶</a></dt>
<dd><p>A list of functions that are called when the application context
is destroyed.  Since the application context is also torn down
if the request ends this is the place to store code that disconnects
from databases.</p>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.teardown_request">
<tt class="descname">teardown_request</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.teardown_request" title="永久链接至目标">¶</a></dt>
<dd><p>Register a function to be run at the end of each request,
regardless of whether there was an exception or not.  These functions
are executed when the request context is popped, even if not an
actual request was performed.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">()</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">ctx.pop()</span></tt> is executed in the above example, the teardown
functions are called just before the request context moves from the
stack of active contexts.  This becomes relevant if you are using
such constructs in tests.</p>
<p>Generally teardown functions must take every necessary step to avoid
that they will fail.  If they do execute code that might fail they
will have to surround the execution of these code by try/except
statements and log occurring errors.</p>
<p>When a teardown function was called because of a exception it will
be passed an error object.</p>
<div class="admonition-debug-note admonition">
<p class="first admonition-title">Debug Note</p>
<p class="last">In debug mode Flask will not tear down a request on an exception
immediately.  Instead if will keep it alive so that the interactive
debugger can still access it.  This behavior can be controlled
by the <tt class="docutils literal"><span class="pre">PRESERVE_CONTEXT_ON_EXCEPTION</span></tt> configuration variable.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.teardown_request_funcs">
<tt class="descname">teardown_request_funcs</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.teardown_request_funcs" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with lists of functions that are called after
each request, even if an exception has occurred. The key of the
dictionary is the name of the blueprint this function is active for,
<cite>None</cite> for all requests. These functions are not allowed to modify
the request, and their return values are ignored. If an exception
occurred while processing the request, it gets passed to each
teardown_request function. To register a function here, use the
<a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> decorator.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.template_context_processors">
<tt class="descname">template_context_processors</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.template_context_processors" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with list of functions that are called without argument
to populate the template context.  The key of the dictionary is the
name of the blueprint this function is active for, <cite>None</cite> for all
requests.  Each returns a dictionary that the template context is
updated with.  To register a function here, use the
<a class="reference internal" href="index.html#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">context_processor()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.template_filter">
<tt class="descname">template_filter</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.template_filter" title="永久链接至目标">¶</a></dt>
<dd><p>A decorator that is used to register custom template filter.
You can specify a name for the filter, otherwise the function
name will be used. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.template_filter</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the filter, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.template_global">
<tt class="descname">template_global</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.template_global" title="永久链接至目标">¶</a></dt>
<dd><p>A decorator that is used to register a custom template global function.
You can specify a name for the global function, otherwise the function
name will be used. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.template_global</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the global function, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.template_test">
<tt class="descname">template_test</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.template_test" title="永久链接至目标">¶</a></dt>
<dd><p>A decorator that is used to register custom template test.
You can specify a name for the test, otherwise the function
name will be used. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.template_test</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the test, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.test_client">
<tt class="descname">test_client</tt><big>(</big><em>use_cookies=True</em><big>)</big><a class="headerlink" href="#flask.Flask.test_client" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a test client for this application.  For information
about unit testing head over to <a class="reference internal" href="index.html#testing"><em>测试 Flask 应用</em></a>.</p>
<p>Note that if you are testing for assertions or exceptions in your
application code, you must set <tt class="docutils literal"><span class="pre">app.testing</span> <span class="pre">=</span> <span class="pre">True</span></tt> in order for the
exceptions to propagate to the test client.  Otherwise, the exception
will be handled by the application (not visible to the test client) and
the only indication of an AssertionError or other exception will be a
500 status code response to the test client.  See the <a class="reference internal" href="index.html#flask.Flask.testing" title="flask.Flask.testing"><tt class="xref py py-attr docutils literal"><span class="pre">testing</span></tt></a>
attribute.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">testing</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</pre></div>
</div>
<p>The test client can be used in a <cite>with</cite> block to defer the closing down
of the context until the end of the <cite>with</cite> block.  This is useful if
you want to access the context locals for testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/?vodka=42&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;vodka&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;42&#39;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="index.html#flask.testing.FlaskClient" title="flask.testing.FlaskClient"><tt class="xref py py-class docutils literal"><span class="pre">FlaskClient</span></tt></a> for more information.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.4 版更改: </span>added support for <cite>with</cite> block usage for the client.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能: </span>The <cite>use_cookies</cite> parameter was added as well as the ability
to override the client to be used by setting the
<a class="reference internal" href="index.html#flask.Flask.test_client_class" title="flask.Flask.test_client_class"><tt class="xref py py-attr docutils literal"><span class="pre">test_client_class</span></tt></a> attribute.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.test_client_class">
<tt class="descname">test_client_class</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.test_client_class" title="永久链接至目标">¶</a></dt>
<dd><p>the test client that is used with when <cite>test_client</cite> is used.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.test_request_context">
<tt class="descname">test_request_context</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.test_request_context" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a WSGI environment from the given values (see
<tt class="xref py py-func docutils literal"><span class="pre">werkzeug.test.EnvironBuilder()</span></tt> for more information, this
function accepts the same arguments).</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.testing">
<tt class="descname">testing</tt><a class="headerlink" href="#flask.Flask.testing" title="永久链接至目标">¶</a></dt>
<dd><p>The testing flag.  Set this to <cite>True</cite> to enable the test mode of
Flask extensions (and in the future probably also Flask itself).
For example this might activate unittest helpers that have an
additional runtime cost which should not be enabled by default.</p>
<p>If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
default it&#8217;s implicitly enabled.</p>
<p>This attribute can also be configured from the config with the
<cite>TESTING</cite> configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.trap_http_exception">
<tt class="descname">trap_http_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.trap_http_exception" title="永久链接至目标">¶</a></dt>
<dd><p>Checks if an HTTP exception should be trapped or not.  By default
this will return <cite>False</cite> for all exceptions except for a bad request
key error if <tt class="docutils literal"><span class="pre">TRAP_BAD_REQUEST_ERRORS</span></tt> is set to <cite>True</cite>.  It
also returns <cite>True</cite> if <tt class="docutils literal"><span class="pre">TRAP_HTTP_EXCEPTIONS</span></tt> is set to <cite>True</cite>.</p>
<p>This is called for all HTTP exceptions raised by a view function.
If it returns <cite>True</cite> for any exception the error handler for this
exception is not called and it shows up as regular exception in the
traceback.  This is helpful for debugging implicitly raised HTTP
exceptions.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.update_template_context">
<tt class="descname">update_template_context</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#flask.Flask.update_template_context" title="永久链接至目标">¶</a></dt>
<dd><p>Update the template context with some commonly used variables.
This injects request, session, config and g into the template
context as well as everything template context processors want
to inject.  Note that the as of Flask 0.6, the original values
in the context will not be overridden if a context processor
decides to return a value with the same key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>context</strong> &#8211; the context as a dictionary that is updated in place
to add extra variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_build_error_handlers">
<tt class="descname">url_build_error_handlers</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.url_build_error_handlers" title="永久链接至目标">¶</a></dt>
<dd><p>A list of functions that are called when <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-meth docutils literal"><span class="pre">url_for()</span></tt></a> raises a
<tt class="xref py py-exc docutils literal"><span class="pre">BuildError</span></tt>.  Each function registered here
is called with <cite>error</cite>, <cite>endpoint</cite> and <cite>values</cite>.  If a function
returns <cite>None</cite> or raises a <cite>BuildError</cite> the next function is
tried.</p>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_default_functions">
<tt class="descname">url_default_functions</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.url_default_functions" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with lists of functions that can be used as URL value
preprocessors.  The key <cite>None</cite> here is used for application wide
callbacks, otherwise the key is the name of the blueprint.
Each of these functions has the chance to modify the dictionary
of URL values before they are used as the keyword arguments of the
view function.  For each function registered this one should also
provide a <a class="reference internal" href="index.html#flask.Flask.url_defaults" title="flask.Flask.url_defaults"><tt class="xref py py-meth docutils literal"><span class="pre">url_defaults()</span></tt></a> function that adds the parameters
automatically again that were removed that way.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.url_defaults">
<tt class="descname">url_defaults</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.url_defaults" title="永久链接至目标">¶</a></dt>
<dd><p>Callback function for URL defaults for all view functions of the
application.  It&#8217;s called with the endpoint and values and should
update the values passed in place.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_map">
<tt class="descname">url_map</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.url_map" title="永久链接至目标">¶</a></dt>
<dd><p>The <a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Map" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> for this instance.  You can use
this to change the routing converters after the class was created
but before any routes are connected.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.routing</span> <span class="kn">import</span> <span class="n">BaseConverter</span>

<span class="k">class</span> <span class="nc">ListConverter</span><span class="p">(</span><span class="n">BaseConverter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseConverter</span><span class="o">.</span><span class="n">to_url</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">url_map</span><span class="o">.</span><span class="n">converters</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ListConverter</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_rule_class">
<tt class="descname">url_rule_class</tt><a class="headerlink" href="#flask.Flask.url_rule_class" title="永久链接至目标">¶</a></dt>
<dd><p>The rule object to use for URL rules created.  This is used by
<a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a>.  Defaults to <a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Rule" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">werkzeug.routing.Rule</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt> 的别名</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.url_value_preprocessor">
<tt class="descname">url_value_preprocessor</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.url_value_preprocessor" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a function as URL value preprocessor for all view
functions of the application.  It&#8217;s called before the view functions
are called and can modify the url values provided.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_value_preprocessors">
<tt class="descname">url_value_preprocessors</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.url_value_preprocessors" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with lists of functions that can be used as URL
value processor functions.  Whenever a URL is built these functions
are called to modify the dictionary of values in place.  The key
<cite>None</cite> here is used for application wide
callbacks, otherwise the key is the name of the blueprint.
Each of these functions has the chance to modify the dictionary</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.use_x_sendfile">
<tt class="descname">use_x_sendfile</tt><a class="headerlink" href="#flask.Flask.use_x_sendfile" title="永久链接至目标">¶</a></dt>
<dd><p>Enable this if you want to use the X-Sendfile feature.  Keep in
mind that the server has to support this.  This only affects files
sent with the <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified">0.2 新版功能.</span></p>
</div>
<p>This attribute can also be configured from the config with the
<cite>USE_X_SENDFILE</cite> configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.view_functions">
<tt class="descname">view_functions</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Flask.view_functions" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary of all view functions registered.  The keys will
be function names which are also used to generate URLs and
the values are the function objects themselves.
To register a view function, use the <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.wsgi_app">
<tt class="descname">wsgi_app</tt><big>(</big><em>environ</em>, <em>start_response</em><big>)</big><a class="headerlink" href="#flask.Flask.wsgi_app" title="永久链接至目标">¶</a></dt>
<dd><p>The actual WSGI application.  This is not implemented in
<cite>__call__</cite> so that middlewares can be applied without losing a
reference to the class.  So instead of doing this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s a better idea to do this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you still have the original application object around and
can continue to call methods on it.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.7 版更改: </span>The behavior of the before and after request callbacks was changed
under error conditions and a new callback was added that will
always execute at the end of the request, independent on if an
error occurred or not.  See <a class="reference internal" href="index.html#callbacks-and-errors"><em>回调和错误</em></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>environ</strong> &#8211; a WSGI environment</li>
<li><strong>start_response</strong> &#8211; a callable accepting a status code,
a list of headers and an optional
exception context to start the response</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id3">
<h4>蓝图对象<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.Blueprint">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Blueprint</tt><big>(</big><em>name</em>, <em>import_name</em>, <em>static_folder=None</em>, <em>static_url_path=None</em>, <em>template_folder=None</em>, <em>url_prefix=None</em>, <em>subdomain=None</em>, <em>url_defaults=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint" title="永久链接至目标">¶</a></dt>
<dd><p>Represents a blueprint.  A blueprint is an object that records
functions that will be called with the
<tt class="xref py py-class docutils literal"><span class="pre">BlueprintSetupState</span></tt> later to register functions
or other things on the main application.  See <a class="reference internal" href="index.html#blueprints"><em>用蓝图实现模块化的应用</em></a> for more
information.</p>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
<dl class="method">
<dt id="flask.Blueprint.add_app_template_filter">
<tt class="descname">add_app_template_filter</tt><big>(</big><em>f</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint.add_app_template_filter" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template filter, available application wide.  Like
<a class="reference internal" href="index.html#flask.Flask.add_template_filter" title="flask.Flask.add_template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.add_template_filter()</span></tt></a> but for a blueprint.  Works exactly
like the <a class="reference internal" href="index.html#flask.Blueprint.app_template_filter" title="flask.Blueprint.app_template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">app_template_filter()</span></tt></a> decorator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the filter, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.add_app_template_global">
<tt class="descname">add_app_template_global</tt><big>(</big><em>f</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint.add_app_template_global" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template global, available application wide.  Like
<a class="reference internal" href="index.html#flask.Flask.add_template_global" title="flask.Flask.add_template_global"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.add_template_global()</span></tt></a> but for a blueprint.  Works exactly
like the <a class="reference internal" href="index.html#flask.Blueprint.app_template_global" title="flask.Blueprint.app_template_global"><tt class="xref py py-meth docutils literal"><span class="pre">app_template_global()</span></tt></a> decorator.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the global, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.add_app_template_test">
<tt class="descname">add_app_template_test</tt><big>(</big><em>f</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint.add_app_template_test" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template test, available application wide.  Like
<a class="reference internal" href="index.html#flask.Flask.add_template_test" title="flask.Flask.add_template_test"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.add_template_test()</span></tt></a> but for a blueprint.  Works exactly
like the <a class="reference internal" href="index.html#flask.Blueprint.app_template_test" title="flask.Blueprint.app_template_test"><tt class="xref py py-meth docutils literal"><span class="pre">app_template_test()</span></tt></a> decorator.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the test, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>rule</em>, <em>endpoint=None</em>, <em>view_func=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Blueprint.add_url_rule" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.add_url_rule()</span></tt></a> but for a blueprint.  The endpoint for
the <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> function is prefixed with the name of the blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.after_app_request">
<tt class="descname">after_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.after_app_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.after_request()</span></tt></a> but for a blueprint.  Such a function
is executed after each request, even if outside of the blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.after_request">
<tt class="descname">after_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.after_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.after_request()</span></tt></a> but for a blueprint.  This function
is only executed after each request that is handled by a function of
that blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_context_processor">
<tt class="descname">app_context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_context_processor" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.context_processor()</span></tt></a> but for a blueprint.  Such a
function is executed each request, even if outside of the blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_errorhandler">
<tt class="descname">app_errorhandler</tt><big>(</big><em>code</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_errorhandler" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.errorhandler()</span></tt></a> but for a blueprint.  This
handler is used for all requests, even if outside of the blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_template_filter">
<tt class="descname">app_template_filter</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_template_filter" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template filter, available application wide.  Like
<a class="reference internal" href="index.html#flask.Flask.template_filter" title="flask.Flask.template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.template_filter()</span></tt></a> but for a blueprint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the filter, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_template_global">
<tt class="descname">app_template_global</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_template_global" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template global, available application wide.  Like
<a class="reference internal" href="index.html#flask.Flask.template_global" title="flask.Flask.template_global"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.template_global()</span></tt></a> but for a blueprint.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the global, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_template_test">
<tt class="descname">app_template_test</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_template_test" title="永久链接至目标">¶</a></dt>
<dd><p>Register a custom template test, available application wide.  Like
<a class="reference internal" href="index.html#flask.Flask.template_test" title="flask.Flask.template_test"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.template_test()</span></tt></a> but for a blueprint.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>name</strong> &#8211; the optional name of the test, otherwise the
function name will be used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_url_defaults">
<tt class="descname">app_url_defaults</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_url_defaults" title="永久链接至目标">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="index.html#flask.Blueprint.url_defaults" title="flask.Blueprint.url_defaults"><tt class="xref py py-meth docutils literal"><span class="pre">url_defaults()</span></tt></a> but application wide.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.app_url_value_preprocessor">
<tt class="descname">app_url_value_preprocessor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.app_url_value_preprocessor" title="永久链接至目标">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="index.html#flask.Blueprint.url_value_preprocessor" title="flask.Blueprint.url_value_preprocessor"><tt class="xref py py-meth docutils literal"><span class="pre">url_value_preprocessor()</span></tt></a> but application wide.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.before_app_first_request">
<tt class="descname">before_app_first_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.before_app_first_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.before_first_request" title="flask.Flask.before_first_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_first_request()</span></tt></a>.  Such a function is
executed before the first request to the application.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.before_app_request">
<tt class="descname">before_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.before_app_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_request()</span></tt></a>.  Such a function is executed
before each request, even if outside of a blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.before_request">
<tt class="descname">before_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.before_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_request()</span></tt></a> but for a blueprint.  This function
is only executed before each request that is handled by a function of
that blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.context_processor">
<tt class="descname">context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.context_processor" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.context_processor()</span></tt></a> but for a blueprint.  This
function is only executed for requests handled by a blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.endpoint">
<tt class="descname">endpoint</tt><big>(</big><em>endpoint</em><big>)</big><a class="headerlink" href="#flask.Blueprint.endpoint" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.endpoint" title="flask.Flask.endpoint"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.endpoint()</span></tt></a> but for a blueprint.  This does not
prefix the endpoint with the blueprint name, this has to be done
explicitly by the user of this method.  If the endpoint is prefixed
with a <cite>.</cite> it will be registered to the current blueprint, otherwise
it&#8217;s an application independent endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.errorhandler">
<tt class="descname">errorhandler</tt><big>(</big><em>code_or_exception</em><big>)</big><a class="headerlink" href="#flask.Blueprint.errorhandler" title="永久链接至目标">¶</a></dt>
<dd><p>Registers an error handler that becomes active for this blueprint
only.  Please be aware that routing does not happen local to a
blueprint so an error handler for 404 usually is not handled by
a blueprint unless it is caused inside a view function.  Another
special case is the 500 internal server error which is always looked
up from the application.</p>
<p>Otherwise works as the <a class="reference internal" href="index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> decorator
of the <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.get_send_file_max_age">
<tt class="descname">get_send_file_max_age</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Blueprint.get_send_file_max_age" title="永久链接至目标">¶</a></dt>
<dd><p>Provides default cache_timeout for the <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> functions.</p>
<p>By default, this function returns <tt class="docutils literal"><span class="pre">SEND_FILE_MAX_AGE_DEFAULT</span></tt> from
the configuration of <a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a>.</p>
<p>Static file functions such as <a class="reference internal" href="index.html#flask.send_from_directory" title="flask.send_from_directory"><tt class="xref py py-func docutils literal"><span class="pre">send_from_directory()</span></tt></a> use this
function, and <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> calls this function on
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> when the given cache_timeout is <cite>None</cite>. If a
cache_timeout is given in <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>, that timeout is used;
otherwise, this method is called.</p>
<p>This allows subclasses to change the behavior when sending files based
on the filename.  For example, to set the cache timeout for .js files
to 60 seconds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyFlask</span><span class="p">(</span><span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_send_file_max_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.js&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">60</span>
        <span class="k">return</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="o">.</span><span class="n">get_send_file_max_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Blueprint.has_static_folder">
<tt class="descname">has_static_folder</tt><a class="headerlink" href="#flask.Blueprint.has_static_folder" title="永久链接至目标">¶</a></dt>
<dd><p>This is <cite>True</cite> if the package bound object&#8217;s container has a
folder named <tt class="docutils literal"><span class="pre">'static'</span></tt>.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Blueprint.jinja_loader">
<tt class="descname">jinja_loader</tt><a class="headerlink" href="#flask.Blueprint.jinja_loader" title="永久链接至目标">¶</a></dt>
<dd><p>The Jinja loader for this package bound object.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.make_setup_state">
<tt class="descname">make_setup_state</tt><big>(</big><em>app</em>, <em>options</em>, <em>first_registration=False</em><big>)</big><a class="headerlink" href="#flask.Blueprint.make_setup_state" title="永久链接至目标">¶</a></dt>
<dd><p>Creates an instance of <a class="reference internal" href="index.html#flask.blueprints.BlueprintSetupState" title="flask.blueprints.BlueprintSetupState"><tt class="xref py py-meth docutils literal"><span class="pre">BlueprintSetupState()</span></tt></a>
object that is later passed to the register callback functions.
Subclasses can override this to return a subclass of the setup state.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.open_resource">
<tt class="descname">open_resource</tt><big>(</big><em>resource</em>, <em>mode='rb'</em><big>)</big><a class="headerlink" href="#flask.Blueprint.open_resource" title="永久链接至目标">¶</a></dt>
<dd><p>Opens a resource from the application&#8217;s resource folder.  To see
how this works, consider the following folder structure:</p>
<div class="highlight-python"><pre>/myapplication.py
/schema.sql
/static
    /style.css
/templates
    /layout.html
    /index.html</pre>
</div>
<p>If you want to open the <cite>schema.sql</cite> file you would do the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;schema.sql&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>resource</strong> &#8211; the name of the resource.  To access resources within
subfolders use forward slashes as separator.</li>
<li><strong>mode</strong> &#8211; resource file opening mode, default is &#8216;rb&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.record">
<tt class="descname">record</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#flask.Blueprint.record" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a function that is called when the blueprint is
registered on the application.  This function is called with the
state as argument as returned by the <a class="reference internal" href="index.html#flask.Blueprint.make_setup_state" title="flask.Blueprint.make_setup_state"><tt class="xref py py-meth docutils literal"><span class="pre">make_setup_state()</span></tt></a>
method.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.record_once">
<tt class="descname">record_once</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#flask.Blueprint.record_once" title="永久链接至目标">¶</a></dt>
<dd><p>Works like <a class="reference internal" href="index.html#flask.Blueprint.record" title="flask.Blueprint.record"><tt class="xref py py-meth docutils literal"><span class="pre">record()</span></tt></a> but wraps the function in another
function that will ensure the function is only called once.  If the
blueprint is registered a second time on the application, the
function passed is not called.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.register">
<tt class="descname">register</tt><big>(</big><em>app</em>, <em>options</em>, <em>first_registration=False</em><big>)</big><a class="headerlink" href="#flask.Blueprint.register" title="永久链接至目标">¶</a></dt>
<dd><p>Called by <a class="reference internal" href="index.html#flask.Flask.register_blueprint" title="flask.Flask.register_blueprint"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.register_blueprint()</span></tt></a> to register a blueprint
on the application.  This can be overridden to customize the register
behavior.  Keyword arguments from
<a class="reference internal" href="index.html#flask.Flask.register_blueprint" title="flask.Flask.register_blueprint"><tt class="xref py py-func docutils literal"><span class="pre">register_blueprint()</span></tt></a> are directly forwarded to this
method in the <cite>options</cite> dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.route">
<tt class="descname">route</tt><big>(</big><em>rule</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Blueprint.route" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.route()</span></tt></a> but for a blueprint.  The endpoint for the
<a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> function is prefixed with the name of the blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.send_static_file">
<tt class="descname">send_static_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Blueprint.send_static_file" title="永久链接至目标">¶</a></dt>
<dd><p>Function used internally to send static files from the static
folder to the browser.</p>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.teardown_app_request">
<tt class="descname">teardown_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.teardown_app_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.teardown_request()</span></tt></a> but for a blueprint.  Such a
function is executed when tearing down each request, even if outside of
the blueprint.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.teardown_request">
<tt class="descname">teardown_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.teardown_request" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.teardown_request()</span></tt></a> but for a blueprint.  This
function is only executed when tearing down requests handled by a
function of that blueprint.  Teardown request functions are executed
when the request context is popped, even when no actual request was
performed.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.url_defaults">
<tt class="descname">url_defaults</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.url_defaults" title="永久链接至目标">¶</a></dt>
<dd><p>Callback function for URL defaults for this blueprint.  It&#8217;s called
with the endpoint and values and should update the values passed
in place.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Blueprint.url_value_preprocessor">
<tt class="descname">url_value_preprocessor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Blueprint.url_value_preprocessor" title="永久链接至目标">¶</a></dt>
<dd><p>Registers a function as URL value preprocessor for this
blueprint.  It&#8217;s called before the view functions are called and
can modify the url values provided.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id4">
<h4>进入的请求对象<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.Request">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Request</tt><big>(</big><em>environ</em>, <em>populate_request=True</em>, <em>shallow=False</em><big>)</big><a class="headerlink" href="#flask.Request" title="永久链接至目标">¶</a></dt>
<dd><p>The request object used by default in Flask.  Remembers the
matched endpoint and view arguments.</p>
<p>It is what ends up as <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a>.  If you want to replace
the request object used you can subclass this and set
<a class="reference internal" href="index.html#flask.Flask.request_class" title="flask.Flask.request_class"><tt class="xref py py-attr docutils literal"><span class="pre">request_class</span></tt></a> to your subclass.</p>
<p>The request object is a <a class="reference external" href="http://werkzeug.pocoo.org/docs/wrappers/#werkzeug.wrappers.Request" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a> subclass and
provides all of the attributes Werkzeug defines plus a few Flask
specific ones.</p>
<dl class="attribute">
<dt id="flask.Request.form">
<tt class="descname">form</tt><a class="headerlink" href="#flask.Request.form" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含解析过的从 <cite>POST</cite> 或 <cite>PUT</cite> 请求发送的表单对象的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.MultiDict" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt></a> 。请注意上传的文件不会在这里，而是在
<a class="reference internal" href="index.html#flask.Request.files" title="flask.Request.files"><tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt></a> 属性中。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.args">
<tt class="descname">args</tt><a class="headerlink" href="#flask.Request.args" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含解析过的查询字符串（ URL 中问号后的部分）内容的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.MultiDict" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt></a> 。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.values">
<tt class="descname">values</tt><a class="headerlink" href="#flask.Request.values" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 <a class="reference internal" href="index.html#flask.Request.form" title="flask.Request.form"><tt class="xref py py-attr docutils literal"><span class="pre">form</span></tt></a> 和 <a class="reference internal" href="index.html#flask.Request.args" title="flask.Request.args"><tt class="xref py py-attr docutils literal"><span class="pre">args</span></tt></a> 全部内容的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.CombinedMultiDict" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">CombinedMultiDict</span></tt></a> 。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.cookies">
<tt class="descname">cookies</tt><a class="headerlink" href="#flask.Request.cookies" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含请求中传送的所有 cookie 内容的  <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> 。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.stream">
<tt class="descname">stream</tt><a class="headerlink" href="#flask.Request.stream" title="永久链接至目标">¶</a></dt>
<dd><p>如果表单提交的数据没有以已知的 mimetype 编码，为性能考虑，数据会不经
修改存储在这个流中。大多数情况下，使用可以把数据提供为字符串的
<a class="reference internal" href="index.html#flask.Request.data" title="flask.Request.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a> 是更好的方法。流只返回一次数据。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.headers">
<tt class="descname">headers</tt><a class="headerlink" href="#flask.Request.headers" title="永久链接至目标">¶</a></dt>
<dd><p>进入请求的标头存为一个类似字典的对象。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.data">
<tt class="descname">data</tt><a class="headerlink" href="#flask.Request.data" title="永久链接至目标">¶</a></dt>
<dd><p>如果进入的请求数据是 Flask 不能处理的 mimetype ，数据将作为字符串
存于此。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.files">
<tt class="descname">files</tt><a class="headerlink" href="#flask.Request.files" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 <cite>POST</cite> 和 <cite>PUT</cite> 请求中上传的文件的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.MultiDict" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt></a> 。每个文件存储为
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">FileStorage</span></tt></a> 对象。其基本的行为类似你在 Python 中
见到的标准文件对象，差异在于这个对象有一个
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.save" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法可以把文件存储到文件系统上。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.environ">
<tt class="descname">environ</tt><a class="headerlink" href="#flask.Request.environ" title="永久链接至目标">¶</a></dt>
<dd><p>底层的 WSGI 环境。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.method">
<tt class="descname">method</tt><a class="headerlink" href="#flask.Request.method" title="永久链接至目标">¶</a></dt>
<dd><p>当前请求的 HTTP 方法 (<tt class="docutils literal"><span class="pre">POST</span></tt> ， <tt class="docutils literal"><span class="pre">GET</span></tt> 等等)</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.path">
<tt class="descname">path</tt><a class="headerlink" href="#flask.Request.path" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.Request.script_root">
<tt class="descname">script_root</tt><a class="headerlink" href="#flask.Request.script_root" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.Request.url">
<tt class="descname">url</tt><a class="headerlink" href="#flask.Request.url" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.Request.base_url">
<tt class="descname">base_url</tt><a class="headerlink" href="#flask.Request.base_url" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.Request.url_root">
<tt class="descname">url_root</tt><a class="headerlink" href="#flask.Request.url_root" title="永久链接至目标">¶</a></dt>
<dd><p>提供不同的方式来审视当前的 URL 。想象你的应用监听下面的 URL:</p>
<div class="highlight-python"><pre>http://www.example.com/myapplication</pre>
</div>
<p>并且用户请求下面的 URL:</p>
<div class="highlight-python"><pre>http://www.example.com/myapplication/page.html?x=y</pre>
</div>
<p>这个情况下，上面提到的属性的值会为如下:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>path</cite></td>
<td><tt class="docutils literal"><span class="pre">/page.html</span></tt></td>
</tr>
<tr class="row-even"><td><cite>script_root</cite></td>
<td><tt class="docutils literal"><span class="pre">/myapplication</span></tt></td>
</tr>
<tr class="row-odd"><td><cite>base_url</cite></td>
<td><tt class="docutils literal"><span class="pre">http://www.example.com/myapplication/page.html</span></tt></td>
</tr>
<tr class="row-even"><td><cite>url</cite></td>
<td><tt class="docutils literal"><span class="pre">http://www.example.com/myapplication/page.html?x=y</span></tt></td>
</tr>
<tr class="row-odd"><td><cite>url_root</cite></td>
<td><tt class="docutils literal"><span class="pre">http://www.example.com/myapplication/</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.is_xhr">
<tt class="descname">is_xhr</tt><a class="headerlink" href="#flask.Request.is_xhr" title="永久链接至目标">¶</a></dt>
<dd><p>当请求由 JavaScript 的 <cite>XMLHttpRequest</cite> 触发时，该值为 <cite>True</cite> 。
这只对支持 <tt class="docutils literal"><span class="pre">X-Requested-With</span></tt> 标头并把该标头设置为
<cite>XMLHttpRequest</cite> 的库奏效。这么做的库有 prototype 、 jQuery 以及
Mochikit 等更多。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.blueprint">
<tt class="descname">blueprint</tt><a class="headerlink" href="#flask.Request.blueprint" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the current blueprint</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.endpoint">
<tt class="descname">endpoint</tt><a class="headerlink" href="#flask.Request.endpoint" title="永久链接至目标">¶</a></dt>
<dd><p>The endpoint that matched the request.  This in combination with
<a class="reference internal" href="index.html#flask.Request.view_args" title="flask.Request.view_args"><tt class="xref py py-attr docutils literal"><span class="pre">view_args</span></tt></a> can be used to reconstruct the same or a
modified URL.  If an exception happened when matching, this will
be <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Request.get_json">
<tt class="descname">get_json</tt><big>(</big><em>force=False</em>, <em>silent=False</em>, <em>cache=True</em><big>)</big><a class="headerlink" href="#flask.Request.get_json" title="永久链接至目标">¶</a></dt>
<dd><p>Parses the incoming JSON request data and returns it.  If
parsing fails the <a class="reference internal" href="index.html#flask.Request.on_json_loading_failed" title="flask.Request.on_json_loading_failed"><tt class="xref py py-meth docutils literal"><span class="pre">on_json_loading_failed()</span></tt></a> method on the
request object will be invoked.  By default this function will
only load the json data if the mimetype is <tt class="docutils literal"><span class="pre">application/json</span></tt>
but this can be overriden by the <cite>force</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>force</strong> &#8211; if set to <cite>True</cite> the mimetype is ignored.</li>
<li><strong>silent</strong> &#8211; if set to <cite>False</cite> this method will fail silently
and return <cite>False</cite>.</li>
<li><strong>cache</strong> &#8211; if set to <cite>True</cite> the parsed JSON data is remembered
on the request.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.json">
<tt class="descname">json</tt><a class="headerlink" href="#flask.Request.json" title="永久链接至目标">¶</a></dt>
<dd><p>If the mimetype is <cite>application/json</cite> this will contain the
parsed JSON data.  Otherwise this will be <cite>None</cite>.</p>
<p>The <a class="reference internal" href="index.html#flask.Request.get_json" title="flask.Request.get_json"><tt class="xref py py-meth docutils literal"><span class="pre">get_json()</span></tt></a> method should be used instead.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.max_content_length">
<tt class="descname">max_content_length</tt><a class="headerlink" href="#flask.Request.max_content_length" title="永久链接至目标">¶</a></dt>
<dd><p>Read-only view of the <cite>MAX_CONTENT_LENGTH</cite> config key.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.module">
<tt class="descname">module</tt><a class="headerlink" href="#flask.Request.module" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the current module if the request was dispatched
to an actual module.  This is deprecated functionality, use blueprints
instead.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Request.on_json_loading_failed">
<tt class="descname">on_json_loading_failed</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Request.on_json_loading_failed" title="永久链接至目标">¶</a></dt>
<dd><p>Called if decoding of the JSON data failed.  The return value of
this method is used by <a class="reference internal" href="index.html#flask.Request.get_json" title="flask.Request.get_json"><tt class="xref py py-meth docutils literal"><span class="pre">get_json()</span></tt></a> when an error occurred.  The
default implementation just raises a <tt class="xref py py-class docutils literal"><span class="pre">BadRequest</span></tt> exception.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.10 版更改: </span>Removed buggy previous behavior of generating a random JSON
response.  If you want that behavior back you can trivially
add it by subclassing.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.routing_exception">
<tt class="descname">routing_exception</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Request.routing_exception" title="永久链接至目标">¶</a></dt>
<dd><p>if matching the URL failed, this is the exception that will be
raised / was raised as part of the request handling.  This is
usually a <a class="reference external" href="http://werkzeug.pocoo.org/docs/exceptions/#werkzeug.exceptions.NotFound" title="(在 Werkzeug v0.10)"><tt class="xref py py-exc docutils literal"><span class="pre">NotFound</span></tt></a> exception or
something similar.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.url_rule">
<tt class="descname">url_rule</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Request.url_rule" title="永久链接至目标">¶</a></dt>
<dd><p>the internal URL rule that matched the request.  This can be
useful to inspect which methods are allowed for the URL from
a before/after handler (<tt class="docutils literal"><span class="pre">request.url_rule.methods</span></tt>) etc.</p>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.view_args">
<tt class="descname">view_args</tt><em class="property"> = None</em><a class="headerlink" href="#flask.Request.view_args" title="永久链接至目标">¶</a></dt>
<dd><p>a dict of view arguments that matched the request.  If an exception
happened when matching, this will be <cite>None</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.request">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">request</tt><a class="headerlink" href="#flask.request" title="永久链接至目标">¶</a></dt>
<dd><p>你可以使用全局 <cite>request</cite> 对象访问进入的请求数据。 Flask 处理进入的请求
数据并允许你用这个全局对象访问它。如果你工作在多线程环境，Flask 内部保证
你总会在当前线程上获取正确的数据，</p>
<p>这是一个代理。详情见 <a class="reference internal" href="index.html#notes-on-proxies"><em>留意代理</em></a> 。</p>
<p>请求对象是一个 <a class="reference external" href="http://werkzeug.pocoo.org/docs/wrappers/#werkzeug.wrappers.Request" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a> 子类的实例，提供所有
Werkzeug 定义的属性。这里只对最重要的展示了简要概述。</p>
</dd></dl>

</div>
<div class="section" id="id5">
<h4>响应对象<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.Response">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Response</tt><big>(</big><em>response=None</em>, <em>status=None</em>, <em>headers=None</em>, <em>mimetype=None</em>, <em>content_type=None</em>, <em>direct_passthrough=False</em><big>)</big><a class="headerlink" href="#flask.Response" title="永久链接至目标">¶</a></dt>
<dd><p>The response object that is used by default in Flask.  Works like the
response object from Werkzeug but is set to have an HTML mimetype by
default.  Quite often you don&#8217;t have to create this object yourself because
<a class="reference internal" href="index.html#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">make_response()</span></tt></a> will take care of that for you.</p>
<p>If you want to replace the response object used you can subclass this and
set <a class="reference internal" href="index.html#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> to your subclass.</p>
<dl class="attribute">
<dt id="flask.Response.headers">
<tt class="descname">headers</tt><a class="headerlink" href="#flask.Response.headers" title="永久链接至目标">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">Headers</span></tt> 对象表示响应的标头。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.status">
<tt class="descname">status</tt><a class="headerlink" href="#flask.Response.status" title="永久链接至目标">¶</a></dt>
<dd><p>字符串表示的响应状态。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.status_code">
<tt class="descname">status_code</tt><a class="headerlink" href="#flask.Response.status_code" title="永久链接至目标">¶</a></dt>
<dd><p>整数表示的响应状态。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.data">
<tt class="descname">data</tt><a class="headerlink" href="#flask.Response.data" title="永久链接至目标">¶</a></dt>
<dd><p>A descriptor that calls <tt class="xref py py-meth docutils literal"><span class="pre">get_data()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">set_data()</span></tt>.  This
should not be used and will eventually get deprecated.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.mimetype">
<tt class="descname">mimetype</tt><a class="headerlink" href="#flask.Response.mimetype" title="永久链接至目标">¶</a></dt>
<dd><p>The mimetype (content type without charset etc.)</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.set_cookie">
<tt class="descname">set_cookie</tt><big>(</big><em>key</em>, <em>value=''</em>, <em>max_age=None</em>, <em>expires=None</em>, <em>path='/'</em>, <em>domain=None</em>, <em>secure=None</em>, <em>httponly=False</em><big>)</big><a class="headerlink" href="#flask.Response.set_cookie" title="永久链接至目标">¶</a></dt>
<dd><p>Sets a cookie. The parameters are the same as in the cookie <cite>Morsel</cite>
object in the Python standard library but it accepts unicode data, too.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; the key (name) of the cookie to be set.</li>
<li><strong>value</strong> &#8211; the value of the cookie.</li>
<li><strong>max_age</strong> &#8211; should be a number of seconds, or <cite>None</cite> (default) if
the cookie should last only as long as the client&#8217;s
browser session.</li>
<li><strong>expires</strong> &#8211; should be a <cite>datetime</cite> object or UNIX timestamp.</li>
<li><strong>domain</strong> &#8211; if you want to set a cross-domain cookie.  For example,
<tt class="docutils literal"><span class="pre">domain=&quot;.example.com&quot;</span></tt> will set a cookie that is
readable by the domain <tt class="docutils literal"><span class="pre">www.example.com</span></tt>,
<tt class="docutils literal"><span class="pre">foo.example.com</span></tt> etc.  Otherwise, a cookie will only
be readable by the domain that set it.</li>
<li><strong>path</strong> &#8211; limits the cookie to a given path, per default it will
span the whole domain.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id6">
<h4>会话<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>如果你设置了 <a class="reference internal" href="index.html#flask.Flask.secret_key" title="flask.Flask.secret_key"><tt class="xref py py-attr docutils literal"><span class="pre">Flask.secret_key</span></tt></a> ，你可以在 Flask 应用中使用会话。会话
主要使得在请求见保留信息成为可能。 Flask 的实现方法是使用一个签名的 cookie 。
这样，用户可以查看会话的内容，但是不能修改它，除非用户知道密钥。所以确保密钥
被设置为一个复杂且无法被容易猜测的值。</p>
<p>你可以使用 <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 对象来访问当前的会话:</p>
<dl class="class">
<dt id="flask.session">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">session</tt><a class="headerlink" href="#flask.session" title="永久链接至目标">¶</a></dt>
<dd><p>会话对象很像通常的字典，区别是会话对象会追踪修改。</p>
<p>这是一个代理。更多信息见 <a class="reference internal" href="index.html#notes-on-proxies"><em>留意代理</em></a> 。</p>
<p>下列属性是需要关注的:</p>
<dl class="attribute">
<dt id="flask.session.new">
<tt class="descname">new</tt><a class="headerlink" href="#flask.session.new" title="永久链接至目标">¶</a></dt>
<dd><p>如果会话是新的，该值为 <cite>True</cite> ，否则为 <cite>False</cite> 。</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.session.modified">
<tt class="descname">modified</tt><a class="headerlink" href="#flask.session.modified" title="永久链接至目标">¶</a></dt>
<dd><p>当果会话对象检测到修改，这个值为 <cite>True</cite> 。注意可变结构的修改不会
被自动捕获，这种情况下你需要自行显式地设置这个属性为 <cite>True</cite> 。这
里有 一个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># this change is not picked up because a mutable object (here</span>
<span class="c"># a list) is changed.</span>
<span class="n">session</span><span class="p">[</span><span class="s">&#39;objects&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="c"># so mark it as modified yourself</span>
<span class="n">session</span><span class="o">.</span><span class="n">modified</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.session.permanent">
<tt class="descname">permanent</tt><a class="headerlink" href="#flask.session.permanent" title="永久链接至目标">¶</a></dt>
<dd><p>如果设为 <cite>True</cite> ，会话存活
<a class="reference internal" href="index.html#flask.Flask.permanent_session_lifetime" title="flask.Flask.permanent_session_lifetime"><tt class="xref py py-attr docutils literal"><span class="pre">permanent_session_lifetime</span></tt></a> 秒。默认为 31 天。
如果是 <cite>False</cite> （默认选项），会话会在用户关闭浏览器时删除。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id7">
<h4>会话接口<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
<p>会话接口提供了简单的途径来替换 Flask 正在使用的会话实现。</p>
<dl class="class">
<dt id="flask.sessions.SessionInterface">
<em class="property">class </em><tt class="descclassname">flask.sessions.</tt><tt class="descname">SessionInterface</tt><a class="headerlink" href="#flask.sessions.SessionInterface" title="永久链接至目标">¶</a></dt>
<dd><p>The basic interface you have to implement in order to replace the
default session interface which uses werkzeug&#8217;s securecookie
implementation.  The only methods you have to implement are
<a class="reference internal" href="index.html#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a> and <a class="reference internal" href="index.html#flask.sessions.SessionInterface.save_session" title="flask.sessions.SessionInterface.save_session"><tt class="xref py py-meth docutils literal"><span class="pre">save_session()</span></tt></a>, the others have
useful defaults which you don&#8217;t need to change.</p>
<p>The session object returned by the <a class="reference internal" href="index.html#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a> method has to
provide a dictionary like interface plus the properties and methods
from the <a class="reference internal" href="index.html#flask.sessions.SessionMixin" title="flask.sessions.SessionMixin"><tt class="xref py py-class docutils literal"><span class="pre">SessionMixin</span></tt></a>.  We recommend just subclassing a dict
and adding that mixin:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">SessionMixin</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>If <a class="reference internal" href="index.html#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a> returns <cite>None</cite> Flask will call into
<a class="reference internal" href="index.html#flask.sessions.SessionInterface.make_null_session" title="flask.sessions.SessionInterface.make_null_session"><tt class="xref py py-meth docutils literal"><span class="pre">make_null_session()</span></tt></a> to create a session that acts as replacement
if the session support cannot work because some requirement is not
fulfilled.  The default <a class="reference internal" href="index.html#flask.sessions.NullSession" title="flask.sessions.NullSession"><tt class="xref py py-class docutils literal"><span class="pre">NullSession</span></tt></a> class that is created
will complain that the secret key was not set.</p>
<p>To replace the session interface on an application all you have to do
is to assign <a class="reference internal" href="index.html#flask.Flask.session_interface" title="flask.Flask.session_interface"><tt class="xref py py-attr docutils literal"><span class="pre">flask.Flask.session_interface</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">session_interface</span> <span class="o">=</span> <span class="n">MySessionInterface</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
<dl class="method">
<dt id="flask.sessions.SessionInterface.get_cookie_domain">
<tt class="descname">get_cookie_domain</tt><big>(</big><em>app</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.get_cookie_domain" title="永久链接至目标">¶</a></dt>
<dd><p>Helpful helper method that returns the cookie domain that should
be used for the session cookie if session cookies are used.</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.get_cookie_httponly">
<tt class="descname">get_cookie_httponly</tt><big>(</big><em>app</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.get_cookie_httponly" title="永久链接至目标">¶</a></dt>
<dd><p>Returns True if the session cookie should be httponly.  This
currently just returns the value of the <tt class="docutils literal"><span class="pre">SESSION_COOKIE_HTTPONLY</span></tt>
config var.</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.get_cookie_path">
<tt class="descname">get_cookie_path</tt><big>(</big><em>app</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.get_cookie_path" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the path for which the cookie should be valid.  The
default implementation uses the value from the SESSION_COOKIE_PATH``
config var if it&#8217;s set, and falls back to <tt class="docutils literal"><span class="pre">APPLICATION_ROOT</span></tt> or
uses <tt class="docutils literal"><span class="pre">/</span></tt> if it&#8217;s <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.get_cookie_secure">
<tt class="descname">get_cookie_secure</tt><big>(</big><em>app</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.get_cookie_secure" title="永久链接至目标">¶</a></dt>
<dd><p>Returns True if the cookie should be secure.  This currently
just returns the value of the <tt class="docutils literal"><span class="pre">SESSION_COOKIE_SECURE</span></tt> setting.</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.get_expiration_time">
<tt class="descname">get_expiration_time</tt><big>(</big><em>app</em>, <em>session</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.get_expiration_time" title="永久链接至目标">¶</a></dt>
<dd><p>A helper method that returns an expiration date for the session
or <cite>None</cite> if the session is linked to the browser session.  The
default implementation returns now + the permanent session
lifetime configured on the application.</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.is_null_session">
<tt class="descname">is_null_session</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.is_null_session" title="永久链接至目标">¶</a></dt>
<dd><p>Checks if a given object is a null session.  Null sessions are
not asked to be saved.</p>
<p>This checks if the object is an instance of <a class="reference internal" href="index.html#flask.sessions.SessionInterface.null_session_class" title="flask.sessions.SessionInterface.null_session_class"><tt class="xref py py-attr docutils literal"><span class="pre">null_session_class</span></tt></a>
by default.</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.make_null_session">
<tt class="descname">make_null_session</tt><big>(</big><em>app</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.make_null_session" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a null session which acts as a replacement object if the
real session support could not be loaded due to a configuration
error.  This mainly aids the user experience because the job of the
null session is to still support lookup without complaining but
modifications are answered with a helpful error message of what
failed.</p>
<p>This creates an instance of <a class="reference internal" href="index.html#flask.sessions.SessionInterface.null_session_class" title="flask.sessions.SessionInterface.null_session_class"><tt class="xref py py-attr docutils literal"><span class="pre">null_session_class</span></tt></a> by default.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SessionInterface.null_session_class">
<tt class="descname">null_session_class</tt><a class="headerlink" href="#flask.sessions.SessionInterface.null_session_class" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="index.html#flask.sessions.SessionInterface.make_null_session" title="flask.sessions.SessionInterface.make_null_session"><tt class="xref py py-meth docutils literal"><span class="pre">make_null_session()</span></tt></a> will look here for the class that should
be created when a null session is requested.  Likewise the
<a class="reference internal" href="index.html#flask.sessions.SessionInterface.is_null_session" title="flask.sessions.SessionInterface.is_null_session"><tt class="xref py py-meth docutils literal"><span class="pre">is_null_session()</span></tt></a> method will perform a typecheck against
this type.</p>
<p><a class="reference internal" href="index.html#flask.sessions.NullSession" title="flask.sessions.NullSession"><tt class="xref py py-class docutils literal"><span class="pre">NullSession</span></tt></a> 的别名</p>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.open_session">
<tt class="descname">open_session</tt><big>(</big><em>app</em>, <em>request</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.open_session" title="永久链接至目标">¶</a></dt>
<dd><p>This method has to be implemented and must either return <cite>None</cite>
in case the loading failed because of a configuration error or an
instance of a session object which implements a dictionary like
interface + the methods and attributes on <a class="reference internal" href="index.html#flask.sessions.SessionMixin" title="flask.sessions.SessionMixin"><tt class="xref py py-class docutils literal"><span class="pre">SessionMixin</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SessionInterface.pickle_based">
<tt class="descname">pickle_based</tt><em class="property"> = False</em><a class="headerlink" href="#flask.sessions.SessionInterface.pickle_based" title="永久链接至目标">¶</a></dt>
<dd><p>A flag that indicates if the session interface is pickle based.
This can be used by flask extensions to make a decision in regards
to how to deal with the session object.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.sessions.SessionInterface.save_session">
<tt class="descname">save_session</tt><big>(</big><em>app</em>, <em>session</em>, <em>response</em><big>)</big><a class="headerlink" href="#flask.sessions.SessionInterface.save_session" title="永久链接至目标">¶</a></dt>
<dd><p>This is called for actual sessions returned by <a class="reference internal" href="index.html#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a>
at the end of the request.  This is still called during a request
context so if you absolutely need access to the request you can do
that.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.sessions.SecureCookieSessionInterface">
<em class="property">class </em><tt class="descclassname">flask.sessions.</tt><tt class="descname">SecureCookieSessionInterface</tt><a class="headerlink" href="#flask.sessions.SecureCookieSessionInterface" title="永久链接至目标">¶</a></dt>
<dd><p>The default session interface that stores sessions in signed cookies
through the <tt class="xref py py-mod docutils literal"><span class="pre">itsdangerous</span></tt> module.</p>
<dl class="method">
<dt id="flask.sessions.SecureCookieSessionInterface.digest_method">
<tt class="descname">digest_method</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.sessions.SecureCookieSessionInterface.digest_method" title="永久链接至目标">¶</a></dt>
<dd><p>the hash function to use for the signature.  The default is sha1</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SecureCookieSessionInterface.key_derivation">
<tt class="descname">key_derivation</tt><em class="property"> = 'hmac'</em><a class="headerlink" href="#flask.sessions.SecureCookieSessionInterface.key_derivation" title="永久链接至目标">¶</a></dt>
<dd><p>the name of the itsdangerous supported key derivation.  The default
is hmac.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SecureCookieSessionInterface.salt">
<tt class="descname">salt</tt><em class="property"> = 'cookie-session'</em><a class="headerlink" href="#flask.sessions.SecureCookieSessionInterface.salt" title="永久链接至目标">¶</a></dt>
<dd><p>the salt that should be applied on top of the secret key for the
signing of cookie based sessions.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SecureCookieSessionInterface.serializer">
<tt class="descname">serializer</tt><em class="property"> = &lt;flask.sessions.TaggedJSONSerializer object at 0x30016d0&gt;</em><a class="headerlink" href="#flask.sessions.SecureCookieSessionInterface.serializer" title="永久链接至目标">¶</a></dt>
<dd><p>A python serializer for the payload.  The default is a compact
JSON derived serializer with support for some extra Python types
such as datetime objects or tuples.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SecureCookieSessionInterface.session_class">
<tt class="descname">session_class</tt><a class="headerlink" href="#flask.sessions.SecureCookieSessionInterface.session_class" title="永久链接至目标">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">SecureCookieSession</span></tt> 的别名</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.sessions.NullSession">
<em class="property">class </em><tt class="descclassname">flask.sessions.</tt><tt class="descname">NullSession</tt><big>(</big><em>initial=None</em><big>)</big><a class="headerlink" href="#flask.sessions.NullSession" title="永久链接至目标">¶</a></dt>
<dd><p>Class used to generate nicer error messages if sessions are not
available.  Will still allow read-only access to the empty session
but fail on setting.</p>
</dd></dl>

<dl class="class">
<dt id="flask.sessions.SessionMixin">
<em class="property">class </em><tt class="descclassname">flask.sessions.</tt><tt class="descname">SessionMixin</tt><a class="headerlink" href="#flask.sessions.SessionMixin" title="永久链接至目标">¶</a></dt>
<dd><p>Expands a basic dictionary with an accessors that are expected
by Flask extensions and users for the session.</p>
<dl class="attribute">
<dt id="flask.sessions.SessionMixin.modified">
<tt class="descname">modified</tt><em class="property"> = True</em><a class="headerlink" href="#flask.sessions.SessionMixin.modified" title="永久链接至目标">¶</a></dt>
<dd><p>for some backends this will always be <cite>True</cite>, but some backends will
default this to false and detect changes in the dictionary for as
long as changes do not happen on mutable structures in the session.
The default mixin implementation just hardcodes <cite>True</cite> in.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SessionMixin.new">
<tt class="descname">new</tt><em class="property"> = False</em><a class="headerlink" href="#flask.sessions.SessionMixin.new" title="永久链接至目标">¶</a></dt>
<dd><p>some session backends can tell you if a session is new, but that is
not necessarily guaranteed.  Use with caution.  The default mixin
implementation just hardcodes <cite>False</cite> in.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.SessionMixin.permanent">
<tt class="descname">permanent</tt><a class="headerlink" href="#flask.sessions.SessionMixin.permanent" title="永久链接至目标">¶</a></dt>
<dd><p>this reflects the <tt class="docutils literal"><span class="pre">'_permanent'</span></tt> key in the dict.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="flask.sessions.session_json_serializer">
<tt class="descclassname">flask.sessions.</tt><tt class="descname">session_json_serializer</tt><a class="headerlink" href="#flask.sessions.session_json_serializer" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<div class="admonition-notice admonition">
<p class="first admonition-title">Notice</p>
<p class="last"><tt class="docutils literal"><span class="pre">PERMANENT_SESSION_LIFETIME</span></tt> 配置键从 Flask 0.8 开始可以是一个整数。
你可以自己计算值，或用应用上的
<a class="reference internal" href="index.html#flask.Flask.permanent_session_lifetime" title="flask.Flask.permanent_session_lifetime"><tt class="xref py py-attr docutils literal"><span class="pre">permanent_session_lifetime</span></tt></a> 属性来自动转换结果为
一个整数。</p>
</div>
</div>
<div class="section" id="id8">
<h4>测试客户端<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.testing.FlaskClient">
<em class="property">class </em><tt class="descclassname">flask.testing.</tt><tt class="descname">FlaskClient</tt><big>(</big><em>application</em>, <em>response_wrapper=None</em>, <em>use_cookies=True</em>, <em>allow_subdomain_redirects=False</em><big>)</big><a class="headerlink" href="#flask.testing.FlaskClient" title="永久链接至目标">¶</a></dt>
<dd><p>Works like a regular Werkzeug test client but has some knowledge about
how Flask works to defer the cleanup of the request context stack to the
end of a with body when used in a with statement.  For general information
about how to use this class refer to <a class="reference external" href="http://werkzeug.pocoo.org/docs/test/#werkzeug.test.Client" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">werkzeug.test.Client</span></tt></a>.</p>
<p>Basic usage is outlined in the <a class="reference internal" href="index.html#testing"><em>测试 Flask 应用</em></a> chapter.</p>
<dl class="method">
<dt id="flask.testing.FlaskClient.session_transaction">
<tt class="descname">session_transaction</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#flask.testing.FlaskClient.session_transaction" title="永久链接至目标">¶</a></dt>
<dd><p>When used in combination with a with statement this opens a
session transaction.  This can be used to modify the session that
the test client uses.  Once the with block is left the session is
stored back.</p>
<blockquote>
<div><dl class="docutils">
<dt>with client.session_transaction() as session:</dt>
<dd>session[&#8216;value&#8217;] = 42</dd>
</dl>
</div></blockquote>
<p>Internally this is implemented by going through a temporary test
request context and since session handling could depend on
request variables this function accepts the same arguments as
<a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> which are directly
passed through.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id9">
<h4>应用全局变量<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>只在一个请求内，从一个函数到另一个函数共享数据，全局变量并不够好。因为这
在线程环境下行不通。 Flask 提供了一个特殊的对象来确保只在活动的请求中
有效，并且每个请求都返回不同的值。一言蔽之：它做正确的事情，如同它对
<a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 和 <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 做的那样。</p>
<dl class="data">
<dt id="flask.g">
<tt class="descclassname">flask.</tt><tt class="descname">g</tt><a class="headerlink" href="#flask.g" title="永久链接至目标">¶</a></dt>
<dd><p>在这上存储你任何你想要存储的。例如一个数据库连接或者当前登入的用户。</p>
<p>从 Flask 0.10 起，对象 g 存储在应用上下文中而不再是请求上下文中，这
意味着即使在应用上下文中它也是可访问的而不是只能在请求上下文中。在
结合 <a class="reference internal" href="index.html#faking-resources"><em>伪造资源和上下文</em></a> 模式使用来测试时这尤为有用。</p>
<p>另外，在 0.10 中你可以使用 <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> 方法来获取一个属性或者如果这
个属性没设置的话将得到 <cite>None</cite> (或者第二个参数)。
这两种用法现在是没有区别的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flask</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>现在也能在 g 对象上使用 <tt class="docutils literal"><span class="pre">in</span></tt> 运算符来确定它是否有某个属性，并且它
将使用 <cite>yield</cite> 关键字来生成这样一个可迭代的包含所有keys的生成器。</p>
<p>这是一个代理。详情见 <a class="reference internal" href="index.html#notes-on-proxies"><em>留意代理</em></a> 。</p>
</dd></dl>

</div>
<div class="section" id="id10">
<h4>有用的函数和类<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<dl class="data">
<dt id="flask.current_app">
<tt class="descclassname">flask.</tt><tt class="descname">current_app</tt><a class="headerlink" href="#flask.current_app" title="永久链接至目标">¶</a></dt>
<dd><p>指向正在处理请求的应用。这对于想要支持同时运行多个应用的扩展有用。
它由应用上下文驱动，而不是请求上下文，所以你可以用
<a class="reference internal" href="index.html#flask.Flask.app_context" title="flask.Flask.app_context"><tt class="xref py py-meth docutils literal"><span class="pre">app_context()</span></tt></a> 方法
修改这个代理的值。</p>
<p>这是一个代理。详情见 <a class="reference internal" href="index.html#notes-on-proxies"><em>留意代理</em></a> 。</p>
</dd></dl>

<dl class="function">
<dt id="flask.has_request_context">
<tt class="descclassname">flask.</tt><tt class="descname">has_request_context</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.has_request_context" title="永久链接至目标">¶</a></dt>
<dd><p>If you have code that wants to test if a request context is there or
not this function can be used.  For instance, you may want to take advantage
of request information if the request object is available, but fail
silently if it is unavailable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">remote_addr</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
        <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">has_request_context</span><span class="p">():</span>
            <span class="n">remote_addr</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">remote_addr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remote_addr</span> <span class="o">=</span> <span class="n">remote_addr</span>
</pre></div>
</div>
<p>Alternatively you can also just test any of the context bound objects
(such as <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> or <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> for truthness):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">remote_addr</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
        <span class="k">if</span> <span class="n">remote_addr</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">request</span><span class="p">:</span>
            <span class="n">remote_addr</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">remote_addr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remote_addr</span> <span class="o">=</span> <span class="n">remote_addr</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="flask.has_app_context">
<tt class="descclassname">flask.</tt><tt class="descname">has_app_context</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.has_app_context" title="永久链接至目标">¶</a></dt>
<dd><p>Works like <a class="reference internal" href="index.html#flask.has_request_context" title="flask.has_request_context"><tt class="xref py py-func docutils literal"><span class="pre">has_request_context()</span></tt></a> but for the application
context.  You can also just do a boolean check on the
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> object instead.</p>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="flask.url_for">
<tt class="descclassname">flask.</tt><tt class="descname">url_for</tt><big>(</big><em>endpoint</em>, <em>**values</em><big>)</big><a class="headerlink" href="#flask.url_for" title="永久链接至目标">¶</a></dt>
<dd><p>Generates a URL to the given endpoint with the method provided.</p>
<p>Variable arguments that are unknown to the target endpoint are appended
to the generated URL as query arguments.  If the value of a query argument
is <cite>None</cite>, the whole pair is skipped.  In case blueprints are active
you can shortcut references to the same blueprint by prefixing the
local endpoint with a dot (<tt class="docutils literal"><span class="pre">.</span></tt>).</p>
<p>This will reference the index function local to the current blueprint:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_for</span><span class="p">(</span><span class="s">&#39;.index&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information, head over to the <a class="reference internal" href="index.html#url-building"><em>Quickstart</em></a>.</p>
<p>To integrate applications, <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> has a hook to intercept URL build
errors through <tt class="xref py py-attr docutils literal"><span class="pre">Flask.build_error_handler</span></tt>.  The <cite>url_for</cite> function
results in a <tt class="xref py py-exc docutils literal"><span class="pre">BuildError</span></tt> when the current app does
not have a URL for the given endpoint and values.  When it does, the
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> calls its <tt class="xref py py-attr docutils literal"><span class="pre">build_error_handler</span></tt> if
it is not <cite>None</cite>, which can return a string to use as the result of
<cite>url_for</cite> (instead of <cite>url_for</cite>&#8216;s default to raise the
<tt class="xref py py-exc docutils literal"><span class="pre">BuildError</span></tt> exception) or re-raise the exception.
An example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">external_url_handler</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="o">**</span><span class="n">values</span><span class="p">):</span>
    <span class="s">&quot;Looks up an external URL when `url_for` cannot build a URL.&quot;</span>
    <span class="c"># This is an example of hooking the build_error_handler.</span>
    <span class="c"># Here, lookup_url is some utility function you&#39;ve built</span>
    <span class="c"># which looks up the endpoint in some external URL registry.</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">lookup_url</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="o">**</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">url</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># External lookup did not have a URL.</span>
        <span class="c"># Re-raise the BuildError, in context of original traceback.</span>
        <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">exc_value</span> <span class="ow">is</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">tb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>
    <span class="c"># url_for will use this result, instead of raising BuildError.</span>
    <span class="k">return</span> <span class="n">url</span>

<span class="n">app</span><span class="o">.</span><span class="n">build_error_handler</span> <span class="o">=</span> <span class="n">external_url_handler</span>
</pre></div>
</div>
<p>Here, <cite>error</cite> is the instance of <tt class="xref py py-exc docutils literal"><span class="pre">BuildError</span></tt>, and
<cite>endpoint</cite> and <cite>**values</cite> are the arguments passed into <cite>url_for</cite>.  Note
that this is for building URLs outside the current application, and not for
handling 404 NotFound errors.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能: </span>The <cite>_scheme</cite> parameter was added.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能: </span>The <cite>_anchor</cite> and <cite>_method</cite> parameters were added.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能: </span>Calls <tt class="xref py py-meth docutils literal"><span class="pre">Flask.handle_build_error()</span></tt> on
<tt class="xref py py-exc docutils literal"><span class="pre">BuildError</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>endpoint</strong> &#8211; the endpoint of the URL (name of the function)</li>
<li><strong>values</strong> &#8211; the variable arguments of the URL rule</li>
<li><strong>_external</strong> &#8211; if set to <cite>True</cite>, an absolute URL is generated. Server
address can be changed via <cite>SERVER_NAME</cite> configuration variable which
defaults to <cite>localhost</cite>.</li>
<li><strong>_scheme</strong> &#8211; a string specifying the desired URL scheme. The <cite>_external</cite>
parameter must be set to <cite>True</cite> or a <cite>ValueError</cite> is raised.</li>
<li><strong>_anchor</strong> &#8211; if provided this is added as anchor to the URL.</li>
<li><strong>_method</strong> &#8211; if provided this explicitly specifies an HTTP method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.abort">
<tt class="descclassname">flask.</tt><tt class="descname">abort</tt><big>(</big><em>code</em><big>)</big><a class="headerlink" href="#flask.abort" title="永久链接至目标">¶</a></dt>
<dd><p>抛出一个给定状态代码的 <a class="reference external" href="http://werkzeug.pocoo.org/docs/exceptions/#werkzeug.exceptions.HTTPException" title="(在 Werkzeug v0.10)"><tt class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></tt></a> 。
例如想要用一个页面未找到异常来终止请求，你可以调用 <tt class="docutils literal"><span class="pre">abort(404)</span></tt> 。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>code</strong> &#8211; the HTTP error code.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.redirect">
<tt class="descclassname">flask.</tt><tt class="descname">redirect</tt><big>(</big><em>location</em>, <em>code=302</em><big>)</big><a class="headerlink" href="#flask.redirect" title="永久链接至目标">¶</a></dt>
<dd><p>Return a response object (a WSGI application) that, if called,
redirects the client to the target location.  Supported codes are 301,
302, 303, 305, and 307.  300 is not supported because it&#8217;s not a real
redirect and 304 because it&#8217;s the answer for a request with a request
with defined If-Modified-Since headers.</p>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能: </span>The location can now be a unicode string that is encoded using
the <tt class="xref py py-func docutils literal"><span class="pre">iri_to_uri()</span></tt> function.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>location</strong> &#8211; the location the response should redirect to.</li>
<li><strong>code</strong> &#8211; the redirect status code. defaults to 302.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.make_response">
<tt class="descclassname">flask.</tt><tt class="descname">make_response</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#flask.make_response" title="永久链接至目标">¶</a></dt>
<dd><p>Sometimes it is necessary to set additional headers in a view.  Because
views do not have to return response objects but can return a value that
is converted into a response object by Flask itself, it becomes tricky to
add headers to it.  This function can be called instead of using a return
and you will get a response object which you can use to attach headers.</p>
<p>If view looked like this and you want to add a new header:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;index.html&#39;</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>You can now do something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s">&#39;index.html&#39;</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">42</span><span class="p">))</span>
    <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;X-Parachutes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;parachutes are cool&#39;</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p>This function accepts the very same arguments you can return from a
view function.  This for example creates a response with a 404 error
code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">response</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s">&#39;not_found.html&#39;</span><span class="p">),</span> <span class="mi">404</span><span class="p">)</span>
</pre></div>
</div>
<p>The other use case of this function is to force the return value of a
view function into a response which is helpful with view
decorators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">response</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">view_function</span><span class="p">())</span>
<span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;X-Parachutes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;parachutes are cool&#39;</span>
</pre></div>
</div>
<p>Internally this function does the following things:</p>
<ul class="simple">
<li>if no arguments are passed, it creates a new response argument</li>
<li>if one argument is passed, <a class="reference internal" href="index.html#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.make_response()</span></tt></a>
is invoked with it.</li>
<li>if more than one argument is passed, the arguments are passed
to the <a class="reference internal" href="index.html#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.make_response()</span></tt></a> function as tuple.</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="flask.send_file">
<tt class="descclassname">flask.</tt><tt class="descname">send_file</tt><big>(</big><em>filename_or_fp</em>, <em>mimetype=None</em>, <em>as_attachment=False</em>, <em>attachment_filename=None</em>, <em>add_etags=True</em>, <em>cache_timeout=None</em>, <em>conditional=False</em><big>)</big><a class="headerlink" href="#flask.send_file" title="永久链接至目标">¶</a></dt>
<dd><p>Sends the contents of a file to the client.  This will use the
most efficient method available and configured.  By default it will
try to use the WSGI server&#8217;s file_wrapper support.  Alternatively
you can set the application&#8217;s <a class="reference internal" href="index.html#flask.Flask.use_x_sendfile" title="flask.Flask.use_x_sendfile"><tt class="xref py py-attr docutils literal"><span class="pre">use_x_sendfile</span></tt></a> attribute
to <tt class="docutils literal"><span class="pre">True</span></tt> to directly emit an <cite>X-Sendfile</cite> header.  This however
requires support of the underlying webserver for <cite>X-Sendfile</cite>.</p>
<p>By default it will try to guess the mimetype for you, but you can
also explicitly provide one.  For extra security you probably want
to send certain files as attachment (HTML for instance).  The mimetype
guessing requires a <cite>filename</cite> or an <cite>attachment_filename</cite> to be
provided.</p>
<p>Please never pass filenames to this function from user sources without
checking them first.  Something like this is usually sufficient to
avoid security problems:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="s">&#39;..&#39;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">):</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.2 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能: </span>The <cite>add_etags</cite>, <cite>cache_timeout</cite> and <cite>conditional</cite> parameters were
added.  The default behavior is now to attach etags.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.7 版更改: </span>mimetype guessing and etag support for file objects was
deprecated because it was unreliable.  Pass a filename if you are
able to, otherwise attach an etag yourself.  This functionality
will be removed in Flask 1.0</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span>cache_timeout pulls its default from application config, when None.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename_or_fp</strong> &#8211; the filename of the file to send.  This is
relative to the <tt class="xref py py-attr docutils literal"><span class="pre">root_path</span></tt> if a
relative path is specified.
Alternatively a file object might be provided
in which case <cite>X-Sendfile</cite> might not work and
fall back to the traditional method.  Make sure
that the file pointer is positioned at the start
of data to send before calling <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>.</li>
<li><strong>mimetype</strong> &#8211; the mimetype of the file if provided, otherwise
auto detection happens.</li>
<li><strong>as_attachment</strong> &#8211; set to <cite>True</cite> if you want to send this file with
a <tt class="docutils literal"><span class="pre">Content-Disposition:</span> <span class="pre">attachment</span></tt> header.</li>
<li><strong>attachment_filename</strong> &#8211; the filename for the attachment if it
differs from the file&#8217;s filename.</li>
<li><strong>add_etags</strong> &#8211; set to <cite>False</cite> to disable attaching of etags.</li>
<li><strong>conditional</strong> &#8211; set to <cite>True</cite> to enable conditional responses.</li>
<li><strong>cache_timeout</strong> &#8211; the timeout in seconds for the headers. When <cite>None</cite>
(default), this value is set by
<a class="reference internal" href="index.html#flask.Flask.get_send_file_max_age" title="flask.Flask.get_send_file_max_age"><tt class="xref py py-meth docutils literal"><span class="pre">get_send_file_max_age()</span></tt></a> of
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.send_from_directory">
<tt class="descclassname">flask.</tt><tt class="descname">send_from_directory</tt><big>(</big><em>directory</em>, <em>filename</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.send_from_directory" title="永久链接至目标">¶</a></dt>
<dd><p>Send a file from a given directory with <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>.  This
is a secure way to quickly expose static files from an upload folder
or something similar.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/uploads/&lt;path:filename&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">download_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">send_from_directory</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;UPLOAD_FOLDER&#39;</span><span class="p">],</span>
                               <span class="n">filename</span><span class="p">,</span> <span class="n">as_attachment</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-sending-files-and-performance admonition">
<p class="first admonition-title">Sending files and Performance</p>
<p class="last">It is strongly recommended to activate either <cite>X-Sendfile</cite> support in
your webserver or (if no authentication happens) to tell the webserver
to serve files for the given path on its own without calling into the
web application for improved performance.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.5 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>directory</strong> &#8211; the directory where all the files are stored.</li>
<li><strong>filename</strong> &#8211; the filename relative to that directory to
download.</li>
<li><strong>options</strong> &#8211; optional keyword arguments that are directly
forwarded to <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.safe_join">
<tt class="descclassname">flask.</tt><tt class="descname">safe_join</tt><big>(</big><em>directory</em>, <em>filename</em><big>)</big><a class="headerlink" href="#flask.safe_join" title="永久链接至目标">¶</a></dt>
<dd><p>Safely join <cite>directory</cite> and <cite>filename</cite>.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/wiki/&lt;path:filename&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">wiki_page</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">safe_join</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;WIKI_FOLDER&#39;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read and process the file content...</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>directory</strong> &#8211; the base directory.</li>
<li><strong>filename</strong> &#8211; the untrusted filename relative to that directory.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">NotFound</span></tt> if the resulting path
would fall out of <cite>directory</cite>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.escape">
<tt class="descclassname">flask.</tt><tt class="descname">escape</tt><big>(</big><em>s</em><big>)</big> &rarr; markup<a class="headerlink" href="#flask.escape" title="永久链接至目标">¶</a></dt>
<dd><p>Convert the characters &amp;, &lt;, &gt;, &#8216;, and &#8221; in string s to HTML-safe
sequences.  Use this if you need to display text that might contain
such characters in HTML.  Marks return value as markup string.</p>
</dd></dl>

<dl class="class">
<dt id="flask.Markup">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Markup</tt><a class="headerlink" href="#flask.Markup" title="永久链接至目标">¶</a></dt>
<dd><p>Marks a string as being safe for inclusion in HTML/XML output without
needing to be escaped.  This implements the <cite>__html__</cite> interface a couple
of frameworks and web applications use.  <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> is a direct
subclass of <cite>unicode</cite> and provides all the methods of <cite>unicode</cite> just that
it escapes arguments passed and always returns <cite>Markup</cite>.</p>
<p>The <cite>escape</cite> function returns markup objects so that double escaping can&#8217;t
happen.</p>
<p>The constructor of the <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> class can be used for three
different things:  When passed an unicode object it&#8217;s assumed to be safe,
when passed an object with an HTML representation (has an <cite>__html__</cite>
method) that representation is used, otherwise the object passed is
converted into a unicode string and then assumed to be safe:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;</span><span class="p">)</span>
<span class="go">Markup(u&#39;Hello &lt;em&gt;World&lt;/em&gt;!&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span> <span class="k">def</span> <span class="nf">__html__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">return</span> <span class="s">&#39;&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;&#39;</span>
<span class="gp">... </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="n">Foo</span><span class="p">())</span>
<span class="go">Markup(u&#39;&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;&#39;)</span>
</pre></div>
</div>
<p>If you want object passed being always treated as unsafe you can use the
<a class="reference internal" href="index.html#flask.escape" title="flask.escape"><tt class="xref py py-meth docutils literal"><span class="pre">escape()</span></tt></a> classmethod to create a <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s">&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;</span><span class="p">)</span>
<span class="go">Markup(u&#39;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&#39;)</span>
</pre></div>
</div>
<p>Operations on a markup string are markup aware which means that all
arguments are passed through the <a class="reference internal" href="index.html#flask.escape" title="flask.escape"><tt class="xref py py-func docutils literal"><span class="pre">escape()</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;em&gt;</span><span class="si">%s</span><span class="s">&lt;/em&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">%</span> <span class="s">&quot;foo &amp; bar&quot;</span>
<span class="go">Markup(u&#39;&lt;em&gt;foo &amp;amp; bar&lt;/em&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strong</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;strong&gt;</span><span class="si">%(text)s</span><span class="s">&lt;/strong&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strong</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;text&#39;</span><span class="p">:</span> <span class="s">&#39;&lt;blink&gt;hacker here&lt;/blink&gt;&#39;</span><span class="p">}</span>
<span class="go">Markup(u&#39;&lt;strong&gt;&amp;lt;blink&amp;gt;hacker here&amp;lt;/blink&amp;gt;&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;em&gt;Hello&lt;/em&gt; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;&lt;foo&gt;&quot;</span>
<span class="go">Markup(u&#39;&lt;em&gt;Hello&lt;/em&gt; &amp;lt;foo&amp;gt;&#39;)</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="flask.Markup.escape">
<em class="property">classmethod </em><tt class="descname">escape</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#flask.Markup.escape" title="永久链接至目标">¶</a></dt>
<dd><p>Escape the string.  Works like <a class="reference internal" href="index.html#flask.escape" title="flask.escape"><tt class="xref py py-func docutils literal"><span class="pre">escape()</span></tt></a> with the difference
that for subclasses of <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> this function would return the
correct subclass.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Markup.striptags">
<tt class="descname">striptags</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Markup.striptags" title="永久链接至目标">¶</a></dt>
<dd><p>Unescape markup into an text_type string and strip all tags.  This
also resolves known HTML4 and XHTML entities.  Whitespace is
normalized to one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Main &amp;raquo;  &lt;em&gt;About&lt;/em&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Main \xbb About&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Markup.unescape">
<tt class="descname">unescape</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Markup.unescape" title="永久链接至目标">¶</a></dt>
<dd><p>Unescape markup again into an text_type string.  This also resolves
known HTML4 and XHTML entities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Main &amp;raquo; &lt;em&gt;About&lt;/em&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unescape</span><span class="p">()</span>
<span class="go">u&#39;Main \xbb &lt;em&gt;About&lt;/em&gt;&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id11">
<h4>消息闪现<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt id="flask.flash">
<tt class="descclassname">flask.</tt><tt class="descname">flash</tt><big>(</big><em>message</em>, <em>category='message'</em><big>)</big><a class="headerlink" href="#flask.flash" title="永久链接至目标">¶</a></dt>
<dd><p>Flashes a message to the next request.  In order to remove the
flashed message from the session and to display it to the user,
the template has to call <a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.3 版更改: </span><cite>category</cite> parameter added.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>message</strong> &#8211; the message to be flashed.</li>
<li><strong>category</strong> &#8211; the category for the message.  The following values
are recommended: <tt class="docutils literal"><span class="pre">'message'</span></tt> for any kind of message,
<tt class="docutils literal"><span class="pre">'error'</span></tt> for errors, <tt class="docutils literal"><span class="pre">'info'</span></tt> for information
messages and <tt class="docutils literal"><span class="pre">'warning'</span></tt> for warnings.  However any
kind of string can be used as category.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.get_flashed_messages">
<tt class="descclassname">flask.</tt><tt class="descname">get_flashed_messages</tt><big>(</big><em>with_categories=False</em>, <em>category_filter=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#flask.get_flashed_messages" title="永久链接至目标">¶</a></dt>
<dd><p>Pulls all flashed messages from the session and returns them.
Further calls in the same request to the function will return
the same messages.  By default just the messages are returned,
but when <cite>with_categories</cite> is set to <cite>True</cite>, the return value will
be a list of tuples in the form <tt class="docutils literal"><span class="pre">(category,</span> <span class="pre">message)</span></tt> instead.</p>
<p>Filter the flashed messages to one or more categories by providing those
categories in <cite>category_filter</cite>.  This allows rendering categories in
separate html blocks.  The <cite>with_categories</cite> and <cite>category_filter</cite>
arguments are distinct:</p>
<ul class="simple">
<li><cite>with_categories</cite> controls whether categories are returned with message
text (<cite>True</cite> gives a tuple, where <cite>False</cite> gives just the message text).</li>
<li><cite>category_filter</cite> filters the messages down to only those matching the
provided categories.</li>
</ul>
<p>See <a class="reference internal" href="index.html#message-flashing-pattern"><em>消息闪现</em></a> for examples.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.3 版更改: </span><cite>with_categories</cite> parameter added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span><cite>category_filter</cite> parameter added.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>with_categories</strong> &#8211; set to <cite>True</cite> to also receive categories.</li>
<li><strong>category_filter</strong> &#8211; whitelist of categories to limit return values</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-flask.json">
<span id="json"></span><h4>JSON 支持<a class="headerlink" href="#module-flask.json" title="永久链接至标题">¶</a></h4>
<p>Flask 使用 <tt class="docutils literal"><span class="pre">simplejson</span></tt> 来实现JSON。自从 simplejson 既在标准库中提供也在
Flask 的拓展中提供。Flask将首先尝试自带的simplejson，如果失败了就使用标准
库中的json模块。除此之外，为了更容易定制它还会委托访问当前应用的JSON的编码
器和解码器。</p>
<p>所以首先不要这样用：</p>
<blockquote>
<div><dl class="docutils">
<dt>try:</dt>
<dd>import simplejson as json</dd>
<dt>except ImportError:</dt>
<dd>import json</dd>
</dl>
</div></blockquote>
<p>你可以这样</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">json</span>
</pre></div>
</div>
<p>For usage examples, read the <a class="reference external" href="http://docs.python.org/dev/library/json.html#module-json" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">json</span></tt></a> documentation.
关于更多的用法，请阅读标准库中的 <a class="reference external" href="http://docs.python.org/dev/library/json.html#module-json" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">json</span></tt></a> 文档。下面的拓展已经默认被集成
到了标准库中JSON模块里：</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">datetime</span></tt> 对象被序列化为 <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> 字符串。</li>
<li>任何带有 <tt class="docutils literal"><span class="pre">__html__</span></tt> 方法(比如 <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a>)将在序列化的时候
调用这个方法然后返回的字符串将会被序列化为字符串。</li>
</ol>
<p>这个 <tt class="xref py py-func docutils literal"><span class="pre">htmlsafe_dumps()</span></tt> 方法也能在 Jinja2 的过滤器中使用，名字为
<tt class="docutils literal"><span class="pre">|tojson</span></tt> 。请注意在 <cite>script</cite> 标签内部的内容将不会被转义，所以如果你想在
<cite>script</cite> 内部使用的话请确保它是不可用的通过 <tt class="docutils literal"><span class="pre">|safe</span></tt> 来转义，除非你正在
使用 Flask 0.10，如下：</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
    <span class="nx">doSomethingWith</span><span class="p">(</span><span class="cp">{{</span> <span class="nv">user.username</span><span class="o">|</span><span class="nf">tojson</span><span class="o">|</span><span class="nf">safe</span> <span class="cp">}}</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
</div>
<dl class="function">
<dt id="flask.json.jsonify">
<tt class="descclassname">flask.json.</tt><tt class="descname">jsonify</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.json.jsonify" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="index.html#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> with the JSON representation of
the given arguments with an <cite>application/json</cite> mimetype.  The arguments
to this function are the same as to the <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> constructor.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">jsonify</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/_get_current_user&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_current_user</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
                   <span class="n">email</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span>
                   <span class="nb">id</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<p>This will send a JSON response like this to the browser:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
    <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;admin&quot;</span><span class="p">,</span>
    <span class="s">&quot;email&quot;</span><span class="p">:</span> <span class="s">&quot;admin@localhost&quot;</span><span class="p">,</span>
    <span class="s">&quot;id&quot;</span><span class="p">:</span> <span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For security reasons only objects are supported toplevel.  For more
information about this, have a look at <a class="reference internal" href="index.html#json-security"><em>JSON 安全</em></a>.</p>
<p>This function&#8217;s response will be pretty printed if it was not requested
with <tt class="docutils literal"><span class="pre">X-Requested-With:</span> <span class="pre">XMLHttpRequest</span></tt> to simplify debugging unless
the <tt class="docutils literal"><span class="pre">JSONIFY_PRETTYPRINT_REGULAR</span></tt> config parameter is set to false.</p>
<div class="versionadded">
<p><span class="versionmodified">0.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="flask.json.dumps">
<tt class="descclassname">flask.json.</tt><tt class="descname">dumps</tt><big>(</big><em>obj</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.json.dumps" title="永久链接至目标">¶</a></dt>
<dd><p>Serialize <tt class="docutils literal"><span class="pre">obj</span></tt> to a JSON formatted <tt class="docutils literal"><span class="pre">str</span></tt> by using the application&#8217;s
configured encoder (<a class="reference internal" href="index.html#flask.Flask.json_encoder" title="flask.Flask.json_encoder"><tt class="xref py py-attr docutils literal"><span class="pre">json_encoder</span></tt></a>) if there is an
application on the stack.</p>
<p>This function can return <tt class="docutils literal"><span class="pre">unicode</span></tt> strings or ascii-only bytestrings by
default which coerce into unicode strings automatically.  That behavior by
default is controlled by the <tt class="docutils literal"><span class="pre">JSON_AS_ASCII</span></tt> configuration variable
and can be overriden by the simplejson <tt class="docutils literal"><span class="pre">ensure_ascii</span></tt> parameter.</p>
</dd></dl>

<dl class="function">
<dt id="flask.json.dump">
<tt class="descclassname">flask.json.</tt><tt class="descname">dump</tt><big>(</big><em>obj</em>, <em>fp</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.json.dump" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.json.dumps" title="flask.json.dumps"><tt class="xref py py-func docutils literal"><span class="pre">dumps()</span></tt></a> but writes into a file object.</p>
</dd></dl>

<dl class="function">
<dt id="flask.json.loads">
<tt class="descclassname">flask.json.</tt><tt class="descname">loads</tt><big>(</big><em>s</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.json.loads" title="永久链接至目标">¶</a></dt>
<dd><p>Unserialize a JSON object from a string <tt class="docutils literal"><span class="pre">s</span></tt> by using the application&#8217;s
configured decoder (<a class="reference internal" href="index.html#flask.Flask.json_decoder" title="flask.Flask.json_decoder"><tt class="xref py py-attr docutils literal"><span class="pre">json_decoder</span></tt></a>) if there is an
application on the stack.</p>
</dd></dl>

<dl class="function">
<dt id="flask.json.load">
<tt class="descclassname">flask.json.</tt><tt class="descname">load</tt><big>(</big><em>fp</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.json.load" title="永久链接至目标">¶</a></dt>
<dd><p>Like <a class="reference internal" href="index.html#flask.json.loads" title="flask.json.loads"><tt class="xref py py-func docutils literal"><span class="pre">loads()</span></tt></a> but reads from a file object.</p>
</dd></dl>

<dl class="class">
<dt id="flask.json.JSONEncoder">
<em class="property">class </em><tt class="descclassname">flask.json.</tt><tt class="descname">JSONEncoder</tt><big>(</big><em>skipkeys=False</em>, <em>ensure_ascii=True</em>, <em>check_circular=True</em>, <em>allow_nan=True</em>, <em>sort_keys=False</em>, <em>indent=None</em>, <em>separators=None</em>, <em>encoding='utf-8'</em>, <em>default=None</em>, <em>use_decimal=True</em>, <em>namedtuple_as_object=True</em>, <em>tuple_as_array=True</em><big>)</big><a class="headerlink" href="#flask.json.JSONEncoder" title="永久链接至目标">¶</a></dt>
<dd><p>The default Flask JSON encoder.  This one extends the default simplejson
encoder by also supporting <tt class="docutils literal"><span class="pre">datetime</span></tt> objects, <tt class="docutils literal"><span class="pre">UUID</span></tt> as well as
<tt class="docutils literal"><span class="pre">Markup</span></tt> objects which are serialized as RFC 822 datetime strings (same
as the HTTP date format).  In order to support more data types override the
<a class="reference internal" href="index.html#flask.json.JSONEncoder.default" title="flask.json.JSONEncoder.default"><tt class="xref py py-meth docutils literal"><span class="pre">default()</span></tt></a> method.</p>
<dl class="method">
<dt id="flask.json.JSONEncoder.default">
<tt class="descname">default</tt><big>(</big><em>o</em><big>)</big><a class="headerlink" href="#flask.json.JSONEncoder.default" title="永久链接至目标">¶</a></dt>
<dd><p>Implement this method in a subclass such that it returns a
serializable object for <tt class="docutils literal"><span class="pre">o</span></tt>, or calls the base implementation (to
raise a <tt class="docutils literal"><span class="pre">TypeError</span></tt>).</p>
<p>For example, to support arbitrary iterators, you could implement
default like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">JSONEncoder</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.json.JSONDecoder">
<em class="property">class </em><tt class="descclassname">flask.json.</tt><tt class="descname">JSONDecoder</tt><big>(</big><em>encoding=None</em>, <em>object_hook=None</em>, <em>parse_float=None</em>, <em>parse_int=None</em>, <em>parse_constant=None</em>, <em>strict=True</em>, <em>object_pairs_hook=None</em><big>)</big><a class="headerlink" href="#flask.json.JSONDecoder" title="永久链接至目标">¶</a></dt>
<dd><p>The default JSON decoder.  This one does not change the behavior from
the default simplejson encoder.  Consult the <a class="reference external" href="http://docs.python.org/dev/library/json.html#module-json" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">json</span></tt></a> documentation
for more information.  This decoder is not only used for the load
functions of this module but also <a class="reference internal" href="index.html#flask.Request" title="flask.Request"><tt class="xref py py-attr docutils literal"><span class="pre">Request</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="id12">
<h4>模板渲染<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt id="flask.render_template">
<tt class="descclassname">flask.</tt><tt class="descname">render_template</tt><big>(</big><em>template_name_or_list</em>, <em>**context</em><big>)</big><a class="headerlink" href="#flask.render_template" title="永久链接至目标">¶</a></dt>
<dd><p>Renders a template from the template folder with the given
context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>template_name_or_list</strong> &#8211; the name of the template to be
rendered, or an iterable with template names
the first one existing will be rendered</li>
<li><strong>context</strong> &#8211; the variables that should be available in the
context of the template.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.render_template_string">
<tt class="descclassname">flask.</tt><tt class="descname">render_template_string</tt><big>(</big><em>source</em>, <em>**context</em><big>)</big><a class="headerlink" href="#flask.render_template_string" title="永久链接至目标">¶</a></dt>
<dd><p>Renders a template from the given template source string
with the given context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> &#8211; the sourcecode of the template to be
rendered</li>
<li><strong>context</strong> &#8211; the variables that should be available in the
context of the template.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.get_template_attribute">
<tt class="descclassname">flask.</tt><tt class="descname">get_template_attribute</tt><big>(</big><em>template_name</em>, <em>attribute</em><big>)</big><a class="headerlink" href="#flask.get_template_attribute" title="永久链接至目标">¶</a></dt>
<dd><p>Loads a macro (or variable) a template exports.  This can be used to
invoke a macro from within Python code.  If you for example have a
template named <cite>_cider.html</cite> with the following contents:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">macro</span> <span class="nv">hello</span><span class="o">(</span><span class="nv">name</span><span class="o">)</span> <span class="cp">%}</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="cp">{%</span> <span class="k">endmacro</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>You can access this from Python code like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hello</span> <span class="o">=</span> <span class="n">get_template_attribute</span><span class="p">(</span><span class="s">&#39;_cider.html&#39;</span><span class="p">,</span> <span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="k">return</span> <span class="n">hello</span><span class="p">(</span><span class="s">&#39;World&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.2 新版功能.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>template_name</strong> &#8211; the name of the template</li>
<li><strong>attribute</strong> &#8211; the name of the variable of macro to access</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id13">
<h4>配置<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.Config">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Config</tt><big>(</big><em>root_path</em>, <em>defaults=None</em><big>)</big><a class="headerlink" href="#flask.Config" title="永久链接至目标">¶</a></dt>
<dd><p>Works exactly like a dict but provides ways to fill it from files
or special dictionaries.  There are two common patterns to populate the
config.</p>
<p>Either you can fill the config from a config file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="s">&#39;yourconfig.cfg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or alternatively you can define the configuration options in the
module that calls <a class="reference internal" href="index.html#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a> or provide an import path to
a module that should be loaded.  It is also possible to tell it to
use the same module and with that provide the configuration values
just before the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="s">&#39;development key&#39;</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases (loading from any Python file or loading from modules),
only uppercase keys are added to the config.  This makes it possible to use
lowercase values in the config file for temporary values that are not added
to the config or to define the config keys in the same file that implements
the application.</p>
<p>Probably the most interesting way to load configurations is from an
environment variable pointing to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_envvar</span><span class="p">(</span><span class="s">&#39;YOURAPPLICATION_SETTINGS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case before launching the application you have to set this
environment variable to the file you want to use.  On Linux and OS X
use the export statement:</p>
<div class="highlight-python"><pre>export YOURAPPLICATION_SETTINGS='/path/to/config/file'</pre>
</div>
<p>On windows use <cite>set</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>root_path</strong> &#8211; path to which files are read relative from.  When the
config object is created by the application, this is
the application&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">root_path</span></tt>.</li>
<li><strong>defaults</strong> &#8211; an optional dictionary of default values</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flask.Config.from_envvar">
<tt class="descname">from_envvar</tt><big>(</big><em>variable_name</em>, <em>silent=False</em><big>)</big><a class="headerlink" href="#flask.Config.from_envvar" title="永久链接至目标">¶</a></dt>
<dd><p>Loads a configuration from an environment variable pointing to
a configuration file.  This is basically just a shortcut with nicer
error messages for this line of code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;YOURAPPLICATION_SETTINGS&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>variable_name</strong> &#8211; name of the environment variable</li>
<li><strong>silent</strong> &#8211; set to <cite>True</cite> if you want silent failure for missing
files.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">bool. <cite>True</cite> if able to load config, <cite>False</cite> otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Config.from_object">
<tt class="descname">from_object</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#flask.Config.from_object" title="永久链接至目标">¶</a></dt>
<dd><p>Updates the values from the given object.  An object can be of one
of the following two types:</p>
<ul class="simple">
<li>a string: in this case the object with that name will be imported</li>
<li>an actual object reference: that object is used directly</li>
</ul>
<p>Objects are usually either modules or classes.</p>
<p>Just the uppercase variables in that object are stored in the config.
Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;yourapplication.default_config&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">default_config</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">default_config</span><span class="p">)</span>
</pre></div>
</div>
<p>You should not use this function to load the actual configuration but
rather configuration defaults.  The actual config should be loaded
with <a class="reference internal" href="index.html#flask.Config.from_pyfile" title="flask.Config.from_pyfile"><tt class="xref py py-meth docutils literal"><span class="pre">from_pyfile()</span></tt></a> and ideally from a location not within the
package because the package might be installed system wide.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>obj</strong> &#8211; an import name or object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Config.from_pyfile">
<tt class="descname">from_pyfile</tt><big>(</big><em>filename</em>, <em>silent=False</em><big>)</big><a class="headerlink" href="#flask.Config.from_pyfile" title="永久链接至目标">¶</a></dt>
<dd><p>Updates the values in the config from a Python file.  This function
behaves as if the file was imported as module with the
<a class="reference internal" href="index.html#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; the filename of the config.  This can either be an
absolute filename or a filename relative to the
root path.</li>
<li><strong>silent</strong> &#8211; set to <cite>True</cite> if you want silent failure for missing
files.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能: </span><cite>silent</cite> parameter.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id14">
<h4>扩展<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<dl class="data">
<dt id="flask.flask.ext">
<tt class="descclassname">flask.</tt><tt class="descname">ext</tt><a class="headerlink" href="#flask.flask.ext" title="永久链接至目标">¶</a></dt>
<dd><p>这个模块重定向导入模块到 Flask 扩展。它在 0.8 中被加入，作为导入 Flask
扩展的权威方式，并使得我们在发布扩展时能有更大的灵活性。</p>
<p>如果你想使用名为 “Flask-Foo” 的扩展，你应按照下述从 <a class="reference internal" href="index.html#flask.flask.ext" title="flask.flask.ext"><tt class="xref py py-data docutils literal"><span class="pre">ext</span></tt></a>
导入:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask.ext</span> <span class="kn">import</span> <span class="n">foo</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="id15">
<h4>流的辅助函数<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt id="flask.stream_with_context">
<tt class="descclassname">flask.</tt><tt class="descname">stream_with_context</tt><big>(</big><em>generator_or_function</em><big>)</big><a class="headerlink" href="#flask.stream_with_context" title="永久链接至目标">¶</a></dt>
<dd><p>Request contexts disappear when the response is started on the server.
This is done for efficiency reasons and to make it less likely to encounter
memory leaks with badly written WSGI middlewares.  The downside is that if
you are using streamed responses, the generator cannot access request bound
information any more.</p>
<p>This function however can help you keep the context around for longer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">stream_with_context</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">Response</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/stream&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">streamed_response</span><span class="p">():</span>
    <span class="nd">@stream_with_context</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">():</span>
        <span class="k">yield</span> <span class="s">&#39;Hello &#39;</span>
        <span class="k">yield</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">yield</span> <span class="s">&#39;!&#39;</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">generate</span><span class="p">())</span>
</pre></div>
</div>
<p>Alternatively it can also be used around a specific generator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">stream_with_context</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">Response</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/stream&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">streamed_response</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">():</span>
        <span class="k">yield</span> <span class="s">&#39;Hello &#39;</span>
        <span class="k">yield</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">yield</span> <span class="s">&#39;!&#39;</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">stream_with_context</span><span class="p">(</span><span class="n">generate</span><span class="p">()))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="id16">
<h4>有用的内构件<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<dl class="class">
<dt id="flask.ctx.RequestContext">
<em class="property">class </em><tt class="descclassname">flask.ctx.</tt><tt class="descname">RequestContext</tt><big>(</big><em>app</em>, <em>environ</em>, <em>request=None</em><big>)</big><a class="headerlink" href="#flask.ctx.RequestContext" title="永久链接至目标">¶</a></dt>
<dd><p>The request context contains all request relevant information.  It is
created at the beginning of the request and pushed to the
<cite>_request_ctx_stack</cite> and removed at the end of it.  It will create the
URL adapter and request object for the WSGI environment provided.</p>
<p>Do not attempt to use this class directly, instead use
<a class="reference internal" href="index.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> and
<a class="reference internal" href="index.html#flask.Flask.request_context" title="flask.Flask.request_context"><tt class="xref py py-meth docutils literal"><span class="pre">request_context()</span></tt></a> to create this object.</p>
<p>When the request context is popped, it will evaluate all the
functions registered on the application for teardown execution
(<a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a>).</p>
<p>The request context is automatically popped at the end of the request
for you.  In debug mode the request context is kept around if
exceptions happen so that interactive debuggers have a chance to
introspect the data.  With 0.4 this can also be forced for requests
that did not fail and outside of <cite>DEBUG</cite> mode.  By setting
<tt class="docutils literal"><span class="pre">'flask._preserve_context'</span></tt> to <cite>True</cite> on the WSGI environment the
context will not pop itself at the end of the request.  This is used by
the <a class="reference internal" href="index.html#flask.Flask.test_client" title="flask.Flask.test_client"><tt class="xref py py-meth docutils literal"><span class="pre">test_client()</span></tt></a> for example to implement the
deferred cleanup functionality.</p>
<p>You might find this helpful for unittests where you need the
information from the context local around for a little longer.  Make
sure to properly <tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt> the stack yourself in
that situation, otherwise your unittests will leak memory.</p>
<dl class="method">
<dt id="flask.ctx.RequestContext.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.ctx.RequestContext.copy" title="永久链接至目标">¶</a></dt>
<dd><p>Creates a copy of this request context with the same request object.
This can be used to move a request context to a different greenlet.
Because the actual request object is the same this cannot be used to
move a request context to a different thread unless access to the
request object is locked.</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.ctx.RequestContext.match_request">
<tt class="descname">match_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.ctx.RequestContext.match_request" title="永久链接至目标">¶</a></dt>
<dd><p>Can be overridden by a subclass to hook into the matching
of the request.</p>
</dd></dl>

<dl class="method">
<dt id="flask.ctx.RequestContext.pop">
<tt class="descname">pop</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#flask.ctx.RequestContext.pop" title="永久链接至目标">¶</a></dt>
<dd><p>Pops the request context and unbinds it by doing that.  This will
also trigger the execution of functions registered by the
<a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> decorator.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span>Added the <cite>exc</cite> argument.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.ctx.RequestContext.push">
<tt class="descname">push</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.ctx.RequestContext.push" title="永久链接至目标">¶</a></dt>
<dd><p>Binds the request context to the current context.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="flask._request_ctx_stack">
<tt class="descclassname">flask.</tt><tt class="descname">_request_ctx_stack</tt><a class="headerlink" href="#flask._request_ctx_stack" title="永久链接至目标">¶</a></dt>
<dd><p>Flask 中使用的所有的上下文局部对象，都由内部的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/local/#werkzeug.local.LocalStack" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">LocalStack</span></tt></a> 实现。这是一个带文档的实例，并且可以
在扩展和应用的代码中使用，但一般来说是不推荐这样使用的。</p>
<p>下面的属性在栈的每层上都存在:</p>
<dl class="docutils">
<dt><cite>app</cite></dt>
<dd>活动的 Flask 应用</dd>
<dt><cite>url_adapter</cite></dt>
<dd>用于匹配请求的 URL 适配器</dd>
<dt><cite>request</cite></dt>
<dd>当前的请求对象</dd>
<dt><cite>session</cite></dt>
<dd>当前的会话对象</dd>
<dt><cite>g</cite></dt>
<dd>拥有 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">flask.g</span></tt></a> 对象上全部属性的对象</dd>
<dt><cite>flashes</cite></dt>
<dd>闪现消息的内部缓存</dd>
</dl>
<p>用法示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">_request_ctx_stack</span>

<span class="k">def</span> <span class="nf">get_session</span><span class="p">():</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">top</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ctx</span><span class="o">.</span><span class="n">session</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="flask.ctx.AppContext">
<em class="property">class </em><tt class="descclassname">flask.ctx.</tt><tt class="descname">AppContext</tt><big>(</big><em>app</em><big>)</big><a class="headerlink" href="#flask.ctx.AppContext" title="永久链接至目标">¶</a></dt>
<dd><p>The application context binds an application object implicitly
to the current thread or greenlet, similar to how the
<tt class="xref py py-class docutils literal"><span class="pre">RequestContext</span></tt> binds request information.  The application
context is also implicitly created if a request context is created
but the application is not on top of the individual application
context.</p>
<dl class="method">
<dt id="flask.ctx.AppContext.pop">
<tt class="descname">pop</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#flask.ctx.AppContext.pop" title="永久链接至目标">¶</a></dt>
<dd><p>Pops the app context.</p>
</dd></dl>

<dl class="method">
<dt id="flask.ctx.AppContext.push">
<tt class="descname">push</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.ctx.AppContext.push" title="永久链接至目标">¶</a></dt>
<dd><p>Binds the app context to the current context.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="flask._app_ctx_stack">
<tt class="descclassname">flask.</tt><tt class="descname">_app_ctx_stack</tt><a class="headerlink" href="#flask._app_ctx_stack" title="永久链接至目标">¶</a></dt>
<dd><p>类似请求上下文，但是只跟应用绑定。主要为扩展提供数据存储。</p>
<div class="versionadded">
<p><span class="versionmodified">0.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="flask.blueprints.BlueprintSetupState">
<em class="property">class </em><tt class="descclassname">flask.blueprints.</tt><tt class="descname">BlueprintSetupState</tt><big>(</big><em>blueprint</em>, <em>app</em>, <em>options</em>, <em>first_registration</em><big>)</big><a class="headerlink" href="#flask.blueprints.BlueprintSetupState" title="永久链接至目标">¶</a></dt>
<dd><p>Temporary holder object for registering a blueprint with the
application.  An instance of this class is created by the
<a class="reference internal" href="index.html#flask.Blueprint.make_setup_state" title="flask.Blueprint.make_setup_state"><tt class="xref py py-meth docutils literal"><span class="pre">make_setup_state()</span></tt></a> method and later passed
to all register callback functions.</p>
<dl class="method">
<dt id="flask.blueprints.BlueprintSetupState.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>rule</em>, <em>endpoint=None</em>, <em>view_func=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.add_url_rule" title="永久链接至目标">¶</a></dt>
<dd><p>A helper method to register a rule (and optionally a view function)
to the application.  The endpoint is automatically prefixed with the
blueprint&#8217;s name.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.app">
<tt class="descname">app</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.app" title="永久链接至目标">¶</a></dt>
<dd><p>a reference to the current application</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.blueprint">
<tt class="descname">blueprint</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.blueprint" title="永久链接至目标">¶</a></dt>
<dd><p>a reference to the blueprint that created this setup state.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.first_registration">
<tt class="descname">first_registration</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.first_registration" title="永久链接至目标">¶</a></dt>
<dd><p>as blueprints can be registered multiple times with the
application and not everything wants to be registered
multiple times on it, this attribute can be used to figure
out if the blueprint was registered in the past already.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.options">
<tt class="descname">options</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.options" title="永久链接至目标">¶</a></dt>
<dd><p>a dictionary with all options that were passed to the
<a class="reference internal" href="index.html#flask.Flask.register_blueprint" title="flask.Flask.register_blueprint"><tt class="xref py py-meth docutils literal"><span class="pre">register_blueprint()</span></tt></a> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.subdomain">
<tt class="descname">subdomain</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.subdomain" title="永久链接至目标">¶</a></dt>
<dd><p>The subdomain that the blueprint should be active for, <cite>None</cite>
otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.url_defaults">
<tt class="descname">url_defaults</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.url_defaults" title="永久链接至目标">¶</a></dt>
<dd><p>A dictionary with URL defaults that is added to each and every
URL that was defined with the blueprint.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.blueprints.BlueprintSetupState.url_prefix">
<tt class="descname">url_prefix</tt><em class="property"> = None</em><a class="headerlink" href="#flask.blueprints.BlueprintSetupState.url_prefix" title="永久链接至目标">¶</a></dt>
<dd><p>The prefix that should be used for all URLs defined on the
blueprint.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id17">
<h4>信号<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.6 新版功能.</span></p>
</div>
<dl class="data">
<dt id="flask.signals_available">
<tt class="descclassname">flask.</tt><tt class="descname">signals_available</tt><a class="headerlink" href="#flask.signals_available" title="永久链接至目标">¶</a></dt>
<dd><p>当信号系统可用时为 <cite>True</cite> ，即在 <a class="reference external" href="http://pypi.python.org/pypi/blinker">blinker</a> 已经被安装的情况下。</p>
</dd></dl>

<dl class="data">
<dt id="flask.template_rendered">
<tt class="descclassname">flask.</tt><tt class="descname">template_rendered</tt><a class="headerlink" href="#flask.template_rendered" title="永久链接至目标">¶</a></dt>
<dd><p>当一个模板成功渲染的时候，这个信号会发出。这个信号带着一个模板实例
<cite>template</cite> 和为一个字典的上下文（叫 <cite>context</cite> ）两个参数被调用。</p>
</dd></dl>

<dl class="data">
<dt id="flask.request_started">
<tt class="descclassname">flask.</tt><tt class="descname">request_started</tt><a class="headerlink" href="#flask.request_started" title="永久链接至目标">¶</a></dt>
<dd><p>这个信号在处建立请求上下文之外的任何请求处理开始前发送。因为请求上下文
这个信号在任何对请求的处理前发送，但是正好是在请求的上下文被建立的时候。
因为请求上下文已经被约束了，用户可以使用 <a class="reference internal" href="index.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 之类的标
准全局代理访问请求对象。</p>
</dd></dl>

<dl class="data">
<dt id="flask.request_finished">
<tt class="descclassname">flask.</tt><tt class="descname">request_finished</tt><a class="headerlink" href="#flask.request_finished" title="永久链接至目标">¶</a></dt>
<dd><p>这个信号恰好在请求发送给客户端之前发送。它传递名为 <cite>response</cite> 的将被发送
的响应。</p>
</dd></dl>

<dl class="data">
<dt id="flask.got_request_exception">
<tt class="descclassname">flask.</tt><tt class="descname">got_request_exception</tt><a class="headerlink" href="#flask.got_request_exception" title="永久链接至目标">¶</a></dt>
<dd><p>这个信号在请求处理中抛出异常时发送。它在标准异常处理生效 <em>之前</em> ，甚至是
在不会处理异常的调试模式下也是如此。这个异常会被将作为一个 <cite>exception</cite>
传递到用户那。</p>
</dd></dl>

<dl class="data">
<dt id="flask.request_tearing_down">
<tt class="descclassname">flask.</tt><tt class="descname">request_tearing_down</tt><a class="headerlink" href="#flask.request_tearing_down" title="永久链接至目标">¶</a></dt>
<dd><p>这个信号在请求销毁时发送。它总会被调用，即使发生异常。在这种清况下，造
成teardown的异常将会通过一个叫 <cite>exc</cite> 的关键字参数传递出来。</p>
<div class="versionchanged">
<p><span class="versionmodified">在 0.9 版更改: </span>添加了 <cite>exc</cite> 参数</p>
</div>
</dd></dl>

<dl class="data">
<dt id="flask.appcontext_tearing_down">
<tt class="descclassname">flask.</tt><tt class="descname">appcontext_tearing_down</tt><a class="headerlink" href="#flask.appcontext_tearing_down" title="永久链接至目标">¶</a></dt>
<dd><p>这个信号在应用上下文销毁时发送。它总会被调用，即使发生异常。在这种清况
下，造成teardown的异常将会通过一个叫 <cite>exc</cite> 的关键字参数传递出来。发送
者是application对象。</p>
</dd></dl>

<dl class="data">
<dt id="flask.appcontext_pushed">
<tt class="descclassname">flask.</tt><tt class="descname">appcontext_pushed</tt><a class="headerlink" href="#flask.appcontext_pushed" title="永久链接至目标">¶</a></dt>
<dd><p>当应用上下文被压入栈后会发送这个信号。发送者是application对象</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="flask.appcontext_popped">
<tt class="descclassname">flask.</tt><tt class="descname">appcontext_popped</tt><a class="headerlink" href="#flask.appcontext_popped" title="永久链接至目标">¶</a></dt>
<dd><p>当应用上下文出栈后会发送这个信号。发送者是application对象。这常常与
<a class="reference internal" href="index.html#flask.appcontext_tearing_down" title="flask.appcontext_tearing_down"><tt class="xref py py-data docutils literal"><span class="pre">appcontext_tearing_down</span></tt></a> 这个信号一致。</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="flask.message_flashed">
<tt class="descclassname">flask.</tt><tt class="descname">message_flashed</tt><a class="headerlink" href="#flask.message_flashed" title="永久链接至目标">¶</a></dt>
<dd><p>This signal is sent when the application is flashing a message.
The messages is sent as <cite>message</cite> keyword argument and the
当闪现一个消息时会发送这个信号。消息的内容将以 <cite>message</cite> 关键字参数
发送，而消息的种类则是 <cite>category</cite> 关键字参数。</p>
<div class="versionadded">
<p><span class="versionmodified">0.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="flask.signals.Namespace">
<em class="property">class </em><tt class="descclassname">flask.signals.</tt><tt class="descname">Namespace</tt><a class="headerlink" href="#flask.signals.Namespace" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference external" href="http://discorporate.us/projects/Blinker/docs/1.1/api.html#blinker.base.Namespace" title="(在 Blinker v1.1)"><tt class="xref py py-class docutils literal"><span class="pre">blinker.base.Namespace</span></tt></a> 的别名，如果 blinker 可用的话。否则，
是一个发送伪信号的伪造的类。这个类对想提供与 Flask 相同的备用系统的
Flask扩展有用。</p>
<dl class="method">
<dt id="flask.signals.Namespace.signal">
<tt class="descname">signal</tt><big>(</big><em>name</em>, <em>doc=None</em><big>)</big><a class="headerlink" href="#flask.signals.Namespace.signal" title="永久链接至目标">¶</a></dt>
<dd><p>在此命名空间中创建一个新信号，如果 blinker 可用的话。否则返回一个
带有不做任何事的发送方法，任何操作都会（包括连接）报错为
<a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#RuntimeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> 的伪信号。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id18">
<h4>基于类的视图<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">0.7 新版功能.</span></p>
</div>
<dl class="class">
<dt id="flask.views.View">
<em class="property">class </em><tt class="descclassname">flask.views.</tt><tt class="descname">View</tt><a class="headerlink" href="#flask.views.View" title="永久链接至目标">¶</a></dt>
<dd><p>Alternative way to use view functions.  A subclass has to implement
<tt class="xref py py-meth docutils literal"><span class="pre">dispatch_request()</span></tt> which is called with the view arguments from
the URL routing system.  If <tt class="xref py py-attr docutils literal"><span class="pre">methods</span></tt> is provided the methods
do not have to be passed to the <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a>
method explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">dispatch_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;Hello </span><span class="si">%s</span><span class="s">!&#39;</span> <span class="o">%</span> <span class="n">name</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">MyView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;myview&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>When you want to decorate a pluggable view you will have to either do that
when the view function is created (by wrapping the return value of
<tt class="xref py py-meth docutils literal"><span class="pre">as_view()</span></tt>) or you can use the <tt class="xref py py-attr docutils literal"><span class="pre">decorators</span></tt> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SecretView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">]</span>
    <span class="n">decorators</span> <span class="o">=</span> <span class="p">[</span><span class="n">superuser_required</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">dispatch_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The decorators stored in the decorators list are applied one after another
when the view function is created.  Note that you can <em>not</em> use the class
based decorators since those would decorate the view class and not the
generated view function!</p>
<dl class="classmethod">
<dt id="flask.views.View.as_view">
<em class="property">classmethod </em><tt class="descname">as_view</tt><big>(</big><em>name</em>, <em>*class_args</em>, <em>**class_kwargs</em><big>)</big><a class="headerlink" href="#flask.views.View.as_view" title="永久链接至目标">¶</a></dt>
<dd><p>Converts the class into an actual view function that can be used
with the routing system.  Internally this generates a function on the
fly which will instantiate the <tt class="xref py py-class docutils literal"><span class="pre">View</span></tt> on each request and call
the <tt class="xref py py-meth docutils literal"><span class="pre">dispatch_request()</span></tt> method on it.</p>
<p>The arguments passed to <tt class="xref py py-meth docutils literal"><span class="pre">as_view()</span></tt> are forwarded to the
constructor of the class.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.views.View.decorators">
<tt class="descname">decorators</tt><em class="property"> = []</em><a class="headerlink" href="#flask.views.View.decorators" title="永久链接至目标">¶</a></dt>
<dd><p>The canonical way to decorate class-based views is to decorate the
return value of as_view().  However since this moves parts of the
logic from the class declaration to the place where it&#8217;s hooked
into the routing system.</p>
<p>You can place one or more decorators in this list and whenever the
view function is created the result is automatically decorated.</p>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.views.View.dispatch_request">
<tt class="descname">dispatch_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.views.View.dispatch_request" title="永久链接至目标">¶</a></dt>
<dd><p>Subclasses have to override this method to implement the
actual view function code.  This method is called with all
the arguments from the URL rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.views.View.methods">
<tt class="descname">methods</tt><em class="property"> = None</em><a class="headerlink" href="#flask.views.View.methods" title="永久链接至目标">¶</a></dt>
<dd><p>A for which methods this pluggable view can handle.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.views.MethodView">
<em class="property">class </em><tt class="descclassname">flask.views.</tt><tt class="descname">MethodView</tt><a class="headerlink" href="#flask.views.MethodView" title="永久链接至目标">¶</a></dt>
<dd><p>Like a regular class-based view but that dispatches requests to
particular methods.  For instance if you implement a method called
<tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> it means you will response to <tt class="docutils literal"><span class="pre">'GET'</span></tt> requests and
the <tt class="xref py py-meth docutils literal"><span class="pre">dispatch_request()</span></tt> implementation will automatically
forward your request to that.  Also <tt class="xref py py-attr docutils literal"><span class="pre">options</span></tt> is set for you
automatically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CounterAPI</span><span class="p">(</span><span class="n">MethodView</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;counter&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">session</span><span class="p">[</span><span class="s">&#39;counter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;counter&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="s">&#39;OK&#39;</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/counter&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">CounterAPI</span><span class="o">.</span><span class="n">as_view</span><span class="p">(</span><span class="s">&#39;counter&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="url">
<span id="url-route-registrations"></span><h4>URL 路由注册<a class="headerlink" href="#url" title="永久链接至标题">¶</a></h4>
<p>在路由系统中定义规则可以的方法可以概括为三种:</p>
<ol class="arabic simple">
<li>使用 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.route()</span></tt></a> 装饰器</li>
<li>使用 <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.add_url_rule()</span></tt></a> 函数</li>
<li>直接访问暴露为 <a class="reference internal" href="index.html#flask.Flask.url_map" title="flask.Flask.url_map"><tt class="xref py py-attr docutils literal"><span class="pre">flask.Flask.url_map</span></tt></a> 的底层的 Werkzeug 路由系统</li>
</ol>
<p>路由中的变量部分可以用尖括号指定（ <tt class="docutils literal"><span class="pre">/user/&lt;username&gt;</span></tt>）。默认情况下，URL
中的变量部分接受任何不带斜线的字符串，而 <tt class="docutils literal"><span class="pre">&lt;converter:name&gt;</span></tt> 也可以指定不
同的转换器。</p>
<p>变量部分以关键字参数传递给视图函数。</p>
<p>下面的转换器是可用的:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>string</cite></td>
<td>接受任何不带斜线的字符串（默认的转换器）</td>
</tr>
<tr class="row-even"><td><cite>int</cite></td>
<td>接受整数</td>
</tr>
<tr class="row-odd"><td><cite>float</cite></td>
<td>同 <cite>int</cite> ，但是接受浮点数</td>
</tr>
<tr class="row-even"><td><cite>path</cite></td>
<td>和默认的相似，但也接受斜线</td>
</tr>
</tbody>
</table>
<p>这里是一些例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>需要注意的一个重要细节是 Flask 处理结尾斜线的方式。你可以应用下面两个
规则来保证 URL 的唯一:</p>
<ol class="arabic simple">
<li>如果规则以斜线结尾，当用户以不带斜线的形式请求，用户被自动重定向到
带有结尾斜线的相同页面。</li>
<li>如果规则结尾没有斜线，当用户以带斜线的形式请求，会抛出一个 404 not
found 。</li>
</ol>
<p>这与 web 服务器处理静态文件的方式一致。这使得安全地使用相对链接地址成为
可能。</p>
<p>你可以为同一个函数定义多个规则。无论如何，他们也要唯一。也可以给定默认值。
这里给出一个接受可选页面的 URL 定义:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/users/&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;page&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/users/page/&lt;int:page&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_users</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>这指定了 <tt class="docutils literal"><span class="pre">/users/</span></tt> 为第一页的 URL ，<tt class="docutils literal"><span class="pre">/users/page/N</span></tt> 为第 <cite>N</cite> 页的 URL 。</p>
<p>以下是 <a class="reference internal" href="index.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 和 <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a>
接受的参数。两者唯一的区别是，带有路由参数的视图函数用装饰器定义，而不是
<cite>view_func</cite> 参数。</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>rule</cite></td>
<td>URL 规则的字符串</td>
</tr>
<tr class="row-even"><td><cite>endpoint</cite></td>
<td>注册的 URL 规则的末端。如果没有显式地规定，Flask 本身假设
末端的名称是视图函数的名称，。</td>
</tr>
<tr class="row-odd"><td><cite>view_func</cite></td>
<td>当请求呈递到给定的末端时调用的函数。如果没有提供，可以
在用在 <a class="reference internal" href="index.html#flask.Flask.view_functions" title="flask.Flask.view_functions"><tt class="xref py py-attr docutils literal"><span class="pre">view_functions</span></tt></a> 字典中以末端
作为键名存储，来在之后设定函数。</td>
</tr>
<tr class="row-even"><td><cite>defaults</cite></td>
<td>规则默认值的字典。上面的示例介绍了默认值如何工作。</td>
</tr>
<tr class="row-odd"><td><cite>subdomain</cite></td>
<td>当使用子域名匹配的时候，为子域名设定规则。如果没有给定，假
定为默认的子域名。</td>
</tr>
<tr class="row-even"><td><cite>**options</cite></td>
<td>这些选项会被推送给底层的 <a class="reference external" href="http://werkzeug.pocoo.org/docs/routing/#werkzeug.routing.Rule" title="(在 Werkzeug v0.10)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a>
对象。一个 Werkzeug 的变化是 method 选项的处理。methods是
这个规则被限定的方法列表（ <cite>GET</cite> ， <cite>POST</cite> 等等）。默认情
况下，规则只监听 <cite>GET</cite> （也隐式地监听 <cite>HEAD</cite> ）。从 Flask
0.6 开始，<cite>OPTIONS</cite> 也被隐式地加入，并且做标准的请求处理。
它们需要作为关键字参数来给定。</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="view-func-options">
<span id="id19"></span><h4>视图函数选项<a class="headerlink" href="#view-func-options" title="永久链接至标题">¶</a></h4>
<p>对内部使用，视图函数可以有一些属性，附加到视图函数通常没有控制权的自定义的
行为。下面的可选属性覆盖 <a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a> 的默认值或一般
行为:</p>
<ul class="simple">
<li><cite>__name__</cite>: 函数的名称默认用于末端。如果显式地提供末端，这个值会使用。
此外，它默认以蓝图的名称作为前缀，并且不能从函数本身自定义。</li>
<li><cite>methods</cite>: 如果没有在添加 URL 规则时提供 methods 参数。 Flask 会在视
图函数对象上寻找是否存在 <cite>methods</cite> 属性。如果存在，它会从上面拉取方法
的信息。</li>
<li><cite>provide_automatic_options</cite>: 如果设置了这个属性， Flask 会强制禁用或
启用 HTTP <cite>OPTIONS</cite> 响应的自动实现。这对于对单个视图自定义 <cite>OPTIONS</cite>
响应而使用装饰器的情况下是有用的。</li>
<li><cite>required_methods</cite>: 如果这个属性被设置了， 当注册一个 URL 规则的时候，
Flask 将总是会添加这些 methods 即使 methods 参数在 <tt class="docutils literal"><span class="pre">route()</span></tt> 调用
的时候被显式的覆盖了。</li>
</ul>
<p>完整的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;OPTIONS&#39;</span><span class="p">:</span>
        <span class="c"># custom options handling here</span>
        <span class="o">...</span>
    <span class="k">return</span> <span class="s">&#39;Hello World!&#39;</span>
<span class="n">index</span><span class="o">.</span><span class="n">provide_automatic_options</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">index</span><span class="o">.</span><span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;OPTIONS&#39;</span><span class="p">]</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">0.8 新版功能: </span>加入了 <cite>provide_automatic_options</cite> 功能。</p>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id4">
<h2>额外说明<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>这部分的设计说明，法律信息和变更记录为有兴趣的人准备。</p>
<div class="toctree-wrapper compound">
<span id="document-design"></span><div class="section" id="flask">
<span id="design"></span><h3>Flask 中的设计决策<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h3>
<p>如果你好奇 Flask 为什么用它的方式做事情，而不是别的方法，那么这节是为你准
备的。这节应该给你一些设计决策的想法，也许起初是武断且令人惊讶的，特别是
直接与其它框架相比较。</p>
<div class="section" id="id1">
<h4>显式的应用对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>一个基于 WSGI 的 Python web 应用必须有一个中央的可调用对象来实现实际的应
用。在 Flask 中，这是一个 <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 类的实例。每个 Flask 应用
必须创建一个该类的实例，并传给它模块的名称，但是为什么 Flask 不自己这么
做？</p>
<p>当不是像下面的代码这样使用一个显式的应用对象时:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World!&#39;</span>
</pre></div>
</div>
<p>看起来会是这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">hypothetical_flask</span> <span class="kn">import</span> <span class="n">route</span>

<span class="nd">@route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World!&#39;</span>
</pre></div>
</div>
<p>这样做有三个主要的原因。最重要的一个是，显式的应用对象需要在同一时刻只存在
一个实例。有许多方法来用单个应用对象来仿造多个应用，像维护一个应用的栈一样，
但这会导致一些问题，这里不会赘述。现在问题是：什么时候一个微框架在同一时刻需
要至少一个应用？一个很好的例子是单元测试。当你想要测试什么的时候，创建一个
最小化的应用来测试特定的行为非常有用。当应用对象删除时，它分配的一切都会被
再次释放。</p>
<p>当你的代码中有一个显式的对象时，继承基类（ <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> ）来更改
特定行为将成为可能。如果基于一个不暴露给你的类的对象在你之前创建，这么做只
能通过 hack 。</p>
<p>此外， Flask 依赖于一个那个类的显式实例还有一个非常重要的原因是：包名称。无
论何时你创建一个 Flask 实例，你通常传给它 <cite>__name__</cite> 作为包名。 Flask 依赖
这个信息来正确地加载相对于你模块的资源。在 Python 对反射的杰出支持下，它可
以访问包来找出模板和静态文件存储在哪（见 <a class="reference internal" href="index.html#flask.Flask.open_resource" title="flask.Flask.open_resource"><tt class="xref py py-meth docutils literal"><span class="pre">open_resource()</span></tt></a>
）。当前显然有许多框架不需要任何配置，且能载入相对于你应用的模块的模板。但
是它们需要为此使用当前工作目录，一种非常不值得信赖的决定应用在哪的方式。当
前工作目录是进程间的，而且如果你想要在同一个进程中运行多个应用（这会在你不
知道的一个 web 服务器中发生），路径会断开。更可怕的是：许多 web 服务器不把
你应用的目录，而是文档根目录设定为工作目录，但两者不一定是一个文件夹。</p>
<p>第三个原因是“显明胜于隐含”。那个对象是你的 WSGI 应用，你不需要记住别的东西。
如果你想要应用一个 WSGI 中间件，只需要封装它（虽然有更好的方式来这么做来不
丢失应用对象的引用 <a class="reference internal" href="index.html#flask.Flask.wsgi_app" title="flask.Flask.wsgi_app"><tt class="xref py py-meth docutils literal"><span class="pre">wsgi_app()</span></tt></a> ）。</p>
<p>此外，这个设计使得用工厂函数来创建应用成为可能，这对单元测试和类似的东西
（ <a class="reference internal" href="index.html#app-factories"><em>应用程序的工厂函数</em></a> ）十分有用。</p>
</div>
<div class="section" id="id2">
<h4>路由系统<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>Flask 使用 Werkzeug 路由系统，其被设计为按复杂度自动为路由排序。这意味着，
你可以任意顺序声明路由，而且他们仍会按期望工作。这在你想正确地实现基于装饰
器的路由是必须的，因为当应用被分割为多个模块时装饰器可以以未定义的顺序调用。</p>
<p>另一个 Werkzeug 路由系统的设计决策是， Werkzeug 中的路由试图确保 URL 是唯
一的。 Werkzeug 对此会做的足够多，因为它在路由不明确时自动重定向到一个规
范的 URL 。</p>
</div>
<div class="section" id="id3">
<h4>某个模板引擎<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Flask 在模板引擎上做了决定： Jinja2 。为什么 Flask 没有一个即插的模板引擎
接口？显然，你可以使用一个不同的模板引擎，但是 Flask 仍然会为你配置
Jinja2 。虽然 Jinja2 <em>总是</em> 配置的限制可能会消失，但绑定一个模板引擎并使用
的决策不会。</p>
<p>模板引擎与编程语言类似，每个模板引擎都有特定的理解事物工作的方式。表面上，
它们以相同方式工作：你给引擎一个变量的集合让它为模板求值，并返回一个字符
串。</p>
<p>然而，关于相同点的论述结束了。例如 Jinja2 有一个全面的过滤器系统，一个可靠
的模板继承方式，可以从模板内和 Python 代码内使用复用块（宏）的支持，对所有
操作使用 Unicode，支持迭代模板渲染，可配置的语法等等。其它的引擎，一个类似
Genshi——基于 XML 流求值的引擎，模板继承要考虑 XPath 可用性等等。而 Mako 像
对待 Python 模块一样处理模板。</p>
<p>当把一个模板引擎跟一个应用或框架联系到一起，就不只是渲染模板了。比如，
Flask 使用 Jinja2 全面的自动转义支持。同样，也提供了从 Jinja2 模板中
访问宏的途径。</p>
<p>不去掉模板引擎的独特特性的模板抽象层是一门对自身的科学，也是像 Flask
的微框架的巨大事业。</p>
<p>此外，扩展也可以简易地依赖于一个现有的模板语言。你可以简单地使用你自己的
模板语言，而扩展会始终依赖于 Jinja 本身。</p>
</div>
<div class="section" id="id4">
<h4>微与依赖<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>为什么 Flask 把自己叫做微框架，并且它依赖于两个库（也就是 Werkzeug 和
Jinja 2）。为什么不能？如果我们仔细审查 Ruby 的 web 开发，有一个非常
类似 WSGI 的协议。被称作 Rack 的就是它，但是除此之外，它看起来非常像
一个 WSGI 的 Ruby 实现。但是几乎所有的 Ruby 应用不直接使用 Rack ，而是
基于一个相同名字的库。这个 Rack 库与 Python 中的两个库不相伯仲： WebOb
（以前叫 Paste ） 和 Werkzeug。 Paste 依然在使用，但是从我的理解，它有
些过时，而赞同 WebOb 。 WebOb 和 Werzeug 的开发是一起开始的，也有着同样
的理念：为其它应用的利用做一个 WSGI 的良好实现。</p>
<p>Flask 是一个受益于 Werkzeug 妥善实现 WSGI 接口（有时是一个复杂的任务）
既得成果的框架。感谢 Python 包基础建设中近期的开发，包依赖不再是问题，
并且只有很少的原因反对依赖其它库的库。</p>
</div>
<div class="section" id="id5">
<h4>线程局域变量<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>Flask 为请求、会话和一个额外对象（你可以在 <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> 上放置自己的东
西）使用线程局域对象（实际上是上下文局域对象，它们也支持 greenlet 上下文）。
为什么是这样，这不是一个坏主意吗？</p>
<p>是的，通常情况下使用线程局域变量不是一个明智的主意。它们在不基于线程概念的
服务器上会导致问题，并且使得大型应用难以维护。但 Flask 不仅为大型应用或异步
服务器设计。 Flask 想要使得编写一个传统 web 应用的过程快速而简单。</p>
<p>一些关于基于 Flask 大型应用的灵感，见文档的 <a class="reference internal" href="index.html#becomingbig"><em>聚沙成塔</em></a> 一节。</p>
</div>
<div class="section" id="id6">
<h4>Flask 是什么，不是什么？<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>Flask 永远不会包含数据库层，也不会有表单库或是这个方向的其它东西。 Flask
只建立 Werkezug 和 Jinja2 的桥梁，前者实现一个合适的 WSGI 应用，后者处理
模板。 Flask 也绑定了一些通用的标准库包，比如 logging 。其它所有一切取决
于扩展。</p>
<p>为什么是这样？众口难调，因此 Flask 不强制把特异的偏好和需求囊括在核心里。
大多数 web 应用都可以说需要一个模板引擎，但并不是每个应用都需要一个 SQL
数据库。</p>
<p>Flask 的思想是为所有应用建立一个良好的基础，其余的一切都取决于你和扩展。</p>
</div>
</div>
<span id="document-htmlfaq"></span><div class="section" id="html-xhtml">
<h3>HTML/XHTML 常见问题<a class="headerlink" href="#html-xhtml" title="永久链接至标题">¶</a></h3>
<p>Flask 文档和示例应用使用 HTML5 。你可能会注意到，在许多情况下当结束标签
是可选的时候，并不使用它们，这样 HTML 会更简洁且加载更迅速。因为在开发者
中，关于 HTML 和 XHTML 有许多混淆，本文档试图回答一些主要的疑问。</p>
<div class="section" id="xhtml">
<h4>XHTML 的历史<a class="headerlink" href="#xhtml" title="永久链接至标题">¶</a></h4>
<p>一段时间， XHTML 的出现欲取代 HTML 。然而，Internet 上几乎没有任何实
际的 XHTML （用 XML 规则处理的 HTML ）网站。这种情况有几个主要的原因。
其一是 Internet Explorer 缺乏对 XHTML 妥善的支持。 XHTML 规范要求 XHTML
必须由 MIME 类型 <cite>application/xhtml+xml</cite> 来承载，但是 Internet Explorer
拒绝读取这个 MIME 类型下的文件。</p>
<p>虽然配置 Web 服务器来提供正确的 XHTML 相对简单，但很少有人这么做。这可能
是因为正确地使用 XHTML 会是一件痛苦的事。</p>
<p>痛苦的最重要的原因之一是 XML 苛刻的（严格而残忍）错误处理。当 XML 处理中
遭遇错误时，浏览器会把一个丑陋的错误消息显示给用户，而不是尝试从错误中恢
并显示出能显示的。web 上大多数的 (X)HTML 生成基于非 XML 的模板引擎（比如
Flask 所使用的 Jinja）并不会防止你偶然创建无效的 XHTML 。也有基于 XML 的
模板引擎，诸如 Kid 和 流行的 Genshi，但是它们经常具有更大的运行时开销，
并且不能直接使用，因为它们要遵守 XML 规则。</p>
<p>大多数用户，不管怎样，假设它们正在正确地使用 XHTML 。他们在文档的顶部写下
一个 XHTML doctype 并且闭合了所有必要闭合的标签（ 在 XHTML 中 <tt class="docutils literal"><span class="pre">&lt;br&gt;</span></tt> 要
写为 <tt class="docutils literal"><span class="pre">&lt;br</span> <span class="pre">/&gt;</span></tt> 或 <tt class="docutils literal"><span class="pre">&lt;br&gt;&lt;/br&gt;</span></tt> ）。然而，即使文档可以正确地通过 XHTML
验证，真正决定浏览器中 XHTML/HTML 处理的是前面说到的，经常不被正确设置的
MIME 类型。所以有效的 XHTML 会被视为有效的 HTML 处理。</p>
<p>XHTML 也改变了使用 JavaScript 的方式。要在 XHTML 下正确地工作，程序员不得不
使用带有 XHTML 名称空间的 DOM 接口来查询 HTML 元素。</p>
</div>
<div class="section" id="html5">
<h4>HTML5 的历史<a class="headerlink" href="#html5" title="永久链接至标题">¶</a></h4>
<p>HTML5 规范的开发在 2004 年就以 “Web 应用1.0”之名由网页超文本技术工作小组
（Web Hypertext Application Technology Working Group），或 WHATWG（由主要
的浏览器供应商苹果、 Mozilla 以及 Opera 组成）启动了，目的是编写一个新的改
良的HTML 规范，基于现有的浏览器行为，而不是不切实际和不向后兼容的规范。</p>
<p>例如，在 HTML4 中 <tt class="docutils literal"><span class="pre">&lt;title/Hello/</span></tt> 理论上与 <tt class="docutils literal"><span class="pre">&lt;title&gt;Hello&lt;/title&gt;</span></tt> 处理
得完全相同。然而，由于人们已然使用了诸如 <tt class="docutils literal"><span class="pre">&lt;link</span> <span class="pre">/&gt;</span></tt> 的 XHTML-like 标签，
浏览器供应商在规范语法之上实现了 XHTML 语法。</p>
<p>在 2007 年，这个标准被 W3C 收入一个新的 HTML 规范，也就是 HTML5 。现在，
随着 XHTML 2 工作组解散和 HTML5 被所有主流浏览器供应商实现，XHTML 正在失去
吸引力。</p>
</div>
<div class="section" id="html-vs-xhtml">
<h4>HTML vs. XHTML<a class="headerlink" href="#html-vs-xhtml" title="永久链接至标题">¶</a></h4>
<p>下面的表格给你一个 HTML 4.01 、 XHTML 1.1 和 HTML5 中可用特性的简要综述。
（不包括 XHTML 1.0 ，因为它被 XHTML 1.1 和几乎不使用的 XHTML5 代替 ）</p>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&nbsp;</th>
<th class="head">HTML4.01</th>
<th class="head">XHTML1.1</th>
<th class="head">HTML5</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&lt;tag/value/</span></tt> == <tt class="docutils literal"><span class="pre">&lt;tag&gt;value&lt;/tag&gt;</span></tt></td>
<td><img alt="Yes" src="_images/yes.png" /> <a class="footnote-reference" href="#id4" id="id1">[1]</a></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
</tr>
<tr class="row-odd"><td>支持 <tt class="docutils literal"><span class="pre">&lt;br/&gt;</span></tt></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /> <a class="footnote-reference" href="#id5" id="id2">[2]</a></td>
</tr>
<tr class="row-even"><td>支持  <tt class="docutils literal"><span class="pre">&lt;script/&gt;</span></tt></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
</tr>
<tr class="row-odd"><td>应该使用的 MIME 类型： <cite>text/html</cite></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="No" src="_images/no.png" /> <a class="footnote-reference" href="#id6" id="id3">[3]</a></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
</tr>
<tr class="row-even"><td>应该使用的 MIME 类型：
<cite>application/xhtml+xml</cite></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
</tr>
<tr class="row-odd"><td>严格的错误处理</td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
</tr>
<tr class="row-even"><td>内联 SVG</td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
</tr>
<tr class="row-odd"><td>内联 MathML</td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&lt;video&gt;</span></tt> 标签</td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&lt;audio&gt;</span></tt> 标签</td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
</tr>
<tr class="row-even"><td>新的语义标签，比如 <tt class="docutils literal"><span class="pre">&lt;article&gt;</span></tt></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="No" src="_images/no.png" /></td>
<td><img alt="Yes" src="_images/yes.png" /></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>这是一个从 SGML 中继承过来的鲜为人知的特性。由于上述的原因，它通常不
被浏览器支持。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>这用于兼容生成 <tt class="docutils literal"><span class="pre">&lt;br&gt;</span></tt> 之类的服务器代码。它不应该在新代码中出现。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>XHTML 1.0 是考虑向后兼容，允许呈现为 <cite>text/html</cite> 的最后一个 XHTML 标
准。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id7">
<h4>“严格”意味着什么？<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>HTML5 严格地定义了处理规则，并准确地指定了一个浏览器应该如何应对处理中的错
误——不像 XHTML，只简单声明将要中断解析。一些人因显然无效的语法仍生成期望中
结果而困惑（比如，缺失结尾标签或属性值未用引号包裹）。</p>
<p>这些工作是因为大多数浏览器遭遇一个标记错误时的错误处理是宽容的，其它的实际
上也指定了。下面的结构在 HTML5 标准中是可选的，但一定被浏览器支持:</p>
<ul class="simple">
<li>用 <tt class="docutils literal"><span class="pre">&lt;html&gt;</span></tt> 标签包裹文档。</li>
<li>把页首元素包裹在 <tt class="docutils literal"><span class="pre">&lt;head&gt;</span></tt> 里或把主体元素包裹在 <tt class="docutils literal"><span class="pre">&lt;body&gt;</span></tt> 里。</li>
<li>闭合 <tt class="docutils literal"><span class="pre">&lt;p&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;li&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;dt&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;dd&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;tr&gt;</span></tt>,
<tt class="docutils literal"><span class="pre">&lt;td&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;th&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;tbody&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;thead&gt;</span></tt> 或 <tt class="docutils literal"><span class="pre">&lt;tfoot&gt;</span></tt> 标签。</li>
<li>用引号包裹属性值，只要它们不含有空白字符或其特殊字符（比如 <tt class="docutils literal"><span class="pre">&lt;</span></tt> 、
<tt class="docutils literal"><span class="pre">&gt;</span></tt> 、 <tt class="docutils literal"><span class="pre">'</span></tt> 或 <tt class="docutils literal"><span class="pre">&quot;</span></tt> ）。</li>
<li>需要布尔属性来设定一个值。</li>
</ul>
<p>这意味着下面的页面在 HTML5 中是完全有效的:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;title&gt;</span>Hello HTML5<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">header</span><span class="nt">&gt;</span>
  <span class="nt">&lt;h1&gt;</span>Hello HTML5<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">tagline</span><span class="nt">&gt;</span>HTML5 is awesome
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">nav</span><span class="nt">&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">/index</span><span class="nt">&gt;</span>Index<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">/downloads</span><span class="nt">&gt;</span>Downloads<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">/about</span><span class="nt">&gt;</span>About<span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">body</span><span class="nt">&gt;</span>
  <span class="nt">&lt;h2&gt;</span>HTML5 is probably the future<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;p&gt;</span>
    There might be some other things around but in terms of
    browser vendor support, HTML5 is hard to beat.
  <span class="nt">&lt;dl&gt;</span>
    <span class="nt">&lt;dt&gt;</span>Key 1
    <span class="nt">&lt;dd&gt;</span>Value 1
    <span class="nt">&lt;dt&gt;</span>Key 2
    <span class="nt">&lt;dd&gt;</span>Value 2
  <span class="nt">&lt;/dl&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>HTML5 中的新技术<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>HTML5 添加了许多新特性来使得 Web 应用易于编写和使用。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&lt;audio&gt;</span></tt> 和 <tt class="docutils literal"><span class="pre">&lt;video&gt;</span></tt> 标签提供了不使用 QuickTime 或 Flash 之类的
复杂附件的嵌入音频和视频的方式。</li>
<li>像 <tt class="docutils literal"><span class="pre">&lt;article&gt;</span></tt> 、 <tt class="docutils literal"><span class="pre">&lt;header&gt;</span></tt> 、 <tt class="docutils literal"><span class="pre">&lt;nav&gt;</span></tt> 以及 <tt class="docutils literal"><span class="pre">&lt;time&gt;</span></tt> 之类的
语义化元素，使得内容易于理解。</li>
<li><tt class="docutils literal"><span class="pre">&lt;canvas&gt;</span></tt> 标签，支持强大的绘图 API ，减少了服务器端生成图像来图形化
显示数据的必要。</li>
<li>新的表单控件类型，比如 <tt class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=&quot;data&quot;&gt;</span></tt> 使得用户代理记录和验证
其值更容易。</li>
<li>高级 JavaScript API ，诸如 Web Storage 、 Web Workers 、 Web Sockets 、
地理位置以及离线应用。</li>
</ul>
<p>除此之外，也添加了许多其它的特性。 Mark Pilgrim 即将出版的书
<a class="reference external" href="http://www.diveintohtml5.org/">Dive Into HTML5</a> 是 HTML5 中新特性的优秀入门书。并不是所有的这些特性已经
都被浏览器支持，无论如何，请谨慎使用。</p>
</div>
<div class="section" id="id9">
<h4>应该使用什么？<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>一般情况下，答案是 HTML 5 。考虑到 web 浏览器最新的开发，几乎没有理由再去
使用 XHTML 。总结上面给出的原因:</p>
<ul class="simple">
<li>Internet Explorer （令人悲伤的是目前市场份额处于领先） 对 XHTML 支持不佳。</li>
<li>许多 JavaScript 库也不支持 XHTML ，由于它需要复杂的命名空间 API 。</li>
<li>HTML 添加了数个新特性，包括语义标签和期待已久的 <tt class="docutils literal"><span class="pre">&lt;audio&gt;</span></tt> 和
<tt class="docutils literal"><span class="pre">&lt;video&gt;</span></tt> 标签。</li>
<li>它背后获得了大多数浏览器供应商的支持。</li>
<li>它易于编写，而且更简洁。</li>
</ul>
<p>对于大多数应用，使用 HTML5 无疑比 XHTML 要好。</p>
</div>
</div>
<span id="document-security"></span><div class="section" id="id1">
<h3>安全注意事项<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>Web 应用通常面临所有种类的安全问题，并且很难把所有事做的正确。 Flask 试图
为你解决这些事情中的一些，但你仍需要关心更多的问题。</p>
<div class="section" id="xss">
<span id="id2"></span><h4>跨站脚本攻击（XSS）<a class="headerlink" href="#xss" title="永久链接至标题">¶</a></h4>
<p>跨站脚本攻击的概念是在一个网站的上下文中注入任意的 HTML （以及附带的
JavaScript ）。开发者需要正确地转义文本，使其不能包含任意 HTML 标签来避免
这种攻击。更多的信息请阅读维基百科上关于 <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_scripting">Cross-Site Scripting</a> 的文章。</p>
<p>Flask 配置 Jinja2 自动转义所有值，除非显式地指明不转义。这就排除了模板导
致的所有 XSS 问题，但是你仍需要在其它的地方小心:</p>
<ul class="simple">
<li>生成 HTML 而不使用 Jinja2</li>
<li>在用户提交的数据上调用了 <a class="reference internal" href="index.html#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a></li>
<li>发送上传的 HTML 文件，永远不要这么做，使用
<cite>Content-Disposition: attachment</cite> 标头来避免这个问题</li>
<li>发送上传的文本文件。一些浏览器使用基于开头几个字节的 content-type
猜测，所以用户可能欺骗浏览器执行 HTML</li>
</ul>
<p>另一件非常重要的事情是未用引号包裹的属性。虽然 Jinja2 可以通过转义 HTML
来保护你免受 XSS 问题，仍有一种情况，它不能保护你: 属性注入的 XSS 。为了
应对这种攻击媒介，确保当在属性中使用 Jinja 表达式时，始终用单引号或双引号
包裹属性:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">href</span> <span class="cp">}}</span><span class="s">&quot;</span><span class="nt">&gt;</span>the text<span class="nt">&lt;/a&gt;</span>
</pre></div>
</div>
<p>为什么这是必要的？因为如果你不这么做，攻击者可以容易地注入自制的
JavaScript 处理器。譬如一个攻击者可以注入这段 HTML+JavaScript:</p>
<div class="highlight-html"><div class="highlight"><pre>onmouseover=alert(document.cookie)
</pre></div>
</div>
<p>当用户鼠标经过这个链接， 会在警告窗口里把 cookie 显示给用户。一个精明的
攻击者可能也会执行其它的 JavaScript 代码，而不是把 cookie 显示给用户。
同 CSS 注入联系在一起，攻击者甚至使得元素填满整个页面，这样用户鼠标在页面
上的任何地方都会触发攻击。</p>
</div>
<div class="section" id="csrf">
<h4>跨站请求伪造（CSRF）<a class="headerlink" href="#csrf" title="永久链接至标题">¶</a></h4>
<p>另一个大问题是 CSRF 。这是一个非常复杂的话题，我不会在此详细介绍，而只会
提及 CSRF 是什么和理论上如何避免它。</p>
<p>如果你的验证信息存储在 cookie 中，你有隐式的状态管理。“已登入”状态由一个
cookie 控制，并且这个 cookie 在每个页面的请求中都会发送。不幸的是，在第三
方站点触发的请求中也会发送这个 cookie 。如果你不注意这点，一些人可能会通过
社会工程学来诱导你应用的用户在他们不知道的情况下做一些蠢事。</p>
<p>比如你有一个指定的 URL ，当你发送 <cite>POST</cite> 请求时会删除一个用户的资料（比如
<cite>http://example.com/user/delete</cite> 。如果一个攻击者现在创造一个页面来用
JavaScript 发送这个 post 请求，他们只是诱骗一些用户加载那个页面，而他们
的资料最终会被删除。</p>
<p>想象你在运行 Facebook ，有数以百万计的并发用户，并且某人放出一些小猫图片
的链接。当用户访问那个页面欣赏毛茸茸的猫的图片时，他们的资料就被删除。</p>
<p>你怎样才能阻止这呢？基本上，对于每个修改服务器上内容的请求，你应该使用
一次性令牌，并存储在 cookie 里， <strong>并且</strong> 在发送表单数据的同时附上它。
在服务器再次接收数据之后，你要比较两个令牌，并确保它们相等。</p>
<p>为什么 Flask 没有为你这么做？理想情况下，这应该是表单验证框架做的事，而
Flask 中并不存在表单验证。</p>
</div>
<div class="section" id="json">
<span id="json-security"></span><h4>JSON 安全<a class="headerlink" href="#json" title="永久链接至标题">¶</a></h4>
<div class="admonition-ecmascript-5 admonition">
<p class="first admonition-title">ECMAScript 5 的变更</p>
<p class="last">从 ECMAScript 5 开始，常量的行为变化了。现在它们不由 <tt class="docutils literal"><span class="pre">Array</span></tt> 或其它
的构造函数构造，而是由 <tt class="docutils literal"><span class="pre">Array</span></tt> 的内建构造函数构造，关闭了这个特殊的
攻击媒介。</p>
</div>
<p>JSON 本身是一种高级序列化格式，所以它几乎没有什么可以导致安全问题，对吗？
你不能声明导致问题的递归结构，唯一可能导致破坏的就是在接受者角度上，非常
大的响应可以导致某种意义上的拒绝服务攻击。</p>
<p>然而有一个陷阱。由于浏览器在 CSRF 问题上工作的方式， JSON 也不能幸免。幸运
的是， JavaScript 规范中有一个怪异的部分可以用于简易地解决这一问题。 Flask
通过避免你做危险的事情上为你解决了一些。不幸的是，只有在
<tt class="xref py py-func docutils literal"><span class="pre">jsonify()</span></tt> 中有这样的保护，所以如果你用其它方法生成 JSON 仍然
有风险。</p>
<p>那么，问题是什么，并且怎样避免？问题是 JSON 中数组是一等公民。想象你在
一个 JSON 请求中发送下面的数据。比如 JavaScript 实现的用户界面的一部分，
导出你所有朋友的名字和邮件地址。并不罕见:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;username&quot;</span><span class="o">:</span> <span class="s2">&quot;admin&quot;</span><span class="p">,</span>
     <span class="s2">&quot;email&quot;</span><span class="o">:</span> <span class="s2">&quot;admin@localhost&quot;</span><span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
<p>这当然只在你登入的时候，且只为你这么做。而且，它对一个特定 URL 上的所有
<cite>GET</cite> 请求都这么做。比如请求的 URL 是
<tt class="docutils literal"><span class="pre">http://example.com/api/get_friends.json</span></tt></p>
<p>那么如果一个聪明的黑客把这个嵌入到他自己的网站上，并用社会工程学使得受害
者访问他的网站，会发生什么:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
<span class="kd">var</span> <span class="nx">captured</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">var</span> <span class="nx">oldArray</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">;</span>
<span class="kd">function</span> <span class="nb">Array</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span> <span class="nx">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">capture</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">__defineSetter__</span><span class="p">(</span><span class="nx">id</span><span class="o">++</span><span class="p">,</span> <span class="nx">capture</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span>
      <span class="nx">captured</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">capture</span><span class="p">();</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span>
  <span class="na">src=</span><span class="s">http://example.com/api/get_friends.json</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
<span class="nb">Array</span> <span class="o">=</span> <span class="nx">oldArray</span><span class="p">;</span>
<span class="c1">// now we have all the data in the captured array.</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
</div>
<p>如果你懂得一些 JavaScript 的内部工作机制，你会知道给构造函数打补丁和为
setter 注册回调是可能的。一个攻击者可以利用这点（像上面一样上）来获取
所有你导出的 JSON 文件中的数据。如果在 script 标签中定义了内容类型是
<tt class="docutils literal"><span class="pre">text/javascript</span></tt> ，浏览器会完全忽略 <tt class="docutils literal"><span class="pre">application/json</span></tt> 的
mimetype ，而把其作为 JavaScript 来求值。因为顶层数组元素是允许的（虽然
没用）且我们在自己的构造函数中挂钩，在这个页面载入后， JSON 响应中的数据
会出现在 <cite>captured</cite> 数组中。</p>
<p>因为在 JavaScript 中对象字面量（ <tt class="docutils literal"><span class="pre">{...}</span></tt> ）处于顶层是一个语法错误，攻
击者可能不只是用 script 标签加载数据并请求一个外部的 URL 。所以， Flask
所做的只是在使用 <tt class="xref py py-func docutils literal"><span class="pre">jsonify()</span></tt> 时允许对象作为顶层元素。确保使用
普通的 JSON 生成函数时也这么做。</p>
</div>
</div>
<span id="document-unicode"></span><div class="section" id="flask-unicode">
<h3>Flask 中的 Unicode<a class="headerlink" href="#flask-unicode" title="永久链接至标题">¶</a></h3>
<p>Flask 与 Jinja2 、 Werkzeug 一样，文本方面完全基于 Unicode ，大多数 web 相关的
Python 库同样这样处理文本。如果你还不知道 Unicode 是什么，可能需要阅读
<a class="reference external" href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely,
Positively Must Know About Unicode and Character Sets</a> 。
这些文档对基本知识做了一些封装，保证你处理 Unicode 相关的事情有愉快的经历。</p>
<div class="section" id="id1">
<h4>自动转换<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>为了提供基本无痛的 Unicode 支持，Flask做了这些假设：</p>
<ul class="simple">
<li>你网站上文本编码是 UTF-8</li>
<li>你在内部对文本始终只使用 Unicode ，除非是只有 ASCII 字符的字面量字符串</li>
<li>只要协议会话需要传送字节，都离不开编码和解码过程</li>
</ul>
<p>所以，这对你来说有什么意义？</p>
<p>HTTP 是基于字节的，不仅是说协议，用于定位服务器文档的系统也是这样（即 URI
或 URL ）。然而，通常在 HTTP 上传送的 HTML 支持很多种字符集，并且需要在 HTTP
header 中注明。为了避免不必要的复杂性， Flask 假设你发送的都是 UTF-8
编码的 Unicode，Flask 会为你完成编码工作，并设置适当的 header。</p>
<p>如果你使用 SQLAlchemy 或类似的 ORM 系统与数据库会话，道理也是同样的：一些数据库
已经使用传输 Unicode 的协议，即使没有，SQLALchemy 或其它 ORM 也会顾及到。</p>
</div>
<div class="section" id="id2">
<h4>金科玉律<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>经验法则：如果你不需要处理二进制数据，请一律使用 Unicode 。在 Python 2.x 中，使用
Unicode 意味着什么？</p>
<ul class="simple">
<li>使用 ASCII charpoints （基本是数字、非变音或非奇特的拉丁字母），你可以使用常规的
字符串常量（ <tt class="docutils literal"><span class="pre">'Hello</span> <span class="pre">World'</span></tt> ）</li>
<li>如果你的字符串里有 ASCII 之外的东西，需要把这个字符串标记为 Unicode 字符串，
方法是加上一个小写 <cite>u</cite> 的前缀（比如 <tt class="docutils literal"><span class="pre">u'Hänsel</span> <span class="pre">und</span> <span class="pre">Gretel'</span></tt> ）</li>
<li>如果你在 Python 文件中使用了非 Unicode 字符，你需要告诉 Python 你的文
件使用了何种编码。我再次建议为此使用 UTF-8 。你可以在你 Python 源文件
的第一行或第二行写入 <tt class="docutils literal"><span class="pre">#</span> <span class="pre">-*-</span> <span class="pre">coding:</span> <span class="pre">utf-8</span> <span class="pre">-*-</span></tt> 来告知解释器你的编码
类型。</li>
<li>Jinja 被配置为从 UTF-8 解码模板文件，所以确保你的编辑器也保存文件为 UTF-8 编码。</li>
</ul>
</div>
<div class="section" id="id3">
<h4>自行编解码<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你的工作环境是一个不真正基于 Unicode 的文件系统之类的话，你需要确保使用 Unicode 接口妥善地解码。比如，当你想要在文件系统中加载一个文件，并嵌入到 Jinja2 模板时，
你需要按照文件的编码来解码。这里有一个老问题就是文本文件不指定有效的编码，
所以限定你在文本文件中使用 UTF-8 也是在帮自己的忙。</p>
<p>无论如何，以 Unicode 加载这样文件，你可以使用内置的 <tt class="xref py py-meth docutils literal"><span class="pre">str.decode()</span></tt> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">charset</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">charset</span><span class="p">)</span>
</pre></div>
</div>
<p>从 Unicode 转换成指定的字符集，你可以使用 <tt class="xref py py-meth docutils literal"><span class="pre">unicode.encode()</span></tt> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">write_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">contents</span><span class="p">,</span> <span class="n">charset</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">contents</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">charset</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>配置编辑器<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>现在的大多数编辑器默认存储为 UTF-8 ，但是如果你的编辑器没有配置为这样，你
需要更改它。这里是设置你编辑器存储为 UTF-8 的通用做法:</p>
<ul>
<li><p class="first">Vim: 在你的 <tt class="docutils literal"><span class="pre">.vimrc</span></tt> 文件中加入 <tt class="docutils literal"><span class="pre">set</span> <span class="pre">enc=utf-8</span></tt></p>
</li>
<li><p class="first">Emacs: 使用 encoding cookie，或者把这段文字加入到你的 <tt class="docutils literal"><span class="pre">.emacs</span></tt> 配置文件:</p>
<div class="highlight-python"><pre>(prefer-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)</pre>
</div>
</li>
<li><p class="first">Notepad++:</p>
<ol class="arabic simple">
<li>打开 <em>设置 -&gt; 首选项 ...</em></li>
<li>选择“新建”选项卡</li>
<li>选择“ UTF-8 无 BOM ”作为编码</li>
</ol>
<p>同样也建议使用 Unix 的换行格式，可以在相同的面板中选择，但不是必须的。</p>
</li>
</ul>
</div>
</div>
<span id="document-extensiondev"></span><div class="section" id="flask">
<span id="extension-dev"></span><h3>Flask 扩展开发<a class="headerlink" href="#flask" title="永久链接至标题">¶</a></h3>
<p>Flask，一个微框架，通常需要一些重复的步骤来让第三方库工作。因为在很多时候，
这些步骤可以被分离出，来支持多个项目，就有了 <a class="reference external" href="http://flask.pocoo.org/extensions/">Flask Extension Registry</a> 。</p>
<p>如果你想要为还没有的功能创建你自己的 Flask 扩展，这份扩展开发指南会帮助你
在很短的时间内让你的应用跑起来并且感到像用户一样期待你的扩展运转。</p>
<div class="section" id="id1">
<h4>剖析扩展<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>所有的扩展都位于一个叫做 <tt class="docutils literal"><span class="pre">flask_something</span></tt> 的包，其中“ something ”是你
想要连接的库的名字。那么，例如当你计划要为 Flask 添加一个叫做 <cite>simplexml</cite>
的库的支持时，你应该把你扩展的包命名为 <tt class="docutils literal"><span class="pre">flask_simplexml</span></tt> 。</p>
<p>实际的扩展名（人类可读的名称）无论如何会是“Flask-SimpleXML”之类的东西。
确保在名字中包含“Flask”并注意大小写。这是用户可以在他们的 <cite>setup.py</cite> 文
件中注册你的扩展为依赖的方式。</p>
<p>Flask 设立了一个叫做 <tt class="xref py py-data docutils literal"><span class="pre">flask.ext</span></tt> 的重定向包，用户应该从这个包导入
扩展。例如，如果你有一个叫做 <cite>flask_something</cite> 的包，用户应该用
<tt class="docutils literal"><span class="pre">flask.ext.something</span></tt> 的方式导入。这样做是为了从老命名空间的包过度。
详情见 <a class="reference internal" href="index.html#ext-import-transition"><em>扩展导入的过渡</em></a> 。</p>
<p>但是扩展如何看起来像扩展？一个扩展必须保证它可以同时在多个 Flask 应用中工
作。这是必要条件，因为许多人会使用类似 <a class="reference internal" href="index.html#app-factories"><em>应用程序的工厂函数</em></a> 的模式来创建
应用来进行单元测试或是支持多套配置。因此，你的应用支持这种行为非常重要。</p>
<p>最重要的是，扩展必须与一个 <cite>setup.py</cite> 文件一起装配，并且在 PyPI 上注册。同
样，开发 checkout 链接也应该能工作，这样才可以在 virtualenv 中容易地安装开
发版本，而不是手动下载库。</p>
<p>Flask 扩展必须以 BSD 或 MIT 或更自由的许可证来许可，这样才能被列入到 Flask
Extension Registry 。记住 Flask Extension Registry 是一个人工维护的地方，
并且会视这些库的行为来决定是否进行必要的提前审查。</p>
</div>
<div class="section" id="hello-flaskext">
<h4>&#8220;Hello Flaskext!&#8221;<a class="headerlink" href="#hello-flaskext" title="永久链接至标题">¶</a></h4>
<p>那么让我们开始创建这样一个 Flask 扩展。我们这里想要创建的扩展会提供 SQLite3
最基础的支持。</p>
<p>首先我们创建下面的目录结构:</p>
<div class="highlight-python"><pre>flask-sqlite3/
    flask_sqlite3.py
    LICENSE
    README</pre>
</div>
<p>这里是最重要的文件的内容:</p>
<div class="section" id="setup-py">
<h5>setup.py<a class="headerlink" href="#setup-py" title="永久链接至标题">¶</a></h5>
<p>下一个绝对需要的文件是 <cite>setup.py</cite> ，用于安装你的 Flask 扩展。你可以使用下
面的内容:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Flask-SQLite3</span>
<span class="sd">-------------</span>

<span class="sd">This is the description for that library</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;Flask-SQLite3&#39;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s">&#39;1.0&#39;</span><span class="p">,</span>
    <span class="n">url</span><span class="o">=</span><span class="s">&#39;http://example.com/flask-sqlite3/&#39;</span><span class="p">,</span>
    <span class="n">license</span><span class="o">=</span><span class="s">&#39;BSD&#39;</span><span class="p">,</span>
    <span class="n">author</span><span class="o">=</span><span class="s">&#39;Your Name&#39;</span><span class="p">,</span>
    <span class="n">author_email</span><span class="o">=</span><span class="s">&#39;your-email@example.com&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s">&#39;Very short description&#39;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="n">__doc__</span><span class="p">,</span>
    <span class="n">py_modules</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;flask_sqlite3&#39;</span><span class="p">],</span>
    <span class="c"># if you would be using a package instead use packages instead</span>
    <span class="c"># of py_modules:</span>
    <span class="c"># packages=[&#39;flask_sqlite3&#39;],</span>
    <span class="n">zip_safe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">include_package_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">platforms</span><span class="o">=</span><span class="s">&#39;any&#39;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
        <span class="s">&#39;Flask&#39;</span>
    <span class="p">],</span>
    <span class="n">classifiers</span><span class="o">=</span><span class="p">[</span>
        <span class="s">&#39;Environment :: Web Environment&#39;</span><span class="p">,</span>
        <span class="s">&#39;Intended Audience :: Developers&#39;</span><span class="p">,</span>
        <span class="s">&#39;License :: OSI Approved :: BSD License&#39;</span><span class="p">,</span>
        <span class="s">&#39;Operating System :: OS Independent&#39;</span><span class="p">,</span>
        <span class="s">&#39;Programming Language :: Python&#39;</span><span class="p">,</span>
        <span class="s">&#39;Topic :: Internet :: WWW/HTTP :: Dynamic Content&#39;</span><span class="p">,</span>
        <span class="s">&#39;Topic :: Software Development :: Libraries :: Python Modules&#39;</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>这有相当多的代码，但是你实际上可以从现有的扩展中直接复制/粘贴，并修改相应的
内容。</p>
</div>
<div class="section" id="flask-sqlite3-py">
<h5>flask_sqlite3.py<a class="headerlink" href="#flask-sqlite3-py" title="永久链接至标题">¶</a></h5>
<p>现在这个是你的扩展放代码的位置。但是这样一个扩展到底看起来是什么样？
最佳实践是什么？继续阅读，你会有一些认识。</p>
</div>
</div>
<div class="section" id="id2">
<h4>初始化扩展<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>许多扩展会需要某种类型的初始化步骤。比如，想象一个应用像文档中建议的一样
(<a class="reference internal" href="index.html#sqlite3"><em>在 Flask 中使用 SQLite 3</em></a>) 正在连接到 SQLite。那么，扩展如何获知应用对象的名称？</p>
<p>相当简单：你传递应用对象到它。</p>
<p>有两种推荐的初始化应用的方式:</p>
<p>初始化函数:</p>
<blockquote>
<div>如果你的扩展叫做 <cite>helloworld</cite> ，你应该有一个名为
<tt class="docutils literal"><span class="pre">init_helloworld(app[,</span> <span class="pre">extra_args])</span></tt> 的函数来为应用初始化扩展。它
可以附加在处理器前/后等位置。</div></blockquote>
<dl class="docutils">
<dt>类:</dt>
<dd>类的工作大多像初始化函数，但可以在之后进一步更改其行为。例如
<a class="reference external" href="http://packages.python.org/Flask-OAuth/">OAuth 扩展</a> 的工作方式，一个 <cite>OAuth</cite> 对象提供一些诸如
<cite>OAuth.remote_app</cite> 的助手函数来创建一个使用 OAuth 的远程应用的引用。</dd>
</dl>
<p>用什么取决于你想要什么。对于 SQLite 3 扩展，我们会使用基于类的方法，因为它
提供用户一个可以承担打开和关闭数据库连接的对象。</p>
<p>关于类，重要的是它们鼓励在模块层内共享。这种情况下，对象本身在任何情况下
不得存储任何应用的特定状态，而必须可以在不同的应用间共享。</p>
</div>
<div class="section" id="id3">
<h4>扩展的代码<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>下面是用来复制/粘贴的 <cite>flask_sqlite3.py</cite> 的内容:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span>

<span class="c"># Find the stack on which we want to store the database connection.</span>
<span class="c"># Starting with Flask 0.9, the _app_ctx_stack is the correct one,</span>
<span class="c"># before that we need to use the _request_ctx_stack.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">_app_ctx_stack</span> <span class="k">as</span> <span class="n">stack</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">_request_ctx_stack</span> <span class="k">as</span> <span class="n">stack</span>


<span class="k">class</span> <span class="nc">SQLite3</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span>
        <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">):</span>
        <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;SQLITE3_DATABASE&#39;</span><span class="p">,</span> <span class="s">&#39;:memory:&#39;</span><span class="p">)</span>
        <span class="c"># Use the newstyle teardown_appcontext if it&#39;s available,</span>
        <span class="c"># otherwise fall back to the request context</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="s">&#39;teardown_appcontext&#39;</span><span class="p">):</span>
            <span class="n">app</span><span class="o">.</span><span class="n">teardown_appcontext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">teardown</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">app</span><span class="o">.</span><span class="n">teardown_request</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">teardown</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;SQLITE3_DATABASE&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">teardown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">top</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">&#39;sqlite3_db&#39;</span><span class="p">):</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">sqlite3_db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">top</span>
        <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">&#39;sqlite3_db&#39;</span><span class="p">):</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">sqlite3_db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ctx</span><span class="o">.</span><span class="n">sqlite3_db</span>
</pre></div>
</div>
<p>那么这是这些代码做的事情:</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal"><span class="pre">__init__</span></tt> 方法接受一个可选的应用对象，并且如果提供，会调用 <tt class="docutils literal"><span class="pre">init_app</span></tt> 。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">init_app</span></tt> 方法使得 <tt class="docutils literal"><span class="pre">SQLite3</span></tt> 对象不需要应用对象就可以实例化。这个方法
支持工厂模式来创建应用。 <tt class="docutils literal"><span class="pre">init_app</span></tt> 会为数据库设定配置，如果不提供配置，默
认是一个内存中的数据库。此外， <tt class="docutils literal"><span class="pre">init_app</span></tt> 方法附加了 <tt class="docutils literal"><span class="pre">teardown</span></tt> 处理器。
它会试图使用新样式的应用上下文处理器，并且如果它不存在，退回到请求上下文处理
器。</p>
</li>
<li><p class="first">接下来，我们定义了 <tt class="docutils literal"><span class="pre">connect</span></tt> 方法来打开一个数据库连接。</p>
</li>
<li><p class="first">最后，我们添加一个 <tt class="docutils literal"><span class="pre">connection</span></tt> 属性，首次访问时打开数据库连接，并把它存储
在上下文。这也是处理资源的推荐方式：在资源第一次使用时惰性获取资源。</p>
<p>注意这里，我们把数据库连接通过 <tt class="docutils literal"><span class="pre">_app_ctx_stack.top</span></tt> 附加到应用上下文
的栈顶。扩展应该使用上下文的栈顶来存储它们自己的信息，并使用足够复杂的
名称。注意如果应用使用不支持它的老版本的 Flask 我们退回到
<tt class="docutils literal"><span class="pre">_request_ctx_stack.top</span></tt> 。</p>
</li>
</ol>
<p>那么为什么我们决定在此使用基于类的方法？因为使用我们的扩展的情况看起来
会是这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask_sqlite3</span> <span class="kn">import</span> <span class="n">SQLite3</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="s">&#39;the-config.cfg&#39;</span><span class="p">)</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">SQLite3</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>你之后可以在视图中这样使用数据库:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_all</span><span class="p">():</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>同样地，如果你在请求之外，而你在使用支持应用上下文 Flask 0.9 或之后的版本，
你可以用同样的方法使用数据库:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>在 <cite>with</cite> 块的最后，销毁处理器会自动执行。</p>
<p>此外， <tt class="docutils literal"><span class="pre">init_app</span></tt> 方法用于支持创建应用的工厂模式:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">db</span> <span class="o">=</span> <span class="n">Sqlite3</span><span class="p">()</span>
<span class="c"># Then later on.</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="s">&#39;the-config.cfg&#39;</span><span class="p">)</span>
<span class="n">db</span><span class="o">.</span><span class="n">init_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>记住已审核的 Flask 扩展需要支持用工厂模式来创建应用（下面会解释）。</p>
<div class="admonition-init-app admonition">
<p class="first admonition-title"><tt class="docutils literal"><span class="pre">init_app</span></tt> 的注意事项</p>
<p>如你所见， <tt class="docutils literal"><span class="pre">init_app</span></tt> 不分配 <tt class="docutils literal"><span class="pre">app</span></tt> 到 <tt class="docutils literal"><span class="pre">self</span></tt> 。这是故意的！基于
类的 Flask 扩展必须只在应用传递到构造函数时在对象上存储应用。这告诉扩
展：我对使用多个应用没有兴趣。</p>
<p class="last">当扩展需要找出当前的应用且它没有一个指向其的引用时，必须使用
<a class="reference internal" href="index.html#flask.current_app" title="flask.current_app"><tt class="xref py py-data docutils literal"><span class="pre">current_app</span></tt></a> 上下文局域变量或用一种你可以显式传递应用的
方法更改 API 。</p>
</div>
</div>
<div class="section" id="app-ctx-stack">
<h4>使用 _app_ctx_stack<a class="headerlink" href="#app-ctx-stack" title="永久链接至标题">¶</a></h4>
<p>在上面的例子中，在每个请求之前，一个 <tt class="docutils literal"><span class="pre">sqlite3_db</span></tt> 被分配到
<tt class="docutils literal"><span class="pre">_app_ctx_stack.top</span></tt> 。在一个视图函数中，这个变量可以使用 <tt class="docutils literal"><span class="pre">SQLite3</span></tt>
的属性 <tt class="docutils literal"><span class="pre">connection</span></tt> 来访问。在请求销毁时， <tt class="docutils literal"><span class="pre">sqlite3_db</span></tt> 连接被关闭。
通过使用这个模式， <em>相同</em> 的 sqlite3 数据库连接在请求期间对任何需要它的东
西都是可访问的。</p>
<p>如果 <a class="reference internal" href="index.html#flask._app_ctx_stack" title="flask._app_ctx_stack"><tt class="xref py py-data docutils literal"><span class="pre">_app_ctx_stack</span></tt></a> 因为用户使用了老版本的 Flask 不存在，
建议退化到限定在请求中的 <a class="reference internal" href="index.html#flask._request_ctx_stack" title="flask._request_ctx_stack"><tt class="xref py py-data docutils literal"><span class="pre">_request_ctx_stack</span></tt></a> 。</p>
</div>
<div class="section" id="id4">
<h4>销毁行为<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><em>这只在你想要支持 Flask 0.6 和更老版本时有关</em></p>
<p>由于在 Flask 0.7 中关于在请求的最后运行的函数的变更，你的应用需要在此格外
小心，如果要继续支持 Flask 的更老版本。下面的模式是一个兼顾新旧的好方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">close_connection</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">top</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">sqlite3_db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="s">&#39;teardown_request&#39;</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">teardown_request</span><span class="p">(</span><span class="n">close_connection</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">after_request</span><span class="p">(</span><span class="n">close_connection</span><span class="p">)</span>
</pre></div>
</div>
<p>严格地讲，上面的代码是错误的，因为销毁函数接受异常且典型地不返回任何东西。
尽管如此，因为返回值被丢弃，这刚好会工作，假设中间的代码不触碰传递的参数。</p>
</div>
<div class="section" id="id5">
<h4>他山之石，可以攻玉<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>本文档只接触了扩展开发中绝对的最小部分，如果你想要了解更多，一个非常好的
主意是查看 <a class="reference external" href="http://flask.pocoo.org/extensions/">Flask Extension Registry</a> 上已有的扩展。如果你感到失落，也有
<a class="reference external" href="http://flask.pocoo.org/mailinglist/">邮件列表</a>  和 <a class="reference external" href="http://flask.pocoo.org/community/irc/">IRC 频道</a> 来获取一些漂亮 API 的想法。特别是当你在做之前
没人做过的东西，这会是一个非常好的主意来获得更多投入。这不仅获得人们会想
从扩展中得到什么的想法，也可避免多个开发者重复发明轮子。</p>
<p>记住：良好的 API 设计是困难的，所以请在邮件列表里介绍你的项目，让
其它开发者在 API 设计上助你一臂之力。</p>
<p>最好的 Flask 扩展是那些为 API 共享通用风格的扩展，并且这只在起初就协作时
奏效。</p>
</div>
<div class="section" id="id6">
<h4>已审核的扩展<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>Flask 也有已审核的扩展的概念。已审核的扩展被作为 Flask 自身的一部分来测
试来保证在新版本中不会破坏。这些已审核的扩展会在
<a class="reference external" href="http://flask.pocoo.org/extensions/">Flask Extension Registry</a> 中列出，并有相应的标记。如果你想要自己的扩展
通过审核，你需要遵守下面的指导方针:</p>
<ol class="arabic simple" start="0">
<li>一个通过审核的 Flask 扩展需要一个维护者。如果一个扩展作者想要超越项目，
项目应该寻找一个新的维护者，包括完整的源码托管过渡和 PyPI 访问。如果没
有可用的维护者，请给 Flask 核心团队访问权限。</li>
<li>一个通过审核的 Flask 扩展必须确切地提供一个名为 <tt class="docutils literal"><span class="pre">flask_extensioname</span></tt> 的
包或模块。它们也可能驻留在 <tt class="docutils literal"><span class="pre">flaskext</span></tt> 命名空间包内部，虽然现在这不被推荐。</li>
<li>它必须伴随一个可以使用 <tt class="docutils literal"><span class="pre">make</span> <span class="pre">test</span></tt> 或 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">test</span></tt> 的调用测
试套件。对于用 <tt class="docutils literal"><span class="pre">make</span> <span class="pre">test</span></tt> 测试的套件，扩展必须确保所有测试需要的依赖关
系都被自动处理好。如果测试由 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">test</span></tt> 调用，测试的依赖关系
由 <cite>setup.py</cite> 文件指定。测试套件也必须是发行版的一部分。</li>
<li>通过审核的扩展的 API 可以通过下面特性的检查:
- 一个通过审核的扩展必须支持在同一个 Python 进程中支持多个应用
- 必须支持使用工厂模式创建应用</li>
<li>必须以 BSD/MIT/WTFPL 许可</li>
<li>官方扩展的命名模式是 <em>Flask-ExtensionName</em> 或 <em>ExtensionName-Flask</em></li>
<li>通过审核的扩展必须在 <cite>setup.py</cite> 文件里定义好它们的依赖关系，除非因
其在 PyPI 上不可用而不能满足这个依赖。</li>
<li>扩展的文档必须使用两种 Flask 的 Sphinx 文档主题中的一个</li>
<li>setup.py 描述（因此PyPI 描述同）必须链接到文档、网站（如果有），
并且必须有一个链接来自动安装开发版本（ <tt class="docutils literal"><span class="pre">PackageName==dev</span></tt> ）</li>
<li>安装脚本中的 <tt class="docutils literal"><span class="pre">zip_safe</span></tt> 标志必须被设置为 <tt class="docutils literal"><span class="pre">False</span></tt> ，即使扩展对于
压缩是安全的</li>
<li>现行扩展必须支持 Python 2.6 以及 2.7</li>
</ol>
</div>
<div class="section" id="ext-import-transition">
<span id="id7"></span><h4>扩展导入的过渡<a class="headerlink" href="#ext-import-transition" title="永久链接至标题">¶</a></h4>
<p>一段时间，我们推荐对 Flask 扩展使用命名空间包。这在实践中被证明是有问题
的，因为许多不同命名空间包系统存在竞争，并且 pip 会自动在不同的系统中切
换，这给用户导致了许多问题。</p>
<p>现在，我们推荐命名包为 <tt class="docutils literal"><span class="pre">flask_foo</span></tt> 替代过时的 <tt class="docutils literal"><span class="pre">flaskext.foo</span></tt> 。Flask
0.8 引入了重定向导入系统，允许从 <tt class="docutils literal"><span class="pre">flask.ext.foo</span></tt> 导入，并且如果
<tt class="docutils literal"><span class="pre">flaskext.foo</span></tt> 失败时，会首先尝试 <tt class="docutils literal"><span class="pre">flask_foo</span></tt> 。</p>
<p>Flask 扩展应该力劝用户从 <tt class="docutils literal"><span class="pre">flask.ext.foo</span></tt> 导入，而不是 <tt class="docutils literal"><span class="pre">flask_foo</span></tt>
或 <tt class="docutils literal"><span class="pre">flaskext_foo</span></tt> ，这样扩展可以迁移到新的包名称而不烦扰用户。</p>
</div>
</div>
<span id="document-styleguide"></span><div class="section" id="pocoo">
<h3>Pocoo 风格指引<a class="headerlink" href="#pocoo" title="永久链接至标题">¶</a></h3>
<p>Pocoo 风格指引是所有 Pocoo 项目的风格指引，包括 Flask 。这份风格指引
在 Flask 补丁中是必须的，并且推荐在 Flask 扩展中使用。</p>
<p>一般而言， Pocoo 风格指引遵循 <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> ，有一些小差异和扩充。</p>
<div class="section" id="id1">
<h4>总体布局<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<dl class="docutils">
<dt>缩进:</dt>
<dd>4个空格。没有制表符，没有例外。</dd>
<dt>最大行长:</dt>
<dd>79字符，软限制是 84 ，如果绝对必要。尝试合理放置 <cite>break</cite> 、 <cite>continue</cite>
和 <cite>return</cite> 声明来避免代码过度嵌套。</dd>
<dt>可续长语句:</dt>
<dd><p class="first">你可以使用反斜线来继续一个语句，在这种情况下，你应该对齐下一行到最后一个
点或等号或缩进四个空格:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">this_is_a_very_long</span><span class="p">(</span><span class="n">function_call</span><span class="p">,</span> <span class="s">&#39;with many parameters&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">that_returns_an_object_with_an_attribute</span>

<span class="n">MyModel</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">MyModel</span><span class="o">.</span><span class="n">scalar</span> <span class="o">&gt;</span> <span class="mi">120</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">MyModel</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span> \
             <span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>如果在一个带括号的语句中换行，对齐到括号:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">this_is_a_very_long</span><span class="p">(</span><span class="n">function_call</span><span class="p">,</span> <span class="s">&#39;with many parameters&#39;</span><span class="p">,</span>
                    <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="s">&#39;and even more&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>对于有许多元素的元组或列表，在起始括号后立即换行:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">items</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;this is the first&#39;</span><span class="p">,</span> <span class="s">&#39;set of items&#39;</span><span class="p">,</span> <span class="s">&#39;with more items&#39;</span><span class="p">,</span>
    <span class="s">&#39;to come in this line&#39;</span><span class="p">,</span> <span class="s">&#39;like this&#39;</span>
<span class="p">]</span>
</pre></div>
</div>
</dd>
<dt>空行:</dt>
<dd><p class="first">顶层函数和类由两个空行分隔，其它东西一行。不要使用太多的空行来分隔
代码中的逻辑段。示例:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;Hello </span><span class="si">%s</span><span class="s">!&#39;</span> <span class="o">%</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">goodbye</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;See you </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">name</span>


<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a simple docstring&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">get_annoying_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#39;!!!!111&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id2">
<h4>表达式和语句<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<dl class="docutils">
<dt>常规空格规则:</dt>
<dd><ul class="first simple">
<li>不对一元运算符使用空格（例如 <tt class="docutils literal"><span class="pre">-</span></tt> 、 <tt class="docutils literal"><span class="pre">~</span></tt> 等等），对圆括号同理</li>
<li>在二元运算符间使用空格</li>
</ul>
<p>Good</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">exp</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.05</span>
<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">item_value</span> <span class="o">/</span> <span class="n">item_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">exp</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">my_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">my_dict</span><span class="p">[</span><span class="s">&#39;key&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Bad</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">exp</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">1.05</span>
<span class="n">value</span> <span class="o">=</span> <span class="p">(</span> <span class="n">item_value</span> <span class="o">/</span> <span class="n">item_count</span> <span class="p">)</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">exp</span>
<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">item_value</span><span class="o">/</span><span class="n">item_count</span><span class="p">)</span><span class="o">*</span><span class="n">offset</span><span class="o">/</span><span class="n">exp</span>
<span class="n">value</span><span class="o">=</span><span class="p">(</span> <span class="n">item_value</span><span class="o">/</span><span class="n">item_count</span> <span class="p">)</span> <span class="o">*</span> <span class="n">offset</span><span class="o">/</span><span class="n">exp</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">my_list</span><span class="p">[</span> <span class="n">index</span> <span class="p">]</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">my_dict</span> <span class="p">[</span><span class="s">&#39;key&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt>禁止使用 Yoda 语句:</dt>
<dd><p class="first">永远不要用变量与常量做比较，而是把常量与变量做比较:</p>
<p>God</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;md5&#39;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Bad</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="s">&#39;md5&#39;</span> <span class="o">==</span> <span class="n">method</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</dd>
<dt>比较:</dt>
<dd><ul class="first last simple">
<li>跟任意类型: <tt class="docutils literal"><span class="pre">==</span></tt> 和 <tt class="docutils literal"><span class="pre">!=</span></tt></li>
<li>跟单例，使用 <tt class="docutils literal"><span class="pre">is</span></tt> 和 <tt class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></tt> （例如 <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></tt> ）</li>
<li>永远不要与 <cite>True</cite> 或 <cite>False</cite> 做比较（比如永远不要写
<tt class="docutils literal"><span class="pre">foo</span> <span class="pre">==</span> <span class="pre">False</span></tt> ，而使用 <tt class="docutils literal"><span class="pre">not</span> <span class="pre">foo</span></tt> ）</li>
</ul>
</dd>
<dt>否定包含检查:</dt>
<dd>使用 <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">bar</span></tt> 而不是 <tt class="docutils literal"><span class="pre">not</span> <span class="pre">foo</span> <span class="pre">in</span> <span class="pre">bar</span></tt></dd>
<dt>实例检查:</dt>
<dd>用 <tt class="docutils literal"><span class="pre">isinstance(a,</span> <span class="pre">C)</span></tt> 而不是 <tt class="docutils literal"><span class="pre">type(A)</span> <span class="pre">is</span> <span class="pre">C</span></tt> ， 但通常试图避免
实例检查，请对特性检查。</dd>
</dl>
</div>
<div class="section" id="id3">
<h4>命名约定<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>类名: <tt class="docutils literal"><span class="pre">CamelCase</span></tt> ，缩写词大写（ <tt class="docutils literal"><span class="pre">HTTPWriter</span></tt> 而非 <tt class="docutils literal"><span class="pre">HttpWriter</span></tt> ）</li>
<li>变量名: <tt class="docutils literal"><span class="pre">lowercase_with_underscores</span></tt></li>
<li>方法和函数名: <tt class="docutils literal"><span class="pre">lowercase_with_underscores</span></tt></li>
<li>常量: <tt class="docutils literal"><span class="pre">UPPERCASE_WITH_UNDERSCORES</span></tt></li>
<li>预编译正则表达式: <tt class="docutils literal"><span class="pre">name_re</span></tt></li>
</ul>
<p>被保护的成员以单个下划线作为前缀，双下划线为 mixin 类保留。</p>
<p>有关键字的类上，在末尾添加下划线。允许与内置组建冲突，并且
<strong>一定不要</strong> 在用在变量名后添加下划线的方式解决。如果函数需要访问一个隐蔽
的内置构件，重绑定内置构件到一个不同的名字作为替代。</p>
<dl class="docutils">
<dt>函数和方法参数:</dt>
<dd><ul class="first last simple">
<li>类方法: <tt class="docutils literal"><span class="pre">cls</span></tt> 作为第一个参数</li>
<li>实例方法: <tt class="docutils literal"><span class="pre">self</span></tt> 作为第一个参数</li>
<li>属性的 lambda 表达式应该把第一个参数替换为 <tt class="docutils literal"><span class="pre">x</span></tt> ，像 <tt class="docutils literal"><span class="pre">display_name</span> <span class="pre">=</span>
<span class="pre">property(lambda</span> <span class="pre">x:</span> <span class="pre">x.real_name</span> <span class="pre">or</span> <span class="pre">x.username)</span></tt> 中一样</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id4">
<h4>文档注释<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<dl class="docutils">
<dt>文档字符串约定:</dt>
<dd><p class="first">所有的文档注释应为 Sphinx 可理解的 reStructuredText 格式，其格式根据注释行数而变化。
如果只有一行，闭合的三引号和开头的三引号在同一行，
否则开头的三引号与文本在同一行，而闭合的三引号另起一行:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;This is a simple docstring&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;This is a longer docstring with so much information in there</span>
<span class="sd">    that it spans three lines.  In this case the closing triple quote</span>
<span class="sd">    is on its own line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
</dd>
<dt>模块标头:</dt>
<dd><p class="first">模块标头包含一个 utf-8 编码声明（即使没有使用非 ASCII 字符，也始终推荐这么做）
和一个标准的文档注释:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    package.module</span>
<span class="sd">    ~~~~~~~~~~~~~~</span>

<span class="sd">    A brief description goes here.</span>

<span class="sd">    :copyright: (c) YEAR by AUTHOR.</span>
<span class="sd">    :license: LICENSE_NAME, see LICENSE_FILE for more details.</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p class="last">请留意，合适的版权和许可证文件对于 Flask 扩展通过审核是必须的。</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>注释<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>注释的规则和文档注释类似。两者都使用 reStructuredText 格式。如果一个
注释被用于一个属性的文档，在起始的井号（ <tt class="docutils literal"><span class="pre">#</span></tt> ）后加一个冒号:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c">#: the name of the user as unicode string</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="c">#: the sha1 hash of the password + inline salt</span>
    <span class="n">pw_hash</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-python3"></span><div class="section" id="python-3">
<span id="python3-support"></span><h3>Python 3 支持<a class="headerlink" href="#python-3" title="永久链接至标题">¶</a></h3>
<p>Flask 与其所有依赖包都支持 Python 3，所以理论上你已经可以在 Python 3 中
工作了。尽管如此，在你开始为新项目采用 Python 3 之前，仍有一些事情应该
了解。</p>
<div class="section" id="id1">
<h4>需求<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>如果你想要在 Python 3 中使用 Flask，你需要安装 Python 3.3 或更高的版本。
<em>不支持</em> 3.2 及更古老版本。</p>
<p>此外你需要使用最新且最大版本的 <cite>itsdangerous</cite> 、 <cite>Jinja2</cite> 和
<cite>Werkzeug</cite> 。</p>
</div>
<div class="section" id="api">
<h4>API 稳定性<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h4>
<p>Python 3 中做出的一些关于 Unicode 和 byte 的修改使得编写底层
代码变得困难。这主要影响 WSGI 中间件和与 WSGI 所提供信息的交互。Werkzeug
把所有 WSGI 信息封转成高层的辅助函数，但其中的一些是特地为 Python 3 支持而
新添加的。</p>
<p>很多关于 WSGI 使用的文档是在 WSGI 升级至 Python 3 编写的，未顾及这些细节。
虽然 Werkzeug 和 Flask 在 Python 2.x 中的 API 不会做出大改动，但我们不能保
证 Python 3 中不会发生。</p>
</div>
<div class="section" id="id2">
<h4>少数派<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>根据 PyPI 下载统计，Python 3 用户只有不足 Python 2 用户的 1%。因此，你遭遇的
Python 3 特定的问题将很难在网上搜索到。</p>
</div>
<div class="section" id="id3">
<h4>小生态系统<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>大多数的 Flask 扩展、所有的文档和绝大多数 PyPI 提供的库尚未支持 Python 3。
即使你在已知所有所需要的都支持 Python 3 的情况下开始项目，你也不知道接下来
的 6 个月发生什么。如果你富有冒险精神，你可以开始自行移植那些库，但意志薄弱者
则无计可施。</p>
</div>
<div class="section" id="id4">
<h4>建议<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>除非你已经熟悉各个版本的差异，否则，我们推荐在生态系统完善前，固守当前版
本的 Python。</p>
<p>大多数升级的痛苦在于诸如 Flask 和 Werkzeug 这样的底层库，而非实际的高层应用代码中。
例如 Flask 代码库中所有的 Flask 实例无需修改一行代码就可以在 2.x 和 3.x 中良好运行。</p>
</div>
</div>
<span id="document-upgrading"></span><div class="section" id="id1">
<h3>升级到最新版本<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>Flask 如同其它软件一样，会随着时间不停地更新自己，其中大部分都会是非常体贴的，
你无需改动一行自身代码就可以应用新版本的 Flask。</p>
<p>不过，每当 Flask 有更新时，我们都建议你适当地修改自己的代码，以充分地利用这些新功能，
提高自己代码地质量。</p>
<p>本章节文档为您列举了 Flask 各版本之间地差异，以及你如何修改自身代码才能无痛地升级。</p>
<p>如果你使用 <cite>easy_install</cite> 命令更新、安装 Flask，确保命令中包括 <tt class="docutils literal"><span class="pre">-U</span></tt> 参数</p>
<div class="highlight-python"><pre>$ easy_install -U Flask</pre>
</div>
<div class="section" id="version-0-10">
<span id="upgrading-to-010"></span><h4>Version 0.10<a class="headerlink" href="#version-0-10" title="永久链接至标题">¶</a></h4>
<p>版本 0.9 到 0.10 最大变化在于 cookie 序列化格式从 pickle 转变为了专门的 JSON 格式，
这一更新是为了避免密钥丢失时遭受黑客攻击带来损失。在更新是你会注意到以下两大主要变化：
all sessions that were issued before the upgrade are invalidated and you can
only store a limited amount of types in the session.  The new sessions are
by design much more restricted to only allow JSON with a few small
extensions for tuples and strings with HTML markup.</p>
<p>为了避免破坏用户的 session 数据，你可以使用 Flask 扩展 <cite>Flask-OldSessions_</cite> 来代替原先的 session。</p>
</div>
<div class="section" id="version-0-9">
<h4>Version 0.9<a class="headerlink" href="#version-0-9" title="永久链接至标题">¶</a></h4>
<p>从函数中返回元组的操作被简化了，返回元组时你不再需要为你创建的 response 对象定义参数了，
The behavior of returning tuples from a function was simplified.  If you
return a tuple it no longer defines the arguments for the response object
you&#8217;re creating, it&#8217;s now always a tuple in the form <tt class="docutils literal"><span class="pre">(response,</span> <span class="pre">status,</span>
<span class="pre">headers)</span></tt> where at least one item has to be provided.
如果你的代码依赖于旧版本，可以通过创建 Flask 的子类简单地解决这个问题</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TraditionalFlask</span><span class="p">(</span><span class="n">Flask</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">make_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rv</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_class</span><span class="p">(</span><span class="o">*</span><span class="n">rv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Flask</span><span class="o">.</span><span class="n">make_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你维护的扩展曾使用 <a class="reference internal" href="index.html#flask._request_ctx_stack" title="flask._request_ctx_stack"><tt class="xref py py-data docutils literal"><span class="pre">_request_ctx_stack</span></tt></a> ，可以考虑降至替换为
<a class="reference internal" href="index.html#flask._app_ctx_stack" title="flask._app_ctx_stack"><tt class="xref py py-data docutils literal"><span class="pre">_app_ctx_stack</span></tt></a>，但仍须检查是否可行。例如，对于操作数据的扩展来说，app context stack
更说得通，在请求无关的用例中使用它比 request stack 处理起来更容易。</p>
</div>
<div class="section" id="version-0-8">
<h4>Version 0.8<a class="headerlink" href="#version-0-8" title="永久链接至标题">¶</a></h4>
<p>Flask introduced a new session interface system.  We also noticed that
there was a naming collision between <cite>flask.session</cite> the module that
implements sessions and <a class="reference internal" href="index.html#flask.session" title="flask.session"><tt class="xref py py-data docutils literal"><span class="pre">flask.session</span></tt></a> which is the global session
object.  With that introduction we moved the implementation details for
the session system into a new module called <tt class="xref py py-mod docutils literal"><span class="pre">flask.sessions</span></tt>.  If you
used the previously undocumented session support we urge you to upgrade.</p>
<p>If invalid JSON data was submitted Flask will now raise a
<a class="reference external" href="http://werkzeug.pocoo.org/docs/exceptions/#werkzeug.exceptions.BadRequest" title="(在 Werkzeug v0.10)"><tt class="xref py py-exc docutils literal"><span class="pre">BadRequest</span></tt></a> exception instead of letting the
default <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#ValueError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> bubble up.  This has the advantage that you no
longer have to handle that error to avoid an internal server error showing
up for the user.  If you were catching this down explicitly in the past
as <cite>ValueError</cite> you will need to change this.</p>
<p>Due to a bug in the test client Flask 0.7 did not trigger teardown
handlers when the test client was used in a with statement.  This was
since fixed but might require some changes in your testsuites if you
relied on this behavior.</p>
</div>
<div class="section" id="version-0-7">
<h4>Version 0.7<a class="headerlink" href="#version-0-7" title="永久链接至标题">¶</a></h4>
<p>In Flask 0.7 we cleaned up the code base internally a lot and did some
backwards incompatible changes that make it easier to implement larger
applications with Flask.  Because we want to make upgrading as easy as
possible we tried to counter the problems arising from these changes by
providing a script that can ease the transition.</p>
<p>The script scans your whole application and generates an unified diff with
changes it assumes are safe to apply.  However as this is an automated
tool it won&#8217;t be able to find all use cases and it might miss some.  We
internally spread a lot of deprecation warnings all over the place to make
it easy to find pieces of code that it was unable to upgrade.</p>
<p>We strongly recommend that you hand review the generated patchfile and
only apply the chunks that look good.</p>
<p>If you are using git as version control system for your project we
recommend applying the patch with <tt class="docutils literal"><span class="pre">path</span> <span class="pre">-p1</span> <span class="pre">&lt;</span> <span class="pre">patchfile.diff</span></tt> and then
using the interactive commit feature to only apply the chunks that look
good.</p>
<p>To apply the upgrade script do the following:</p>
<ol class="arabic">
<li><p class="first">Download the script: <a class="reference external" href="https://raw.github.com/mitsuhiko/flask/master/scripts/flask-07-upgrade.py">flask-07-upgrade.py</a></p>
</li>
<li><p class="first">Run it in the directory of your application:</p>
<div class="highlight-python"><pre>python flask-07-upgrade.py &gt; patchfile.diff</pre>
</div>
</li>
<li><p class="first">Review the generated patchfile.</p>
</li>
<li><p class="first">Apply the patch:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">patch</span> <span class="o">-</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="n">patchfile</span><span class="o">.</span><span class="n">diff</span>
</pre></div>
</div>
</li>
<li><p class="first">If you were using per-module template folders you need to move some
templates around.  Previously if you had a folder named <tt class="docutils literal"><span class="pre">templates</span></tt>
next to a blueprint named <tt class="docutils literal"><span class="pre">admin</span></tt> the implicit template path
automatically was <tt class="docutils literal"><span class="pre">admin/index.html</span></tt> for a template file called
<tt class="docutils literal"><span class="pre">templates/index.html</span></tt>.  This no longer is the case.  Now you need
to name the template <tt class="docutils literal"><span class="pre">templates/admin/index.html</span></tt>.  The tool will
not detect this so you will have to do that on your own.</p>
</li>
</ol>
<p>Please note that deprecation warnings are disabled by default starting
with Python 2.7.  In order to see the deprecation warnings that might be
emitted you have to enabled them with the <a class="reference external" href="http://docs.python.org/dev/library/warnings.html#module-warnings" title="(在 Python v3.5)"><tt class="xref py py-mod docutils literal"><span class="pre">warnings</span></tt></a> module.</p>
<p>If you are working with windows and you lack the <cite>patch</cite> command line
utility you can get it as part of various Unix runtime environments for
windows including cygwin, msysgit or ming32.  Also source control systems
like svn, hg or git have builtin support for applying unified diffs as
generated by the tool.  Check the manual of your version control system
for more information.</p>
<div class="section" id="bug-in-request-locals">
<h5>Bug in Request Locals<a class="headerlink" href="#bug-in-request-locals" title="永久链接至标题">¶</a></h5>
<p>Due to a bug in earlier implementations the request local proxies now
raise a <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#RuntimeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> instead of an <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#AttributeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> when they
are unbound.  If you caught these exceptions with <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#AttributeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a>
before, you should catch them with <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#RuntimeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> now.</p>
<p>Additionally the <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> function is now issuing
deprecation warnings if you depend on functionality that will be removed
in Flask 1.0.  Previously it was possible to use etags and mimetypes
when file objects were passed.  This was unreliable and caused issues
for a few setups.  If you get a deprecation warning, make sure to
update your application to work with either filenames there or disable
etag attaching and attach them yourself.</p>
<p>Old code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">return</span> <span class="n">send_file</span><span class="p">(</span><span class="n">my_file_object</span><span class="p">)</span>
<span class="k">return</span> <span class="n">send_file</span><span class="p">(</span><span class="n">my_file_object</span><span class="p">)</span>
</pre></div>
</div>
<p>New code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">return</span> <span class="n">send_file</span><span class="p">(</span><span class="n">my_file_object</span><span class="p">,</span> <span class="n">add_etags</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="upgrading-to-new-teardown-handling">
<span id="id2"></span><h5>Upgrading to new Teardown Handling<a class="headerlink" href="#upgrading-to-new-teardown-handling" title="永久链接至标题">¶</a></h5>
<p>We streamlined the behavior of the callbacks for request handling.  For
things that modify the response the <a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a>
decorators continue to work as expected, but for things that absolutely
must happen at the end of request we introduced the new
<a class="reference internal" href="index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><tt class="xref py py-meth docutils literal"><span class="pre">teardown_request()</span></tt></a> decorator.  Unfortunately that
change also made after-request work differently under error conditions.
It&#8217;s not consistently skipped if exceptions happen whereas previously it
might have been called twice to ensure it is executed at the end of the
request.</p>
<p>If you have database connection code that looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.after_request</span>
<span class="k">def</span> <span class="nf">after_request</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p>You are now encouraged to use this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.teardown_request</span>
<span class="k">def</span> <span class="nf">after_request</span><span class="p">(</span><span class="n">exception</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;db&#39;</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>On the upside this change greatly improves the internal code flow and
makes it easier to customize the dispatching and error handling.  This
makes it now a lot easier to write unit tests as you can prevent closing
down of database connections for a while.  You can take advantage of the
fact that the teardown callbacks are called when the response context is
removed from the stack so a test can query the database after request
handling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
    <span class="c"># g.db is still bound if there is such a thing</span>

<span class="c"># and here it&#39;s gone</span>
</pre></div>
</div>
</div>
<div class="section" id="manual-error-handler-attaching">
<h5>Manual Error Handler Attaching<a class="headerlink" href="#manual-error-handler-attaching" title="永久链接至标题">¶</a></h5>
<p>While it is still possible to attach error handlers to
<tt class="xref py py-attr docutils literal"><span class="pre">Flask.error_handlers</span></tt> it&#8217;s discouraged to do so and in fact
deprecated.  In generaly we no longer recommend custom error handler
attaching via assignments to the underlying dictionary due to the more
complex internal handling to support arbitrary exception classes and
blueprints.  See <tt class="xref py py-meth docutils literal"><span class="pre">Flask.errorhandler()</span></tt> for more information.</p>
<p>The proper upgrade is to change this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">error_handlers</span><span class="p">[</span><span class="mi">403</span><span class="p">]</span> <span class="o">=</span> <span class="n">handle_error</span>
</pre></div>
</div>
<p>Into this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">register_error_handler</span><span class="p">(</span><span class="mi">403</span><span class="p">,</span> <span class="n">handle_error</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively you should just attach the function with a decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">403</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>(Note that <tt class="xref py py-meth docutils literal"><span class="pre">register_error_handler()</span></tt> is new in Flask 0.7)</p>
</div>
<div class="section" id="blueprint-support">
<h5>Blueprint Support<a class="headerlink" href="#blueprint-support" title="永久链接至标题">¶</a></h5>
<p>Blueprints replace the previous concept of “Modules” in Flask.  They
provide better semantics for various features and work better with large
applications.  The update script provided should be able to upgrade your
applications automatically, but there might be some cases where it fails
to upgrade.  What changed?</p>
<ul class="simple">
<li>Blueprints need explicit names.  Modules had an automatic name
guesssing scheme where the shortname for the module was taken from the
last part of the import module.  The upgrade script tries to guess
that name but it might fail as this information could change at
runtime.</li>
<li>Blueprints have an inverse behavior for <tt class="xref py py-meth docutils literal"><span class="pre">url_for()</span></tt>.  Previously
<tt class="docutils literal"><span class="pre">.foo</span></tt> told <tt class="xref py py-meth docutils literal"><span class="pre">url_for()</span></tt> that it should look for the endpoint
<cite>foo</cite> on the application.  Now it means “relative to current module”.
The script will inverse all calls to <tt class="xref py py-meth docutils literal"><span class="pre">url_for()</span></tt> automatically for
you.  It will do this in a very eager way so you might end up with
some unnecessary leading dots in your code if you&#8217;re not using
modules.</li>
<li>Blueprints do not automatically provide static folders.  They will
also no longer automatically export templates from a folder called
<cite>templates</cite> next to their location however but it can be enabled from
the constructor.  Same with static files: if you want to continue
serving static files you need to tell the constructor explicitly the
path to the static folder (which can be relative to the blueprint&#8217;s
module path).</li>
<li>Rendering templates was simplified.  Now the blueprints can provide
template folders which are added to a general template searchpath.
This means that you need to add another subfolder with the blueprint&#8217;s
name into that folder if you want <tt class="docutils literal"><span class="pre">blueprintname/template.html</span></tt> as
the template name.</li>
</ul>
<p>If you continue to use the <cite>Module</cite> object which is deprecated, Flask will
restore the previous behavior as good as possible.  However we strongly
recommend upgrading to the new blueprints as they provide a lot of useful
improvement such as the ability to attach a blueprint multiple times,
blueprint specific error handlers and a lot more.</p>
</div>
</div>
<div class="section" id="version-0-6">
<h4>Version 0.6<a class="headerlink" href="#version-0-6" title="永久链接至标题">¶</a></h4>
<p>Flask 0.6 comes with a backwards incompatible change which affects the
order of after-request handlers.  Previously they were called in the order
of the registration, now they are called in reverse order.  This change
was made so that Flask behaves more like people expected it to work and
how other systems handle request pre- and postprocessing.  If you
depend on the order of execution of post-request functions, be sure to
change the order.</p>
<p>Another change that breaks backwards compatibility is that context
processors will no longer override values passed directly to the template
rendering function.  If for example <cite>request</cite> is as variable passed
directly to the template, the default context processor will not override
it with the current request object.  This makes it easier to extend
context processors later to inject additional variables without breaking
existing template not expecting them.</p>
</div>
<div class="section" id="version-0-5">
<h4>Version 0.5<a class="headerlink" href="#version-0-5" title="永久链接至标题">¶</a></h4>
<p>Flask 0.5 is the first release that comes as a Python package instead of a
single module.  There were a couple of internal refactoring so if you
depend on undocumented internal details you probably have to adapt the
imports.</p>
<p>The following changes may be relevant to your application:</p>
<ul class="simple">
<li>autoescaping no longer happens for all templates.  Instead it is
configured to only happen on files ending with <tt class="docutils literal"><span class="pre">.html</span></tt>, <tt class="docutils literal"><span class="pre">.htm</span></tt>,
<tt class="docutils literal"><span class="pre">.xml</span></tt> and <tt class="docutils literal"><span class="pre">.xhtml</span></tt>.  If you have templates with different
extensions you should override the
<a class="reference internal" href="index.html#flask.Flask.select_jinja_autoescape" title="flask.Flask.select_jinja_autoescape"><tt class="xref py py-meth docutils literal"><span class="pre">select_jinja_autoescape()</span></tt></a> method.</li>
<li>Flask no longer supports zipped applications in this release.  This
functionality might come back in future releases if there is demand
for this feature.  Removing support for this makes the Flask internal
code easier to understand and fixes a couple of small issues that make
debugging harder than necessary.</li>
<li>The <cite>create_jinja_loader</cite> function is gone.  If you want to customize
the Jinja loader now, use the
<a class="reference internal" href="index.html#flask.Flask.create_jinja_environment" title="flask.Flask.create_jinja_environment"><tt class="xref py py-meth docutils literal"><span class="pre">create_jinja_environment()</span></tt></a> method instead.</li>
</ul>
</div>
<div class="section" id="version-0-4">
<h4>Version 0.4<a class="headerlink" href="#version-0-4" title="永久链接至标题">¶</a></h4>
<p>For application developers there are no changes that require changes in
your code.  In case you are developing on a Flask extension however, and
that extension has a unittest-mode you might want to link the activation
of that mode to the new <tt class="docutils literal"><span class="pre">TESTING</span></tt> flag.</p>
</div>
<div class="section" id="version-0-3">
<h4>Version 0.3<a class="headerlink" href="#version-0-3" title="永久链接至标题">¶</a></h4>
<p>Flask 0.3 introduces configuration support and logging as well as
categories for flashing messages.  All these are features that are 100%
backwards compatible but you might want to take advantage of them.</p>
<div class="section" id="configuration-support">
<h5>Configuration Support<a class="headerlink" href="#configuration-support" title="永久链接至标题">¶</a></h5>
<p>The configuration support makes it easier to write any kind of application
that requires some sort of configuration.  (Which most likely is the case
for any application out there).</p>
<p>If you previously had code like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">DEBUG</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="n">SECRET_KEY</span>
</pre></div>
</div>
<p>You no longer have to do that, instead you can just load a configuration
into the config object.  How this works is outlined in <a class="reference internal" href="index.html#config"><em>配置处理</em></a>.</p>
</div>
<div class="section" id="logging-integration">
<h5>Logging Integration<a class="headerlink" href="#logging-integration" title="永久链接至标题">¶</a></h5>
<p>Flask now configures a logger for you with some basic and useful defaults.
If you run your application in production and want to profit from
automatic error logging, you might be interested in attaching a proper log
handler.  Also you can start logging warnings and errors into the logger
when appropriately.  For more information on that, read
<a class="reference internal" href="index.html#application-errors"><em>记录应用错误</em></a>.</p>
</div>
<div class="section" id="categories-for-flash-messages">
<h5>Categories for Flash Messages<a class="headerlink" href="#categories-for-flash-messages" title="永久链接至标题">¶</a></h5>
<p>Flash messages can now have categories attached.  This makes it possible
to render errors, warnings or regular messages differently for example.
This is an opt-in feature because it requires some rethinking in the code.</p>
<p>Read all about that in the <a class="reference internal" href="index.html#message-flashing-pattern"><em>消息闪现</em></a> pattern.</p>
</div>
</div>
</div>
<span id="document-changelog"></span><div class="section" id="flask-changelog">
<h3>Flask Changelog<a class="headerlink" href="#flask-changelog" title="永久链接至标题">¶</a></h3>
<p>Here you can see the full list of changes between each Flask release.</p>
<div class="section" id="version-1-0">
<h4>Version 1.0<a class="headerlink" href="#version-1-0" title="永久链接至标题">¶</a></h4>
<p>(release date to be announced, codename to be selected)</p>
<ul class="simple">
<li>Added <tt class="docutils literal"><span class="pre">SESSION_REFRESH_EACH_REQUEST</span></tt> config key that controls the
set-cookie behavior. If set to <cite>True</cite> a permanent session will be
refreshed each request and get their lifetime extended, if set to
<cite>False</cite> it will only be modified if the session actually modifies.
Non permanent sessions are not affected by this and will always
expire if the browser window closes.</li>
</ul>
</div>
<div class="section" id="version-0-10-2">
<h4>Version 0.10.2<a class="headerlink" href="#version-0-10-2" title="永久链接至标题">¶</a></h4>
<p>(bugfix release, release date to be announced)</p>
<ul class="simple">
<li>Fixed broken <cite>test_appcontext_signals()</cite> test case.</li>
<li>Raise an <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#AttributeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> in <tt class="xref py py-func docutils literal"><span class="pre">flask.helpers.find_package()</span></tt> with a
useful message explaining why it is raised when a PEP 302 import hook is used
without an <cite>is_package()</cite> method.</li>
</ul>
</div>
<div class="section" id="version-0-10-1">
<h4>Version 0.10.1<a class="headerlink" href="#version-0-10-1" title="永久链接至标题">¶</a></h4>
<p>(bugfix release, released on June 14th 2013)</p>
<ul class="simple">
<li>Fixed an issue where <tt class="docutils literal"><span class="pre">|tojson</span></tt> was not quoting single quotes which
made the filter not work properly in HTML attributes. Now it&#8217;s
possible to use that filter in single quoted attributes. This should
make using that filter with angular.js easier.</li>
<li>Added support for byte strings back to the session system. This broke
compatibility with the common case of people putting binary data for
token verification into the session.</li>
<li>Fixed an issue where registering the same method twice for the same endpoint
would trigger an exception incorrectly.</li>
</ul>
</div>
<div class="section" id="version-0-10">
<h4>Version 0.10<a class="headerlink" href="#version-0-10" title="永久链接至标题">¶</a></h4>
<p>Released on June 13nd 2013, codename Limoncello.</p>
<ul class="simple">
<li>Changed default cookie serialization format from pickle to JSON to
limit the impact an attacker can do if the secret key leaks. See
<a class="reference internal" href="index.html#upgrading-to-010"><em>Version 0.10</em></a> for more information.</li>
<li>Added <tt class="docutils literal"><span class="pre">template_test</span></tt> methods in addition to the already existing
<tt class="docutils literal"><span class="pre">template_filter</span></tt> method family.</li>
<li>Added <tt class="docutils literal"><span class="pre">template_global</span></tt> methods in addition to the already existing
<tt class="docutils literal"><span class="pre">template_filter</span></tt> method family.</li>
<li>Set the content-length header for x-sendfile.</li>
<li><tt class="docutils literal"><span class="pre">tojson</span></tt> filter now does not escape script blocks in HTML5 parsers.</li>
<li><tt class="docutils literal"><span class="pre">tojson</span></tt> used in templates is now safe by default due. This was
allowed due to the different escaping behavior.</li>
<li>Flask will now raise an error if you attempt to register a new function
on an already used endpoint.</li>
<li>Added wrapper module around simplejson and added default serialization
of datetime objects. This allows much easier customization of how
JSON is handled by Flask or any Flask extension.</li>
<li>Removed deprecated internal <tt class="docutils literal"><span class="pre">flask.session</span></tt> module alias. Use
<tt class="docutils literal"><span class="pre">flask.sessions</span></tt> instead to get the session module. This is not to
be confused with <tt class="docutils literal"><span class="pre">flask.session</span></tt> the session proxy.</li>
<li>Templates can now be rendered without request context. The behavior is
slightly different as the <tt class="docutils literal"><span class="pre">request</span></tt>, <tt class="docutils literal"><span class="pre">session</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt> objects
will not be available and blueprint&#8217;s context processors are not
called.</li>
<li>The config object is now available to the template as a real global and
not through a context processor which makes it available even in imported
templates by default.</li>
<li>Added an option to generate non-ascii encoded JSON which should result
in less bytes being transmitted over the network. It&#8217;s disabled by
default to not cause confusion with existing libraries that might expect
<tt class="docutils literal"><span class="pre">flask.json.dumps</span></tt> to return bytestrings by default.</li>
<li><tt class="docutils literal"><span class="pre">flask.g</span></tt> is now stored on the app context instead of the request
context.</li>
<li><tt class="docutils literal"><span class="pre">flask.g</span></tt> now gained a <tt class="docutils literal"><span class="pre">get()</span></tt> method for not erroring out on non
existing items.</li>
<li><tt class="docutils literal"><span class="pre">flask.g</span></tt> now can be used with the <tt class="docutils literal"><span class="pre">in</span></tt> operator to see what&#8217;s defined
and it now is iterable and will yield all attributes stored.</li>
<li><tt class="docutils literal"><span class="pre">flask.Flask.request_globals_class</span></tt> got renamed to
<tt class="docutils literal"><span class="pre">flask.Flask.app_ctx_globals_class</span></tt> which is a better name to what it
does since 0.10.</li>
<li><cite>request</cite>, <cite>session</cite> and <cite>g</cite> are now also added as proxies to the template
context which makes them available in imported templates. One has to be
very careful with those though because usage outside of macros might
cause caching.</li>
<li>Flask will no longer invoke the wrong error handlers if a proxy
exception is passed through.</li>
<li>Added a workaround for chrome&#8217;s cookies in localhost not working
as intended with domain names.</li>
<li>Changed logic for picking defaults for cookie values from sessions
to work better with Google Chrome.</li>
<li>Added <cite>message_flashed</cite> signal that simplifies flashing testing.</li>
<li>Added support for copying of request contexts for better working with
greenlets.</li>
<li>Removed custom JSON HTTP exception subclasses. If you were relying on them
you can reintroduce them again yourself trivially. Using them however is
strongly discouraged as the interface was flawed.</li>
<li>Python requirements changed: requiring Python 2.6 or 2.7 now to prepare
for Python 3.3 port.</li>
<li>Changed how the teardown system is informed about exceptions. This is now
more reliable in case something handles an exception halfway through
the error handling process.</li>
<li>Request context preservation in debug mode now keeps the exception
information around which means that teardown handlers are able to
distinguish error from success cases.</li>
<li>Added the <tt class="docutils literal"><span class="pre">JSONIFY_PRETTYPRINT_REGULAR</span></tt> configuration variable.</li>
<li>Flask now orders JSON keys by default to not trash HTTP caches due to
different hash seeds between different workers.</li>
<li>Added <cite>appcontext_pushed</cite> and <cite>appcontext_popped</cite> signals.</li>
<li>The builtin run method now takes the <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> into account when
picking the default port to run on.</li>
<li>Added <cite>flask.request.get_json()</cite> as a replacement for the old
<cite>flask.request.json</cite> property.</li>
</ul>
</div>
<div class="section" id="version-0-9">
<h4>Version 0.9<a class="headerlink" href="#version-0-9" title="永久链接至标题">¶</a></h4>
<p>Released on July 1st 2012, codename Campari.</p>
<ul class="simple">
<li>The <a class="reference internal" href="index.html#flask.Request.on_json_loading_failed" title="flask.Request.on_json_loading_failed"><tt class="xref py py-func docutils literal"><span class="pre">flask.Request.on_json_loading_failed()</span></tt></a> now returns a JSON formatted
response by default.</li>
<li>The <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">flask.url_for()</span></tt></a> function now can generate anchors to the
generated links.</li>
<li>The <a class="reference internal" href="index.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">flask.url_for()</span></tt></a> function now can also explicitly generate
URL rules specific to a given HTTP method.</li>
<li>Logger now only returns the debug log setting if it was not set
explicitly.</li>
<li>Unregister a circular dependency between the WSGI environment and
the request object when shutting down the request. This means that
environ <tt class="docutils literal"><span class="pre">werkzeug.request</span></tt> will be <cite>None</cite> after the response was
returned to the WSGI server but has the advantage that the garbage
collector is not needed on CPython to tear down the request unless
the user created circular dependencies themselves.</li>
<li>Session is now stored after callbacks so that if the session payload
is stored in the session you can still modify it in an after
request callback.</li>
<li>The <a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">flask.Flask</span></tt></a> class will avoid importing the provided import name
if it can (the required first parameter), to benefit tools which build Flask
instances programmatically. The Flask class will fall back to using import
on systems with custom module hooks, e.g. Google App Engine, or when the
import name is inside a zip archive (usually a .egg) prior to Python 2.7.</li>
<li>Blueprints now have a decorator to add custom template filters application
wide, <a class="reference internal" href="index.html#flask.Blueprint.app_template_filter" title="flask.Blueprint.app_template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Blueprint.app_template_filter()</span></tt></a>.</li>
<li>The Flask and Blueprint classes now have a non-decorator method for adding
custom template filters application wide,
<a class="reference internal" href="index.html#flask.Flask.add_template_filter" title="flask.Flask.add_template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.add_template_filter()</span></tt></a> and
<a class="reference internal" href="index.html#flask.Blueprint.add_app_template_filter" title="flask.Blueprint.add_app_template_filter"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Blueprint.add_app_template_filter()</span></tt></a>.</li>
<li>The <a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">flask.get_flashed_messages()</span></tt></a> function now allows rendering flashed
message categories in separate blocks, through a <tt class="docutils literal"><span class="pre">category_filter</span></tt>
argument.</li>
<li>The <a class="reference internal" href="index.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.run()</span></tt></a> method now accepts <cite>None</cite> for <cite>host</cite> and <cite>port</cite>
arguments, using default values when <cite>None</cite>. This allows for calling run
using configuration values, e.g. <tt class="docutils literal"><span class="pre">app.run(app.config.get('MYHOST'),</span>
<span class="pre">app.config.get('MYPORT'))</span></tt>, with proper behavior whether or not a config
file is provided.</li>
<li>The <a class="reference internal" href="index.html#flask.render_template" title="flask.render_template"><tt class="xref py py-meth docutils literal"><span class="pre">flask.render_template()</span></tt></a> method now accepts a either an iterable of
template names or a single template name. Previously, it only accepted a
single template name. On an iterable, the first template found is rendered.</li>
<li>Added <a class="reference internal" href="index.html#flask.Flask.app_context" title="flask.Flask.app_context"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.app_context()</span></tt></a> which works very similar to the
request context but only provides access to the current application. This
also adds support for URL generation without an active request context.</li>
<li>View functions can now return a tuple with the first instance being an
instance of <a class="reference internal" href="index.html#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">flask.Response</span></tt></a>. This allows for returning
<tt class="docutils literal"><span class="pre">jsonify(error=&quot;error</span> <span class="pre">msg&quot;),</span> <span class="pre">400</span></tt> from a view function.</li>
<li><a class="reference internal" href="index.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> and <a class="reference internal" href="index.html#flask.Blueprint" title="flask.Blueprint"><tt class="xref py py-class docutils literal"><span class="pre">Blueprint</span></tt></a> now provide a
<a class="reference internal" href="index.html#flask.Flask.get_send_file_max_age" title="flask.Flask.get_send_file_max_age"><tt class="xref py py-meth docutils literal"><span class="pre">get_send_file_max_age()</span></tt></a> hook for subclasses to override
behavior of serving static files from Flask when using
<a class="reference internal" href="index.html#flask.Flask.send_static_file" title="flask.Flask.send_static_file"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Flask.send_static_file()</span></tt></a> (used for the default static file
handler) and <tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt>. This hook is provided a
filename, which for example allows changing cache controls by file extension.
The default max-age for <cite>send_file</cite> and static files can be configured
through a new <tt class="docutils literal"><span class="pre">SEND_FILE_MAX_AGE_DEFAULT</span></tt> configuration variable, which is
used in the default <cite>get_send_file_max_age</cite> implementation.</li>
<li>Fixed an assumption in sessions implementation which could break message
flashing on sessions implementations which use external storage.</li>
<li>Changed the behavior of tuple return values from functions. They are no
longer arguments to the response object, they now have a defined meaning.</li>
<li>Added <tt class="xref py py-attr docutils literal"><span class="pre">flask.Flask.request_globals_class</span></tt> to allow a specific class to
be used on creation of the <a class="reference internal" href="index.html#flask.g" title="flask.g"><tt class="xref py py-data docutils literal"><span class="pre">g</span></tt></a> instance of each request.</li>
<li>Added <cite>required_methods</cite> attribute to view functions to force-add methods
on registration.</li>
<li>Added <tt class="xref py py-func docutils literal"><span class="pre">flask.after_this_request()</span></tt>.</li>
<li>Added <a class="reference internal" href="index.html#flask.stream_with_context" title="flask.stream_with_context"><tt class="xref py py-func docutils literal"><span class="pre">flask.stream_with_context()</span></tt></a> and the ability to push contexts
multiple times without producing unexpected behavior.</li>
</ul>
</div>
<div class="section" id="version-0-8-1">
<h4>Version 0.8.1<a class="headerlink" href="#version-0-8-1" title="永久链接至标题">¶</a></h4>
<p>Bugfix release, released on July 1st 2012</p>
<ul class="simple">
<li>Fixed an issue with the undocumented <cite>flask.session</cite> module to not
work properly on Python 2.5. It should not be used but did cause
some problems for package managers.</li>
</ul>
</div>
<div class="section" id="version-0-8">
<h4>Version 0.8<a class="headerlink" href="#version-0-8" title="永久链接至标题">¶</a></h4>
<p>Released on September 29th 2011, codename Rakija</p>
<ul class="simple">
<li>Refactored session support into a session interface so that
the implementation of the sessions can be changed without
having to override the Flask class.</li>
<li>Empty session cookies are now deleted properly automatically.</li>
<li>View functions can now opt out of getting the automatic
OPTIONS implementation.</li>
<li>HTTP exceptions and Bad Request errors can now be trapped so that they
show up normally in the traceback.</li>
<li>Flask in debug mode is now detecting some common problems and tries to
warn you about them.</li>
<li>Flask in debug mode will now complain with an assertion error if a view
was attached after the first request was handled. This gives earlier
feedback when users forget to import view code ahead of time.</li>
<li>Added the ability to register callbacks that are only triggered once at
the beginning of the first request. (<tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_first_request()</span></tt>)</li>
<li>Malformed JSON data will now trigger a bad request HTTP exception instead
of a value error which usually would result in a 500 internal server
error if not handled. This is a backwards incompatible change.</li>
<li>Applications now not only have a root path where the resources and modules
are located but also an instance path which is the designated place to
drop files that are modified at runtime (uploads etc.). Also this is
conceptionally only instance depending and outside version control so it&#8217;s
the perfect place to put configuration files etc. For more information
see <a class="reference internal" href="index.html#instance-folders"><em>实例文件夹</em></a>.</li>
<li>Added the <tt class="docutils literal"><span class="pre">APPLICATION_ROOT</span></tt> configuration variable.</li>
<li>Implemented <tt class="xref py py-meth docutils literal"><span class="pre">session_transaction()</span></tt> to
easily modify sessions from the test environment.</li>
<li>Refactored test client internally. The <tt class="docutils literal"><span class="pre">APPLICATION_ROOT</span></tt> configuration
variable as well as <tt class="docutils literal"><span class="pre">SERVER_NAME</span></tt> are now properly used by the test client
as defaults.</li>
<li>Added <a class="reference internal" href="index.html#flask.views.View.decorators" title="flask.views.View.decorators"><tt class="xref py py-attr docutils literal"><span class="pre">flask.views.View.decorators</span></tt></a> to support simpler decorating of
pluggable (class-based) views.</li>
<li>Fixed an issue where the test client if used with the &#8220;with&#8221; statement did not
trigger the execution of the teardown handlers.</li>
<li>Added finer control over the session cookie parameters.</li>
<li>HEAD requests to a method view now automatically dispatch to the <cite>get</cite>
method if no handler was implemented.</li>
<li>Implemented the virtual <tt class="xref py py-mod docutils literal"><span class="pre">flask.ext</span></tt> package to import extensions from.</li>
<li>The context preservation on exceptions is now an integral component of
Flask itself and no longer of the test client. This cleaned up some
internal logic and lowers the odds of runaway request contexts in unittests.</li>
</ul>
</div>
<div class="section" id="version-0-7-3">
<h4>Version 0.7.3<a class="headerlink" href="#version-0-7-3" title="永久链接至标题">¶</a></h4>
<p>Bugfix release, release date to be decided</p>
<ul class="simple">
<li>Fixed the Jinja2 environment&#8217;s list_templates method not returning the
correct names when blueprints or modules were involved.</li>
</ul>
</div>
<div class="section" id="version-0-7-2">
<h4>Version 0.7.2<a class="headerlink" href="#version-0-7-2" title="永久链接至标题">¶</a></h4>
<p>Bugfix release, released on July 6th 2011</p>
<ul class="simple">
<li>Fixed an issue with URL processors not properly working on
blueprints.</li>
</ul>
</div>
<div class="section" id="version-0-7-1">
<h4>Version 0.7.1<a class="headerlink" href="#version-0-7-1" title="永久链接至标题">¶</a></h4>
<p>Bugfix release, released on June 29th 2011</p>
<ul class="simple">
<li>Added missing future import that broke 2.5 compatibility.</li>
<li>Fixed an infinite redirect issue with blueprints.</li>
</ul>
</div>
<div class="section" id="version-0-7">
<h4>Version 0.7<a class="headerlink" href="#version-0-7" title="永久链接至标题">¶</a></h4>
<p>Released on June 28th 2011, codename Grappa</p>
<ul class="simple">
<li>Added <a class="reference internal" href="index.html#flask.Flask.make_default_options_response" title="flask.Flask.make_default_options_response"><tt class="xref py py-meth docutils literal"><span class="pre">make_default_options_response()</span></tt></a>
which can be used by subclasses to alter the default
behavior for <cite>OPTIONS</cite> responses.</li>
<li>Unbound locals now raise a proper <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#RuntimeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> instead
of an <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#AttributeError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a>.</li>
<li>Mimetype guessing and etag support based on file objects is now
deprecated for <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">flask.send_file()</span></tt></a> because it was unreliable.
Pass filenames instead or attach your own etags and provide a
proper mimetype by hand.</li>
<li>Static file handling for modules now requires the name of the
static folder to be supplied explicitly. The previous autodetection
was not reliable and caused issues on Google&#8217;s App Engine. Until
1.0 the old behavior will continue to work but issue dependency
warnings.</li>
<li>fixed a problem for Flask to run on jython.</li>
<li>added a <cite>PROPAGATE_EXCEPTIONS</cite> configuration variable that can be
used to flip the setting of exception propagation which previously
was linked to <cite>DEBUG</cite> alone and is now linked to either <cite>DEBUG</cite> or
<cite>TESTING</cite>.</li>
<li>Flask no longer internally depends on rules being added through the
<cite>add_url_rule</cite> function and can now also accept regular werkzeug
rules added to the url map.</li>
<li>Added an <cite>endpoint</cite> method to the flask application object which
allows one to register a callback to an arbitrary endpoint with
a decorator.</li>
<li>Use Last-Modified for static file sending instead of Date which
was incorrectly introduced in 0.6.</li>
<li>Added <cite>create_jinja_loader</cite> to override the loader creation process.</li>
<li>Implemented a silent flag for <cite>config.from_pyfile</cite>.</li>
<li>Added <cite>teardown_request</cite> decorator, for functions that should run at the end
of a request regardless of whether an exception occurred. Also the behavior
for <cite>after_request</cite> was changed. It&#8217;s now no longer executed when an exception
is raised. See <a class="reference internal" href="index.html#upgrading-to-new-teardown-handling"><em>Upgrading to new Teardown Handling</em></a></li>
<li>Implemented <a class="reference internal" href="index.html#flask.has_request_context" title="flask.has_request_context"><tt class="xref py py-func docutils literal"><span class="pre">flask.has_request_context()</span></tt></a></li>
<li>Deprecated <cite>init_jinja_globals</cite>. Override the
<a class="reference internal" href="index.html#flask.Flask.create_jinja_environment" title="flask.Flask.create_jinja_environment"><tt class="xref py py-meth docutils literal"><span class="pre">create_jinja_environment()</span></tt></a> method instead to
achieve the same functionality.</li>
<li>Added <a class="reference internal" href="index.html#flask.safe_join" title="flask.safe_join"><tt class="xref py py-func docutils literal"><span class="pre">flask.safe_join()</span></tt></a></li>
<li>The automatic JSON request data unpacking now looks at the charset
mimetype parameter.</li>
<li>Don&#8217;t modify the session on <a class="reference internal" href="index.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">flask.get_flashed_messages()</span></tt></a> if there
are no messages in the session.</li>
<li><cite>before_request</cite> handlers are now able to abort requests with errors.</li>
<li>it is not possible to define user exception handlers. That way you can
provide custom error messages from a central hub for certain errors that
might occur during request processing (for instance database connection
errors, timeouts from remote resources etc.).</li>
<li>Blueprints can provide blueprint specific error handlers.</li>
<li>Implemented generic <a class="reference internal" href="index.html#views"><em>即插视图</em></a> (class-based views).</li>
</ul>
</div>
<div class="section" id="version-0-6-1">
<h4>Version 0.6.1<a class="headerlink" href="#version-0-6-1" title="永久链接至标题">¶</a></h4>
<p>Bugfix release, released on December 31st 2010</p>
<ul class="simple">
<li>Fixed an issue where the default <cite>OPTIONS</cite> response was
not exposing all valid methods in the <cite>Allow</cite> header.</li>
<li>Jinja2 template loading syntax now allows &#8221;./&#8221; in front of
a template load path. Previously this caused issues with
module setups.</li>
<li>Fixed an issue where the subdomain setting for modules was
ignored for the static folder.</li>
<li>Fixed a security problem that allowed clients to download arbitrary files
if the host server was a windows based operating system and the client
uses backslashes to escape the directory the files where exposed from.</li>
</ul>
</div>
<div class="section" id="version-0-6">
<h4>Version 0.6<a class="headerlink" href="#version-0-6" title="永久链接至标题">¶</a></h4>
<p>Released on July 27th 2010, codename Whisky</p>
<ul class="simple">
<li>after request functions are now called in reverse order of
registration.</li>
<li>OPTIONS is now automatically implemented by Flask unless the
application explicitly adds &#8216;OPTIONS&#8217; as method to the URL rule.
In this case no automatic OPTIONS handling kicks in.</li>
<li>static rules are now even in place if there is no static folder
for the module. This was implemented to aid GAE which will
remove the static folder if it&#8217;s part of a mapping in the .yml
file.</li>
<li>the <a class="reference internal" href="index.html#flask.Flask.config" title="flask.Flask.config"><tt class="xref py py-attr docutils literal"><span class="pre">config</span></tt></a> is now available in the templates
as <cite>config</cite>.</li>
<li>context processors will no longer override values passed directly
to the render function.</li>
<li>added the ability to limit the incoming request data with the
new <tt class="docutils literal"><span class="pre">MAX_CONTENT_LENGTH</span></tt> configuration value.</li>
<li>the endpoint for the <tt class="xref py py-meth docutils literal"><span class="pre">flask.Module.add_url_rule()</span></tt> method
is now optional to be consistent with the function of the
same name on the application object.</li>
<li>added a <a class="reference internal" href="index.html#flask.make_response" title="flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">flask.make_response()</span></tt></a> function that simplifies
creating response object instances in views.</li>
<li>added signalling support based on blinker. This feature is currently
optional and supposed to be used by extensions and applications. If
you want to use it, make sure to have <a class="reference external" href="http://pypi.python.org/pypi/blinker">blinker</a> installed.</li>
<li>refactored the way URL adapters are created. This process is now
fully customizable with the <a class="reference internal" href="index.html#flask.Flask.create_url_adapter" title="flask.Flask.create_url_adapter"><tt class="xref py py-meth docutils literal"><span class="pre">create_url_adapter()</span></tt></a>
method.</li>
<li>modules can now register for a subdomain instead of just an URL
prefix. This makes it possible to bind a whole module to a
configurable subdomain.</li>
</ul>
</div>
<div class="section" id="version-0-5-2">
<h4>Version 0.5.2<a class="headerlink" href="#version-0-5-2" title="永久链接至标题">¶</a></h4>
<p>Bugfix Release, released on July 15th 2010</p>
<ul class="simple">
<li>fixed another issue with loading templates from directories when
modules were used.</li>
</ul>
</div>
<div class="section" id="version-0-5-1">
<h4>Version 0.5.1<a class="headerlink" href="#version-0-5-1" title="永久链接至标题">¶</a></h4>
<p>Bugfix Release, released on July 6th 2010</p>
<ul class="simple">
<li>fixes an issue with template loading from directories when modules
where used.</li>
</ul>
</div>
<div class="section" id="version-0-5">
<h4>Version 0.5<a class="headerlink" href="#version-0-5" title="永久链接至标题">¶</a></h4>
<p>Released on July 6th 2010, codename Calvados</p>
<ul class="simple">
<li>fixed a bug with subdomains that was caused by the inability to
specify the server name. The server name can now be set with
the <cite>SERVER_NAME</cite> config key. This key is now also used to set
the session cookie cross-subdomain wide.</li>
<li>autoescaping is no longer active for all templates. Instead it
is only active for <tt class="docutils literal"><span class="pre">.html</span></tt>, <tt class="docutils literal"><span class="pre">.htm</span></tt>, <tt class="docutils literal"><span class="pre">.xml</span></tt> and <tt class="docutils literal"><span class="pre">.xhtml</span></tt>.
Inside templates this behavior can be changed with the
<tt class="docutils literal"><span class="pre">autoescape</span></tt> tag.</li>
<li>refactored Flask internally. It now consists of more than a
single file.</li>
<li><a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">flask.send_file()</span></tt></a> now emits etags and has the ability to
do conditional responses builtin.</li>
<li>(temporarily) dropped support for zipped applications. This was a
rarely used feature and led to some confusing behavior.</li>
<li>added support for per-package template and static-file directories.</li>
<li>removed support for <cite>create_jinja_loader</cite> which is no longer used
in 0.5 due to the improved module support.</li>
<li>added a helper function to expose files from any directory.</li>
</ul>
</div>
<div class="section" id="version-0-4">
<h4>Version 0.4<a class="headerlink" href="#version-0-4" title="永久链接至标题">¶</a></h4>
<p>Released on June 18th 2010, codename Rakia</p>
<ul class="simple">
<li>added the ability to register application wide error handlers
from modules.</li>
<li><a class="reference internal" href="index.html#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> handlers are now also invoked
if the request dies with an exception and an error handling page
kicks in.</li>
<li>test client has not the ability to preserve the request context
for a little longer. This can also be used to trigger custom
requests that do not pop the request stack for testing.</li>
<li>because the Python standard library caches loggers, the name of
the logger is configurable now to better support unittests.</li>
<li>added <cite>TESTING</cite> switch that can activate unittesting helpers.</li>
<li>the logger switches to <cite>DEBUG</cite> mode now if debug is enabled.</li>
</ul>
</div>
<div class="section" id="version-0-3-1">
<h4>Version 0.3.1<a class="headerlink" href="#version-0-3-1" title="永久链接至标题">¶</a></h4>
<p>Bugfix release, released on May 28th 2010</p>
<ul class="simple">
<li>fixed a error reporting bug with <a class="reference internal" href="index.html#flask.Config.from_envvar" title="flask.Config.from_envvar"><tt class="xref py py-meth docutils literal"><span class="pre">flask.Config.from_envvar()</span></tt></a></li>
<li>removed some unused code from flask</li>
<li>release does no longer include development leftover files (.git
folder for themes, built documentation in zip and pdf file and
some .pyc files)</li>
</ul>
</div>
<div class="section" id="version-0-3">
<h4>Version 0.3<a class="headerlink" href="#version-0-3" title="永久链接至标题">¶</a></h4>
<p>Released on May 28th 2010, codename Schnaps</p>
<ul class="simple">
<li>added support for categories for flashed messages.</li>
<li>the application now configures a <tt class="xref py py-class docutils literal"><span class="pre">logging.Handler</span></tt> and will
log request handling exceptions to that logger when not in debug
mode. This makes it possible to receive mails on server errors
for example.</li>
<li>added support for context binding that does not require the use of
the with statement for playing in the console.</li>
<li>the request context is now available within the with statement making
it possible to further push the request context or pop it.</li>
<li>added support for configurations.</li>
</ul>
</div>
<div class="section" id="version-0-2">
<h4>Version 0.2<a class="headerlink" href="#version-0-2" title="永久链接至标题">¶</a></h4>
<p>Released on May 12th 2010, codename Jägermeister</p>
<ul class="simple">
<li>various bugfixes</li>
<li>integrated JSON support</li>
<li>added <a class="reference internal" href="index.html#flask.get_template_attribute" title="flask.get_template_attribute"><tt class="xref py py-func docutils literal"><span class="pre">get_template_attribute()</span></tt></a> helper function.</li>
<li><a class="reference internal" href="index.html#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">add_url_rule()</span></tt></a> can now also register a
view function.</li>
<li>refactored internal request dispatching.</li>
<li>server listens on 127.0.0.1 by default now to fix issues with chrome.</li>
<li>added external URL support.</li>
<li>added support for <a class="reference internal" href="index.html#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a></li>
<li>module support and internal request handling refactoring
to better support pluggable applications.</li>
<li>sessions can be set to be permanent now on a per-session basis.</li>
<li>better error reporting on missing secret keys.</li>
<li>added support for Google Appengine.</li>
</ul>
</div>
<div class="section" id="version-0-1">
<h4>Version 0.1<a class="headerlink" href="#version-0-1" title="永久链接至标题">¶</a></h4>
<p>First public preview release.</p>
</div>
</div>
<span id="document-license"></span><div class="section" id="id1">
<h3>许可证<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>Flask 由一个三条款的 BSD 许可证许可。基本上可以认为：你可以用它做任何事情，
只要版权在 Flask 的支持范围内，条款不能被修改，并且提供免责声明。
此外，你不可以在没有书面同意的情况下使用作者的名字来推广衍生作品。</p>
<p>完整的许可证可以在下面找到（ <a class="reference internal" href="index.html#flask-license"><em>Flask License</em></a> ）。对于文档和艺术作品，
使用不同的许可证。</p>
<div class="section" id="authors">
<span id="id2"></span><h4>作者<a class="headerlink" href="#authors" title="永久链接至标题">¶</a></h4>
<p>Flask is written and maintained by Armin Ronacher and
various contributors:</p>
<div class="section" id="development-lead">
<h5>Development Lead<a class="headerlink" href="#development-lead" title="永久链接至标题">¶</a></h5>
<ul class="simple">
<li>Armin Ronacher &lt;<a class="reference external" href="mailto:armin&#46;ronacher&#37;&#52;&#48;active-4&#46;com">armin<span>&#46;</span>ronacher<span>&#64;</span>active-4<span>&#46;</span>com</a>&gt;</li>
</ul>
</div>
<div class="section" id="patches-and-suggestions">
<h5>Patches and Suggestions<a class="headerlink" href="#patches-and-suggestions" title="永久链接至标题">¶</a></h5>
<ul class="simple">
<li>Adam Zapletal</li>
<li>Ali Afshar</li>
<li>Chris Edgemon</li>
<li>Chris Grindstaff</li>
<li>Christopher Grebs</li>
<li>Florent Xicluna</li>
<li>Georg Brandl</li>
<li>Justin Quick</li>
<li>Kenneth Reitz</li>
<li>Marian Sigler</li>
<li>Matt Campell</li>
<li>Matthew Frazier</li>
<li>Michael van Tellingen</li>
<li>Ron DuPlain</li>
<li>Sebastien Estienne</li>
<li>Simon Sapin</li>
<li>Stephane Wirtel</li>
<li>Thomas Schranz</li>
<li>Zhao Xiaohong</li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h4>通用许可证定义<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>下面的章节包含完整的 Flask 及其文档的许可证文本。</p>
<ul class="simple">
<li>在此 <a class="reference internal" href="index.html#authors"><em>作者</em></a> 节中列出的所有作者引用自 &#8220;AUTHORS&#8221; 。</li>
<li>&#8220;<a class="reference internal" href="index.html#flask-license"><em>Flask License</em></a>&#8221; 适用于所有作为 Flask 一部分的源代码（ Flask 本
身，同样也包含实例和单元测试），以及文档。</li>
<li>&#8220;<a class="reference internal" href="index.html#artwork-license"><em>Flask Artwork License</em></a>&#8221; 适用于 Flask 的长角标志（Horn-Logo）。</li>
</ul>
</div>
<div class="section" id="flask-license">
<span id="id4"></span><h4>Flask License<a class="headerlink" href="#flask-license" title="永久链接至标题">¶</a></h4>
<p>Copyright (c) 2012 by Armin Ronacher and contributors.  See AUTHORS
for more details.</p>
<p>Some rights reserved.</p>
<p>Redistribution and use in source and binary forms of the software as well
as documentation, with or without modification, are permitted provided
that the following conditions are met:</p>
<ul class="simple">
<li>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided
with the distribution.</li>
<li>The names of the contributors may not be used to endorse or
promote products derived from this software without specific
prior written permission.</li>
</ul>
<p>THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND
CONTRIBUTORS &#8220;AS IS&#8221; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE AND DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.</p>
</div>
<div class="section" id="flask-artwork-license">
<span id="artwork-license"></span><h4>Flask Artwork License<a class="headerlink" href="#flask-artwork-license" title="永久链接至标题">¶</a></h4>
<p>Copyright (c) 2010 by Armin Ronacher.</p>
<p>Some rights reserved.</p>
<p>This logo or a modified version may be used by anyone to refer to the
Flask project, but does not indicate endorsement by the project.</p>
<p>Redistribution and use in source (the SVG file) and binary forms (rendered
PNG files etc.) of the image, with or without modification, are permitted
provided that the following conditions are met:</p>
<ul class="simple">
<li>Redistributions of source code must retain the above copyright
notice and this list of conditions.</li>
<li>The names of the contributors to the Flask software (see AUTHORS) may
not be used to endorse or promote products derived from this software
without specific prior written permission.</li>
</ul>
<p>Note: we would appreciate that you make the image a link to
<a class="reference external" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a> if you use it on a web page.</p>
</div>
</div>
<span id="document-glossary"></span><div class="section" id="id1">
<h3>术语表<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt>Application / App</dt>
<dd>应用</dd>
<dt>Application Context</dt>
<dd>应用上下文</dd>
<dt>Blueprint</dt>
<dd>蓝图</dd>
<dt>Bubble up</dt>
<dd>冒泡</dd>
<dt>Configuration / Config</dt>
<dd>配置</dd>
<dt>Context Locals</dt>
<dd>上下文局部变量</dd>
<dt>Context-local</dt>
<dd>上下文本地（局域）的</dd>
<dt>Debugger</dt>
<dd>调试器</dd>
<dt>Handler</dt>
<dd>处理程序</dd>
<dt>Handling</dt>
<dd>处理</dd>
<dt>Header</dt>
<dd>标头</dd>
<dt>Logger</dt>
<dd>日志记录器</dd>
<dt>Message Flashing</dt>
<dd>消息闪现</dd>
<dt>Object Literal</dt>
<dd>对象字面量</dd>
<dt>Processor</dt>
<dd>处理器</dd>
<dt>Redirect</dt>
<dd>重定向</dd>
<dt>Request Context</dt>
<dd>请求上下文</dd>
<dt>Sender</dt>
<dd>（信号的）发送者</dd>
<dt>Set / Setting</dt>
<dd>设定</dd>
<dt>Signal</dt>
<dd>信号</dd>
<dt>Token</dt>
<dd>令牌</dd>
<dt>Worker</dt>
<dd>职程</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><h3>关于 Flask</h3>
<p>
  Flask 是一个 Python 实现的 Web 开发微框架。你正在阅读开发版本的文档。
</p>
<h3>译者</h3>
<p>
  <strong>亦念</strong><br />
  <a href="mailto:yinian1992@gmail.com">yinian1992@gmail.com</a>
</o>
<p>
  <strong>云尔</strong><br />
  <a href="mailto:yun.er.run@gmail.com">yun.er.run@gmail.com</a>
</p>
<p>
  <strong>atupal</strong><br />
  <a href="mailto:me@atupal.org">me@atupal.org</a>
</p>
<h3>其它格式</h3>
<p>
  你同样可以下载其它格式的文档:
</p>
<ul>
  <li><a href="https://media.readthedocs.org/epub/flask-chs/latest/flask-chs.epub">ePub（简体中文）</a>
  <li><a href="https://media.readthedocs.org/htmlzip/flask-chs/latest/flask-chs.zip">zip 压缩的 HTML（简体中文）</a>
  <li><a href="http://flask.pocoo.org/docs/flask-docs.pdf">PDF（英文）</a>
  <li><a href="http://flask.pocoo.org/docs/flask-docs.epub">ePub（英文）</a>
  <li><a href="http://flask.pocoo.org/docs/flask-docs.mobi">.mobi（英文）</a>
  <li><a href="http://flask.pocoo.org/docs/flask-docs.zip">zip 压缩的 HTML（英文）</a>
</ul>
<h3>链接</h3>
<ul>
  <li><a href="http://flask.pocoo.org/">Flask 官方网站</a></li>
  <li><a href="http://pypi.python.org/pypi/Flask">Flask @ PyPI</a></li>
  <li><a href="http://github.com/mitsuhiko/flask">Flask @ github</a></li>
  <li><a href="http://github.com/mitsuhiko/flask/issues">问题跟踪</a></li>
</ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright 2013, Armin Ronacher.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  
  </div>
  
  </body>
</html>